<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  类型 - Swift 3.0 官方文档 自整理 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 官方文档 自整理 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 官方文档 自整理 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 官方文档 自整理 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识 待" href="14743596331025.html">基础知识 待</a></li>
          
            <li><a title="基础运算操作 待" href="14743596434163.html">基础运算操作 待</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="控制流" href="14743597355186.html">控制流</a></li>
          
            <li><a title="函数" href="14743597582027.html">函数</a></li>
          
            <li><a title="闭包" href="14743597798199.html">闭包</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标语法" href="14743598556978.html">下标语法</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743599314901.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识 待" href="14743596331025.html">基础知识 待</a></li>
                        
                          <li><a title="基础运算操作 待" href="14743596434163.html">基础运算操作 待</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="控制流" href="14743597355186.html">控制流</a></li>
                        
                          <li><a title="函数" href="14743597582027.html">函数</a></li>
                        
                          <li><a title="闭包" href="14743597798199.html">闭包</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标语法" href="14743598556978.html">下标语法</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743599314901.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>类型</h1>

<p>在斯威夫特，有两种类型：命名类型和复合类型。一个命名的类型是可以给它的定义是当一个特定名称的类型。命名类型包括类，结构，枚举和协议。例如，命名为用户定义的类的实例MyClass有类型MyClass。除了 ​​用户定义的命名类型，雨燕标准库定义了许多常用的命名类型，包括代表数组，字典和可选值。</p>

<p>这通常被认为基本或原始的其他语言，如类型数据类型表示数字，字符和字符串，实际上命名类型，定义和使用结构，雨燕标准库实现的。因为他们命名的类型，你可以扩展自己的行为以适应你的程序的需要，使用扩展声明，讨论的扩展和延伸宣言。</p>

<p>一个复合型是没有名字的类型，在雨燕语言本身定义的。有两种复合类型：函数类型和元组类型。化合物类型可能包含命名的类型等复合类型。例如，元组类型(Int, (Int, Int))包含两个元素：第一个是命名类型Int，而第二个是另一种化合物的类型(Int, Int)。</p>

<p>本章讨论雨燕语言本身定义的类型，并描述了斯威夫特的类型推断行为。</p>

<p>一类型的语法</p>

<p>类型 → 数组类型的字典型功能型类型标识符元组型可选式隐式展开，可选式协议的组成型元类型型 ­          Any­  Self­<br/>
类型标注</p>

<p>一个类型标注明确指定变量或表达式的类型。类型注释用冒号（开始:）和一个类型结束，如下面的例子说明：</p>

<p>let someTuple: (Double, Double) = (3.14159, 2.71828)<br/>
func someFunction(a: Int) { /* ... */ }<br/>
在第一示例中，表达式someTuple被指定为具有元组类型(Double, Double)。在第二个例子中，该参数a的函数someFunction被指定为具有类型Int。</p>

<p>类型注解可以包含类型之前类型的属性的可选列表。</p>

<p>类型注释语法</p>

<p>类型标注 → 属性选择 选择 类型:­inout­<br/>
类型标识符</p>

<p>A型标识指的是命名类型或命名或复合类型的类型别名。</p>

<p>大部分时间，一个类型识别符直接指的是一个命名类型具有相同的名称作为标识符。例如，Int是直接引用命名类型的类型标识符Int和类型标识符Dictionary<String, Int>直接引用命名的类型Dictionary<String, Int>。</p>

<p>有两种情况，其中一个类型标识符不指一种类型具有相同的名称。在第一种情况下，一个类型识别符是指一种命名或化合物类型的类型别名。例如，在下面的例子中，利用Point在类型标注指元组类型(Int, Int)。</p>

<p>typealias Point = (Int, Int)<br/>
let origin: Point = (0, 0)<br/>
在第二种情况下，一个类型标识符使用点（.）语法来引用其他模块中声明或嵌套在其他类型的内命名的类型。例如，在下面的代码类型标识符引用命名类型MyType是中声明的ExampleModule模块。</p>

<p>var someValue: ExampleModule.MyType<br/>
一个类型标识符的语法</p>

<p>类型标识符 → 类型名称仿制参数子句选择类型名称仿制参数子句选择类型标识符 ­   .­<br/>
类型名 → 标识 ­<br/>
元组类型</p>

<p>元组类型是一个逗号分隔的零个或多个类型的列表，用括号括起来。</p>

<p>你可以使用一个元组类型作为函数的返回类型，以使该函数返回一个包含多个值一个元组。你还可以命名一个元组类型中的元素，并使用这些名称来指各元素的值。元素名称是由一个标识符由一个冒号（:)后面紧跟的。有关演示这两个功能的示例，请参阅使用多个返回值的函数。</p>

<p>当一个元组类型的元素具有名称，该名称是类型的一部分​​。</p>

<p>var someTuple = (top: 10, bottom: 12)  // someTuple is of type (top: Int, bottom: Int)<br/>
someTuple = (top: 4, bottom: 42) // OK: names match<br/>
someTuple = (9, 99)              // OK: names are inferred<br/>
someTuple = (left: 5, right: 5)  // Error: names don&#39;t match<br/>
Void对于空的元组类型的类型别名()。如果仅存在一个的括号内的元素，其类型是简单的元件的类型。例如，该类型(Int)是Int，不(Int)。其结果是，可以只有当所述元组类型有两个或更多个元件仅举元组的元素。</p>

<p>一个元组类型的文法</p>

<p>元组型 → 元组类型的元素列表选择(­)­<br/>
元组型元件列表 → 元组型元件的元组类型的元元组型元件列表 ­  ,­<br/>
元组类型元素 → 元素名称类型注释类型<br/><br/>
元素名称 → 标识符 ­<br/>
功能类型</p>

<p>函数类型表示一个函数，方法，或闭合的类型和组成由箭头分开（一个参数和返回类型-&gt;）：</p>

<p>（参数类型） - &gt; 返回类型<br/>
该参数类型为类型的逗号分隔列表。由于返回类型可以是一个元组类型，功能类型支持返回多个值的函数和方法。</p>

<p>该函数类型的参数() -&gt; T（其中T任何类型的）可以应用autoclosure到隐式地创建在其调用点的封闭属性。这提供了语法方便的方式来推迟表达式的评价，而不需要在调用函数写一个明确的关闭。用于autoclosure函数类型参数的示例，参见Autoclosures。</p>

<p>函数类型可以在其一个可变参数的参数参数类型。在语法上，一个可变参数的参数包括一个基本类型名称由三个点（紧接着的...），如Int...，一个可变参数的参数被视为包含基本类型名称的元素的数组。例如，所述可变参数的参数Int...被视为[Int]。对于使用可变参数的参数示例，请参阅可变参数的参数。</p>

<p>要指定在输出参数，可以在前面的参数类型inout关键字。你不能标记可变参数参数或用返回类型inout的关键字。在输出参数在讨论的In-Out参数。</p>

<p>在功能参数名称和方法不对应的功能类型的一部分​​。例如：</p>

<p>func someFunction(left: Int, right: Int) {}<br/>
func anotherFunction(left: Int, right: Int) {}<br/>
func functionWithDifferentLabels(top: Int, bottom: Int) {}</p>

<p>var f = someFunction // The type of f is (Int, Int) -&gt; Void, not (left: Int, right: Int) -&gt; Void.<br/>
f = anotherFunction              // OK<br/>
f = functionWithDifferentLabels  // OK</p>

<p>func functionWithDifferentArgumentTypes(left: Int, right: String) {}<br/>
func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}</p>

<p>f = functionWithDifferentArgumentTypes     // Error<br/>
f = functionWithDifferentNumberOfArguments // Error<br/>
如果函数类型包括多单箭头（多-&gt;），功能类型从右到左进行分组。例如，功能类型(Int) -&gt; (Int) -&gt; Int被理解为(Int) -&gt; ((Int) -&gt; Int)，也就是说，一个函数，一个Int并返回另一个函数，该函数返回一个Int。</p>

<p>可以抛出一个错误的函数类型必须标明的throws关键字，并可以重新抛出误差函数类型必须与被标记rethrows关键字。的throws关键字是一个函数的类型的一部分，和nonthrowing函数是投掷函数的亚型。其结果是，你可以在同一个地方使用nonthrowing函数作为投掷之一。投掷和重新抛出功能描述投掷函数和方法，并重新抛出函数和方法。</p>

<p>函数类型的语法</p>

<p>功能型 → 属性选择功能型参数子句选择 型throws­-&gt;­<br/>
功能型 → 属性选择功能型参数子句型rethrows­-&gt;­<br/>
功能型参数子句 → (­)­<br/>
功能型参数子句 → 函数类型参数列表选择(­...­)­<br/>
功能型参数列表 → 函数类型参数的函数类型参数的函数类型参数列表 ­  ,­<br/>
功能型参数 → 属性选择 选择 类型 的参数标签类型注释 ­ inout­<br/><br/>
参数标签 → 标识符 ­<br/>
数组类型</p>

<p>雨燕的语言提供了雨燕标准库下面的语法糖Array<Element>类型：</p>

<p>[ 类型 ]<br/>
换句话说，下面两个声明是等价的：</p>

<p>let someArray: Array<String> = [<q>Alex</q>, <q>Brian</q>, <q>Dave</q>]<br/>
let someArray: [String] = [<q>Alex</q>, <q>Brian</q>, <q>Dave</q>]<br/>
在这两种情况下，常数someArray被声明为字符串数组。数组的元素可以通过下标通过指定方括号中的有效下标值来访问：someArray[0]是指在元素索引0 <q>Alex</q>。</p>

<p>您可以通过嵌套双方括号，其中基本类型元素的名称包含在最里面的一对括号的创建多维数组。例如，您可以创建一个使用三套方括号的整数三维数组：</p>

<p>var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]<br/>
当在多维数组访问的元素，最左边的下标指数指的是元件的最外数组中该索引位置。接下来的下标指数向右指的是元素的嵌套在一个水平数组中的索引。等等。这意味着，在上述的例子中，array3D[0]是指[[1, 2], [3, 4]]，array3D[0][1]指的是[3, 4]，并array3D[0][1][1]指的是值4。</p>

<p>对于斯威夫特标准库的详细讨论Array类型，请参阅阵列。</p>

<p>数组类型的文法</p>

<p>数组类型 → 类型 ­[­]­<br/>
字典类型</p>

<p>雨燕的语言提供了雨燕标准库下面的语法糖Dictionary<Key, Value>类型：</p>

<p>[ 密钥类型：价值型 ]<br/>
换句话说，下面两个声明是等价的：</p>

<p>let someDictionary: [String: Int] = [<q>Alex</q>: 31, <q>Paul</q>: 39]<br/>
let someDictionary: Dictionary<String, Int> = [<q>Alex</q>: 31, <q>Paul</q>: 39]<br/>
在这两种情况下，常数someDictionary被声明为与字符串作为键和整数作为值的字典。</p>

<p>字典的值可以通过下标通过指定方括号中的相应键来访问：someDictionary[<q>Alex</q>]是指与键关联的值<q>Alex</q>。下标返回字典的值类型的可选值。如果指定键不包含在字典中，下标返回nil。</p>

<p>词典的键类型必须符合雨燕标准库Hashable协议。</p>

<p>对于斯威夫特标准库的详细讨论Dictionary类型，请参阅字典。</p>

<p>一本字典类的语法</p>

<p>字典型 → 型类型[­:­]­<br/>
可选类型</p>

<p>雨燕的语言定义后缀?作为命名类型语法糖Optional<Wrapped>，这是在雨燕标准库中定义。换句话说，下面两个声明是等价的：</p>

<p>var optionalInteger: Int?<br/>
var optionalInteger: Optional<Int><br/>
在这两种情况下，变量optionalInteger声明为具有可选的整数的类型。注意，没有空白可能类型和之间出现?。</p>

<p>类型Optional<Wrapped>是两种情况，枚举none和some(Wrapped)，这是用来表示值可能或可能不存在。任何类型的可被显式地声明为（或者隐式转换为）任选的类型。如果你不提供一个初始值，当你声明一个可选的变量或属性，它的值会自动默认为nil。</p>

<p>如果选购的类型的实例包含一个值，可以使用后缀运算符访问该值!，如下图所示：</p>

<p>optionalInteger = 42<br/>
optionalInteger! // 42<br/>
使用!操作者解开具有的值的可选nil在运行时错误的结果。</p>

<p>您也可以使用可选的链接和可选的结合在一个可选的表达式有条件地执行操作。如果该值是nil，没有执行任何操作，因此产生没有运行时错误。</p>

<p>欲了解更多信息，看看例子说明如何使用可选的类型，请参阅选配。</p>

<p>可选类型的文法</p>

<p>可选类型 → 类型 ­?­<br/>
含蓄无包装可选类型</p>

<p>雨燕的语言定义后缀!作为命名类型语法糖Optional<Wrapped>，这是在雨燕标准库中定义，额外的行为时，它的访问它的自动解开。如果您尝试使用具有的价值隐含展开可选nil，你会得到一个运行时错误。与隐含解卷行为外，下面两个声明是等效的：</p>

<p>var implicitlyUnwrappedString: String!<br/>
var explicitlyUnwrappedString: Optional<String><br/>
注意，没有空白可能类型和之间出现!。</p>

<p>由于隐含解缠改变了包含该类型的声明的意义，是嵌套一个元组类型或一个泛型类型，比如元素类型的字典或内部的可选类型阵列 - 不能被标记为隐式展开。例如：</p>

<p>let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  // Error<br/>
let implicitlyUnwrappedTuple: (Int, Int)!             // OK</p>

<p>let arrayOfImplicitlyUnwrappedElements: [Int!]        // Error<br/>
let implicitlyUnwrappedArray: [Int]!                  // OK<br/>
由于隐含展开自选具有相同Optional<Wrapped>类型可选值，你可以在你的代码都是一样的地方，你可以使用选配使用隐式展开的选配。例如，您可以指定隐含展开自选的数值变量，常量和自选的性能，反之亦然。</p>

<p>与自选，如果你没有，当你宣布一个隐式展开的可选变量或属性提供一个初始值，将其值自动默认为nil。</p>

<p>使用可选的链接到一个隐式展开的可选表达式有条件地执行操作。如果该值是nil，没有执行任何操作，因此产生没有运行时错误。</p>

<p>有关隐含展开可选类型的详细信息，请参阅隐无包装选配。</p>

<p>一个隐式展开的可选类型的文法</p>

<p>隐式展开，可选类型 → 类型 ­!­<br/>
协议组合类型</p>

<p>的协议组成类型描述符合每个协议中指定的协议列表的类型。协议组合类型可能只在类型注解和泛型参数一起使用。</p>

<p>协议组合类型有以下形式：</p>

<p>方案1和方案2<br/>
的协议组成类型允许您无需显式定义一个新的命名方案，从你想要的类型，以符合每个协议继承指定其类型符合多种协议要求的值。例如，指定的协议组成的类型ProtocolA &amp; ProtocolB &amp; ProtocolC实际上是一样的定义一个新的协议ProtocolD，从继承ProtocolA，ProtocolB和ProtocolC，但无需引入一个新的名字。</p>

<p>在协议组成列表中的每个项目必须是协议名称或协议组成类型的类型别名。</p>

<p>协议组成类型的文法</p>

<p>协议的组成型 → 协议标识符的协议组成，延续 ­&amp;­<br/>
协议组成，延续 → 协议标识符协议的组成型 ­<br/><br/>
协议标识符 → 类型标识符 ­<br/>
元类型类型</p>

<p>一个元类型的类型是指任何类型的类型，包括类类型，结构类型，枚举类型，协议类型。</p>

<p>类，结构，或枚举类型的元类型是类型后跟的名称.Type。协议类型-不，在符合协议的具体类型的元类型运行时是协议的名称后面.Protocol。例如，类类型的元类型SomeClass是SomeClass.Type和协议的元类型SomeProtocol的SomeProtocol.Protocol。</p>

<p>您可以使用后缀self表达式访问类型的值。例如，SomeClass.self返回SomeClass本身，而不是的一个实例SomeClass。和SomeProtocol.self返回SomeProtocol本身，而不是符合一个类型的实例SomeProtocol在运行时。您可以使用type(of:)表达式与类型的实例来访问该实例的动态，运行时类型的值，如下例所示：</p>

<p>class SomeBaseClass {<br/>
    class func printClassName() {<br/>
        print(<q>SomeBaseClass</q>)<br/>
    }<br/>
}<br/>
class SomeSubClass: SomeBaseClass {<br/>
    override class func printClassName() {<br/>
        print(<q>SomeSubClass</q>)<br/>
    }<br/>
}<br/>
let someInstance: SomeBaseClass = SomeSubClass()<br/>
// The compile-time type of someInstance is SomeBaseClass,<br/>
// and the runtime type of someInstance is SomeSubClass<br/>
type(of: someInstance).printClassName()<br/>
// Prints <q>SomeSubClass</q><br/>
使用身份符（=<mark>和!</mark>）来测试实例的运行时类型是否相同的编译时类型。</p>

<p>if type(of: someInstance) === someInstance.self {<br/>
    print(<q>The dynamic and static type of someInstance are the same</q>)<br/>
} else {<br/>
    print(<q>The dynamic and static type of someInstance are different</q>)<br/>
}<br/>
// Prints <q>The dynamic and static type of someInstance are different</q><br/>
使用的初始化表达式来构建该类型的元类型值类型的实例。对于类实例，这就是所谓的初始化必须标有required关键字或标有整个班级final的关键字。</p>

<p>class AnotherSubClass: SomeBaseClass {<br/>
    let string: String<br/>
    required init(string: String) {<br/>
        self.string = string<br/>
    }<br/>
    override class func printClassName() {<br/>
        print(<q>AnotherSubClass</q>)<br/>
    }<br/>
}<br/>
let metatype: AnotherSubClass.Type = AnotherSubClass.self<br/>
let anotherInstance = metatype.init(string: <q>some string</q>)<br/>
一元类型类型的文法</p>

<p>元类型类型 → 类型类型 .­Type­  .­Protocol­<br/>
类型的继承条款</p>

<p>A型继承子句用于指定一个命名的类型，从继承的类和协议的命名类型符合。A型继承子句也可以用来指定class一个协议的要求。A型继承子句始于冒号（:），随后任一class要求，类型标识符的列表，或者两者兼而有之。</p>

<p>类类型可以从一个单一的超类继承，并符合任何数量的协议。当定义一个类，超类的名称必须首先出现在类型标识符的列表，后跟任意数量的协议的类必须符合的。如果类不从其它类继承，列表可以用一个协议而不是开始。对于扩展的讨论和类继承的几个例子，请参阅继承。</p>

<p>其它命名的类型只能从继承或符合协议的列表。协议类型可以从任何数目的其他协议继承。当一个协议类型从其它协议继承，该组的从那些其他协议的要求是聚集在一起，并从当前协议继承的任何类型必须符合所有这些要求。正如在讨论的协议声明，则可以包括class关键字作为类型继承子句中的第一个项目，以标记用的协议声明class要求。</p>

<p>在一个枚举定义中的类型继承条款可以是协议列表，或在原始值分配给它的情况下，单一的，命名的类型，指定这些原始数据类型枚举的情况下。对于使用类型继承子句指定其原料的值类型的枚举定义的例子，看到原始值。</p>

<p>一个类型继承条款的语法</p>

<p>类型继承子句 → 类需求型继承列表 ­:­,­<br/>
类型继承子句 → 类要求 ­:­<br/>
类型继承子句 → 型继承列表 ­:­<br/>
类型继承列表 → 类型标识符类型标识符类型继承列表 ­  ,­<br/>
类要求 → class­<br/>
类型推断</p>

<p>雨燕采用广泛类型推断，让您省去许多变量和表达式类型的类型或部分在你的代码。例如，而不是写作var x: Int = 0，你可以写var x = 0，省略了类型完全-编译器能够正确推断x名称类型的值Int。同样，你可以省略类型的一部分时，完整的类型可根据上下文推断。举例来说，如果你写let dict: Dictionary = [<q>A</q>: 1]，编译器推断dict有型Dictionary<String, Int>。</p>

<p>在两个以上的实施例中，类型信息被从表达式树到其根部的叶片向上传递。也就是说，类型x中var x: Int = 0通过首先检查的类型推断0，然后使这种类型的信息到根（变量x）。</p>

<p>在夫特，类型信息也可以流在相反的方向，从根至叶。在下面的例子中，例如，在明确的类型的注释（: Float）的常数eFloat使得数字文字2.71828有一个推断的类型的Float代替Double。</p>

<p>let e = 2.71828 // The type of e is inferred to be Double.<br/>
let eFloat: Float = 2.71828 // The type of eFloat is Float.<br/>
在斯威夫特类型推断在一个表达式或语句的级别运行。这意味着所有的推断的类型的省略类型或部分中表达所需要的信息必须从类型检查的表达或它的子表达式中的一个进行访问。</p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743601580892.html"  title="Previous Post: 词法结构">&laquo; 词法结构</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743601746767.html" 
	        title="Next Post: 表达式">表达式 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743601607750.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
