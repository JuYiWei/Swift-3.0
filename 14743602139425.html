<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  声明 - Swift 3.0 自翻译 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 自翻译 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 自翻译 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 自翻译 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
          
            <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743596689452.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="控制流" href="14743597355186.html">控制流</a></li>
          
            <li><a title="功能" href="14743597582027.html">功能</a></li>
          
            <li><a title="关闭" href="14743597798199.html">关闭</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标" href="14743598556978.html">下标</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="初始化" href="14743599314901.html">初始化</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
                        
                          <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743596689452.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="控制流" href="14743597355186.html">控制流</a></li>
                        
                          <li><a title="功能" href="14743597582027.html">功能</a></li>
                        
                          <li><a title="关闭" href="14743597798199.html">关闭</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标" href="14743598556978.html">下标</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="初始化" href="14743599314901.html">初始化</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>声明</h1>

<p>一个声明引入了一个新的名字或构建到你的程序。例如，你用声明来介绍函数和方法，变量和常量，并确定新的命名枚举，结构，类和协议类型。你也可以使用一个声明来延长现有命名类型的行为，并以符号输入到在别处声明的程序。</p>

<p>在斯威夫特，大多数声明也是其执行或在他们的声明同时初始化在这个意义上的定义。这就是说，因为协议没有实现他们的成员，大多数协议成员只能声明。为方便起见，并且由于区分并不是在夫特那么重要的，术语声明涵盖声明和定义。</p>

<p>声明的语法</p>

<p>报关 → 进口报关 ­<br/>
声明 → 常数声明 ­<br/>
声明 → 变量声明 ­<br/>
声明 → typealias声明 ­<br/>
声明 → 函数声明 ­<br/>
声明 → 枚举声明 ­<br/>
声明 → 结构声明 ­<br/>
声明 → 类声明 ­<br/>
申报 → 协议声明 ­<br/>
声明 → 初始化声明 ­<br/>
声明 → deinitializer声明 ­<br/>
声明 → 扩展声明 ­<br/>
声明 → 标声明 ­<br/>
声明 → 运营商申报 ­<br/>
声明 → 优先级组声明 ­<br/>
声明 → 申报报关单 选择<br/>
顶级代码</p>

<p>在斯威夫特源文件中的顶级代码由零个或多个声明，声明和表情。缺省情况下，变量，常量等命名的声明被在源文件的顶层声明都可以访问在每个源文件是相同的模块的一部分进行编码。您可以通过标记与访问级别修饰符的声明，描述覆盖此默认行为，访问控制级别。</p>

<p>顶级声明的语法</p>

<p>顶级声明 → 报表选择<br/>
代码块</p>

<p>一个代码块是由各种声明和控制结构将语句一起使用。它有以下形式：</p>

<p>{<br/>
    声明<br/>
}<br/>
该语句代码块中包含的声明，表达式和其他类型的报表，并在他们的源代码中出现的顺序执行。</p>

<p>一个代码块的语法</p>

<p>代码块 → 报表选择{­}­<br/>
进口申报</p>

<p>一个进口报关，您可以访问声明当前文件之外的符号。基本形式导入整个模块; 它包含的import关键字，然后是模块名称：</p>

<p>进口 模块<br/>
提供了哪些符号更详细的限制进口的，你可以指定一个特定的子模块或模块或子模块中的特定声明。当使用该详细的形式，只导入符号（声明它，而不是在模块）在目前的范围提供。</p>

<p>进口 进口种 模块。符号名称<br/>
进口 模块，子模块<br/>
进口报关单的语法</p>

<p>进口报关 → 属性选择进口实物选择导入路径 ­import­<br/>
进口实物 → typealias­  struct­  class­  enum­  protocol­  var­  func­<br/>
进口路径 → 导入路径标识符进口路径标识符进口路径 ­  .­<br/>
进口路径标识符 → 标识符运营商<br/><br/>
常量声明</p>

<p>一个常数声明引入了一个名为恒定值到程序中。恒声明使用声明的let关键字，并具有以下形式：</p>

<p>让 常量名：类型 = 表达式<br/>
常量声明定义一个不变之间结合常量名和初始值设定的值表达 ; 一个恒定的值被设定之后，它不能被改变。这就是说，如果一个常数与类对象初始化时，对象本身可以改变，但所述恒定名称和对象之间的结合是指不能。</p>

<p>当一个常数在全局范围内声明的，它必须与一个值进行初始化。当一个常量声明类或结构声明的情况下出现，它被认为是一个不变的性质。恒声明不计算性能，因此不具备的getter和setter方法。</p>

<p>如果该常数名常量声明的是一个元组的模式，在该元组的每个项目的名称被绑定到在初始化对应的值表达。</p>

<p>let (firstNumber, secondNumber) = (10, 42)<br/>
在本例中，firstNumber是该值的命名的常数10，并且secondNumber是一个命名为恒定值42。两个常量现在可以独立使用：</p>

<p>print(<q>The first number is (firstNumber).</q>)<br/>
// Prints <q>The first number is 10.</q><br/>
print(<q>The second number is (secondNumber).</q>)<br/>
// Prints <q>The second number is 42.</q><br/>
该类型的注释（类型）是一个常量声明选购时的类型常量的名称可以推断，如描述的类型推断。 :</p>

<p>声明常量type属性，标志与声明static的声明修饰符。类型属性在讨论类型属性。</p>

<p>有关常数和有关何时使用它们，请参阅指导更多信息常量和变量和存储性能。</p>

<p>常量声明语法</p>

<p>常数声明 → 属性选择申报修饰语选择模式的初始化列表 ­let­<br/>
模式的初始化列表 → 图案初始化模式的初始化模式的初始化列表 ­  ,­<br/>
模式的初始化 → 模式初始化 选择<br/>
初始化 → 表达 ­=­<br/>
变量声明</p>

<p>一个变量声明引入了一个名为变量值到您的程序，并使用声明var关键字。</p>

<p>变量声明有一个声明不同的命名，可变值，包括存储和计算的变量和属性，存储变量和财产观察员和静态变量属性的几种形式。以适当的形式来使用取决于在该变量声明的范围，并打算申报类型的变量。</p>

<p>注意</p>

<p>您也可以在协议声明的上下文中所述声明属性，协议财产申报。</p>

<p>您可以通过标记子类的财产申报与覆盖子类中的财产override申报改良剂，如中所述重写。</p>

<p>存储的变量和存储变量属性</p>

<p>下面的表格声明一个变量存储或存储变量属性：</p>

<p>VAR  变量名：类型 = 表达式<br/>
您可以定义在全局范围内这种形式的变量声明中，函数的局部范围内，或在一个类或结构声明的情况下。当这种形式的变量声明在全局范围或函数的局部范围内声明，它被称为存储变量。当在一类或结构声明的上下文被声明，它被称为一个存储变量属性。</p>

<p>初始化表达可以不存在于一个协议声明，但在所有其他情况下，初始化的表达是可选的。也就是说，如果没有初始化表达式存在，变量声明必须包含一个明确的类型的注释（类型）。 :</p>

<p>作为具有恒定 ​​的声明，如果变量名是一个元组的模式，在该元组的每个项目的名称被绑定到在初始化对应的值表达。</p>

<p>如它们的名字暗示，存储变量或存储变量属性的值存储在存储器中。</p>

<p>计算变量和计算属性</p>

<p>下面的表格声明一个变量计算或计算性能：</p>

<p>VAR  变量名：类型 {<br/>
得到 {<br/>
    声明<br/>
}<br/>
集（setter方法名）{<br/>
    声明<br/>
}<br/>
}<br/>
您可以定义在全局范围内这种形式的变量声明中，函数的局部范围内，或在一个类，结构，枚举，或扩展声明的情况下。当这种形式的变量声明在全局范围或函数的局部范围内声明，它被称为计算的变量。当在一类，结构或扩展声明的上下文中声明，它被称为一个计算属性。</p>

<p>吸气剂是用来读取的值，并且设置器用于写入的值。二传手子句是可选的，只需要一个getter方法时，可以省略这两个条款，并干脆直接返回所请求的值，如描述只读计算属性。但是，如果你提供了一个二传手条款，还必须提供一个getter条款。</p>

<p>在二传手的名称和圆括号是可选的。如果提供一个设置器的名字，它被用作参数的设定器的名称。如果你不提供一个setter名称，默认参数名二传手是newValue，如描述速记二传手宣言。</p>

<p>不同于存储的命名值和存储的变量属性，一个计算命名值或计算出的属性值没有被存储在存储器中。</p>

<p>欲了解更多信息，并查看计算性能的示例，请参阅计算属性。</p>

<p>存储可变观察员和观察员物业</p>

<p>您也可以声明一个变量存储或财产willSet和didSet观察员。观察员声明的存储变量或属性有以下形式：</p>

<p>VAR  变量名：类型 = 表达式 {<br/>
willSet（setter方法名）{<br/>
    声明<br/>
}<br/>
didSet（setter方法名）{<br/>
    声明<br/>
}<br/>
}<br/>
您可以定义在全局范围内这种形式的变量声明中，函数的局部范围内，或在一个类或结构声明的情况下。当这种形式的变量声明在全局范围或函数的局部范围内声明，观察员被称为存储变量观察。当它在一个类或结构声明的上下文声明，观察员被称为财产观察员。</p>

<p>您可以添加属性观察员的任何存储的属性。您也可以通过重写子类中的属性，如描述中添加属性观察员任何继承财产（无论是存储或计算）重写属性观察员。</p>

<p>初始化表达式是一个类或结构声明的情况下可选的，但在其他地方需要。该类型的注释是可选的当类型可以从初始推断表达。</p>

<p>在willSet与didSet观察者提供了一种方式来观察（和适当的反应）时被设置的变量或属性值。当第一次初始化变量或属性的观察员不叫。相反，仅当该值被设置的初始化上下文之外它们被调用。</p>

<p>一个willSet观察者被称为设置变量或属性的值之前。新的值被传递给willSet观察者为常数，因此，它不能在执行改变willSet子句。在didSet新的值设置观测后立即调用。与此相反的willSet观察者，变量或属性的旧值传递给didSet的情况下，你仍然需要访问它的观察者。也就是说，如果您分配一个值，其自身内的变量或属性didSet的观察者条款，即您指定新的值将取代刚刚设置并传递给一个willSet观察者。</p>

<p>在二传手的名称，并在圆括号willSet和didSet条款是可选的。如果您提供的setter的名字，它们被用作参数名的willSet和didSet观察员。如果不提供设定器名称，缺省参数名的willSet观察者是newValue，默认参数名称到didSet观察者oldValue。</p>

<p>该didSet子句是可选的，当你提供一个willSet条款。同样，willSet子句是可选的，当你提供一个didSet条款。</p>

<p>欲了解更多信息，并了解如何使用财产观察员，看一个例子地产观察员。</p>

<p>类型变量属性</p>

<p>要声明一个类型变量属性，标志与声明static的声明修饰符。类可以标记类型计算性能class声明修饰符，而不是让子类覆盖超类的实现。类型属性在讨论类型属性。</p>

<p>注意</p>

<p>在类的声明，该static关键字与标记与两个声明相同的效果class，并final声明修饰符。</p>

<p>一个变量声明的语法</p>

<p>变量声明 → 变量声明头模式的初始化列表 ­<br/>
变量声明 → 变量声明头变量名类型注释代码块 ­<br/>
变量声明 → 变量声明头变量名类型注释消气二传手块 ­<br/>
变量声明 → 变量声明头变量名类型注释消气 setter方法的关键字块 ­<br/>
变量声明 → 变量声明头变量名初始化 willSet-didSet块 ­<br/>
变量声明 → 变量声明头变量名类型注释初始 选择 willSet-didSet块 ­<br/>
变量声明头 → 属性选择申报修饰语选择var­<br/>
变量名 → 标识 ­<br/>
吸气制定者块 → 代码块 ­<br/>
吸气制定者块 → 消气条款二传手子句选择{­}­<br/>
吸气制定者块 → 二传手子句消气条款 ­{­}­<br/>
吸气子句 → 属性选择突变修改选择的代码块 ­get­<br/>
二传手子句 → 属性选择突变修饰选择二传手名选择的代码块 ­set­<br/>
二传手名 → 标识 ­(­)­<br/>
吸气制定者-关键字块 → 消气关键字条款制定者 -关键字子句选择{­}­<br/>
吸气制定者-关键字块 → setter方法的关键字条款消气关键字条款 ­{­}­<br/>
消气关键字条款 → 属性选择突变修改选择get­<br/>
setter方法的关键字节 → 属性选择突变修改选择set­<br/>
willSet-didSet块 → willSet子句 didSet子句选择{­}­<br/>
willSet-didSet块 → didSet子句 willSet子句选择{­}­<br/>
willSet子句 → 属性选择二传手名选择的代码块 ­willSet­<br/>
didSet子句 → 属性选择二传手名选择的代码块 ­didSet­<br/>
类型别名声明</p>

<p>一个类型别名声明引入现有类型的命名别名到你的程序。类型别名声明使用声明的typealias关键字，并具有以下形式：</p>

<p>typealias  名 = 现有类型<br/>
一个类型别名声明后，别名名字可以用来代替的现有类型无处不在你的程序。在现有类型可以是命名型或复合型。类型别名不创建新类型; 他们只是允许名称引用现有类型。</p>

<p>A型别名声明可以使用通用的参数给一个名字到一个现有的泛型类型。类型别名可以提供具体类型的部分或全部的现有类型的通用参数。例如：</p>

<p>typealias StringDictionary<Value> = Dictionary<String, Value></p>

<p>// The following dictionaries have the same type.<br/>
var dictionary1: StringDictionary<Int> = [:]<br/>
var dictionary2: Dictionary<String, Int> = [:]<br/>
当一个类型别名与泛型参数声明，这些参数的约束必须在现有类型的泛型参数的约束完全匹配。例如：</p>

<p>typealias DictionaryOfInts<Key: Hashable> = Dictionary<Key, Int><br/>
因为类型别名和现有类型可以互换使用，类型别名不能引入额外的通用约束。</p>

<p>内部协议的声明，一个类型别名可以给经常使用的类型提供一个更短，更方便的名字。例如：</p>

<p>protocol Sequence {<br/>
    associatedtype Iterator: IteratorProtocol<br/>
    typealias Element = Iterator.Element<br/>
}</p>

<p>func sum<T: Sequence>(_ sequence: T) -&gt; Int where T.Element == Int {<br/>
    // ...<br/>
}<br/>
如果没有这种类型的别名，所述sum功能将要参考相关的类型T.Iterator.Element，而不是T.Element。</p>

<p>又见协议相关联的类型声明。</p>

<p>一个类型别名声明的语法</p>

<p>typealias申报 → 属性选择访问级别修饰符选择 typealias名通用参数子句选择 typealias赋值 ­typealias­<br/>
typealias名 → 标识 ­<br/>
typealias赋值 → 型 ­=­<br/>
函数声明</p>

<p>一个函数声明引入了一个函数或方法到你的程序。在类，结构，枚举或协议的上下文中声明的函数被称为方法。函数声明使用声明的func关键字，并具有以下形式：</p>

<p>FUNC  函数名（参数） - &gt; 返回类型 {<br/>
    声明<br/>
}<br/>
如果函数有返回类型Void，返回类型可以如下省略：</p>

<p>FUNC  函数名（参数）{<br/>
    声明<br/>
}<br/>
的每个参数的类型必须包括-它不能推断。如果写inout在一个参数的类型的前面，参数可以在功能的范围内进行修改。在输出参数进行了详细讨论输入-输出参数如下。</p>

<p>函数可以返回使用一个元组类型的函数的返回类型多个值。</p>

<p>函数定义可以在另一个函数的声明出现。这种功能被称为嵌套函数。对于嵌套函数的讨论，参见嵌套函数。</p>

<p>参数名称</p>

<p>函数的参数是一个逗号分隔的列表，其中每个参数都有几种形式之一。参数在函数调用的顺序必须在函数的声明参数的顺序相匹配。在参数列表的最简单的条目有以下形式：</p>

<p>参数名：参数类型<br/>
一个参数有一个名字，它是在函数体中使用，也作为一个参数的标签，这是调用函数或方法时使用。默认情况下，参数名称也被用来作为参数的标签。例如：</p>

<p>func f(x: Int, y: Int) -&gt; Int { return x + y }<br/>
f(x: 1, y: 2) // both x and y are labeled<br/>
您可以覆盖的参数标签的默认行为具有下列形式之一：</p>

<p>参数标签 参数名：参数类型<br/>
_  参数名：参数类型<br/>
参数名称之前的名称给出参数显式参数的标签，这可以从参数名称不同。对应参数必须在函数或方法调用使用给定参数的标签。</p>

<p>下划线（_参数名之前）抑制参数的标签。对应参数必须在函数或方法调用没有标签。</p>

<p>func repeatGreeting(_ greeting: String, count n: Int) { /* Greet n times */ }<br/>
repeatGreeting(<q>Hello, world!</q>, count: 2) //  count is labeled, greeting is not<br/>
IN-OUT参数</p>

<p>在输出参数传递如下：</p>

<p>当函数被调用时，参数的值复制。<br/>
在函数的本体，副本被修改。<br/>
当该函数返回时，复制的值被分配给原始参数。<br/>
这种行为被称为拷贝在复制出或调用根据数值结果。例如，当一个计算属性或属性与观察者为在出参数传递，其吸气剂被称为函数调用的一部分，它的设置器被称为函数返回的一部分。</p>

<p>作为优化，当参数是存储在存储器中的物理地址的值，相同的存储器位置被内部和功能身体外使用。优化的行为被称为以引用的呼叫 ; 它满足所有的拷贝在复制出模式的要求，同时消除了复制的开销。利用复制在复制出给出的模型，而不依赖的call-by-参考优化编写代码，使其具有或不具有优化行为正确。</p>

<p>不要访问已为IN-OUT参数传递的价值，即使原来的说法是在当前范围内可用。当函数返回时，你原来的更改被覆盖与复制的价值。不要依赖于呼叫按引用优化的实施，尽量保持变化被覆盖。</p>

<p>你可以不一样的参数传递给多个IN-OUT参数，因为在副本被写回的顺序不明确，这意味着原来的终值也将得不到明确的界定。例如：</p>

<p>var x = 10<br/>
func f(a: inout Int, b: inout Int) {<br/>
    a += 1<br/>
    b += 10<br/>
}<br/>
f(a: &amp;x, b: &amp;x) // Invalid, in-out arguments alias each other<br/>
一个封闭或嵌套函数捕获一个进出参数必须nonescaping。如果您需要捕获在输出参数没有突变，或以观察通过其他代码所做的更改，请使用捕捉列表明确捕捉参数不可改变。</p>

<p>func someFunction(a: inout Int) -&gt; () -&gt; Int {<br/>
    return { [a] in return a + 1 }<br/>
}<br/>
如果您需要捕捉和变异的IN-OUT参数，使用一个明确的本地副本，如确保所有突变在函数返回之前完成多线程代码。</p>

<p>func multithreadedFunction(queue: DispatchQueue, x: inout Int) {<br/>
    // Make a local copy and manually copy it back.<br/>
    var localX = x<br/>
    defer { x = localX }</p>

<pre><code>// Operate on localX asynchronously, then wait before returning.
queue.async { someMutatingOperation(&amp;localX) }
queue.sync {}
</code></pre>

<p>}<br/>
欲了解更多讨论和IN-OUT参数的例子，见输入-输出参数。</p>

<p>参数的特殊类型</p>

<p>参数可忽略不计，采用可变数目的值，并且使用以下形式提供的默认值：</p>

<p><u>：参数类型<br/>
参数名：参数类型 ...<br/>
参数名：参数类型 = 默认参数值<br/>
下划线（</u>）参数被明确地忽略，并且不能函数的主体内访问。</p>

<p>用基本类型名称的参数由三个点（紧跟...）被理解为一个可变参数的参数。一个函数可以有至多一个可变参数的参数。一个可变参数的参数被视为包含基本类型名称的元素的数组。例如，所述可变参数的参数Int...被视为[Int]。对于使用可变参数的参数示例，请参阅可变参数的参数。</p>

<p>与A参数等号（=）和它的类型后的表达式被理解为具有给定表达式的一个默认值。当函数被调用给定的表达式。如果在调用函数时省略了参数，则默认值代替。</p>

<p>func f(x: Int = 42) -&gt; Int { return x }<br/>
f()       // Valid, uses default value<br/>
f(x: 7)   // Valid, uses the value provided<br/>
f(7)      // Invalid, missing argument label<br/>
方法的特殊类型</p>

<p>在一个枚举或修改结构的方法self必须标明该mutating声明修饰符。</p>

<p>重写父类方法的方法必须标明override声明修饰。这是一个编译时错误覆盖方法没有override修改或使用override修改器在不重写超类方法的方法。</p>

<p>与类型，而不是一个类型的实例关联的方法必须标明static声明改性剂枚举和结构或class为类声明修饰符。</p>

<p>投掷函数和方法</p>

<p>可以抛出一个错误函数和方法必须标有throws关键字。这些函数和方法是已知的作为投掷功能和抛方法。它们有以下形式：</p>

<p>FUNC  函数名（参数）抛出 - &gt; 返回类型 {<br/>
    声明<br/>
}<br/>
调用一个投掷函数或方法必须被包在一个try或try!表达（即，在一个范围try或try!操作者）。</p>

<p>的throws关键字是一个函数的类型的一部分，和nonthrowing函数是投掷函数的亚型。其结果是，你可以在同一个地方使用nonthrowing函数作为投掷之一。</p>

<p>你不能重载仅基于功能是否能引发错误的功能。这就是说，你可以重载基于功能是否函数的参数可以抛出一个错误。</p>

<p>投掷方法不能重写nonthrowing方法和投掷方法不能满足对nonthrowing方法的协议要求。这就是说，一个nonthrowing方法可以覆盖一个投掷方法和nonthrowing方法能满足一投掷方法的协议的要求。</p>

<p>重新抛出函数和方法</p>

<p>一个函数或方法可以用声明rethrows的关键字，以表明它抛出一个错误只有在其功能参数之一抛出一个错误。这些函数和方法是已知的作为重新抛出功能和重新抛出方法。重新抛出函数和方法必须至少有一个抛函数参数。</p>

<p>func someFunction(callback: () throws -&gt; Void) rethrows {<br/>
    try callback()<br/>
}<br/>
一个重新抛出函数或方法可以包含一个throw只有内声明catch的条款。这使您可以调用里面投掷功能do- catch块和处理中的错误catch抛出不同的错误条款。此外，该catch子句必须处理只由重新抛出函数的投掷参数之一引发的错误。例如，以下是无效的，因为catch子句将处理由抛出的错误alwaysThrows()。</p>

<p>func alwaysThrows() throws {<br/>
    throw SomeError.error<br/>
}<br/>
func someFunction(callback: () throws -&gt; Void) rethrows {<br/>
    do {<br/>
        try callback()<br/>
        try alwaysThrows()  // Invalid, alwaysThrows() isn&#39;t a throwing parameter<br/>
    } catch {<br/>
        throw AnotherError.error<br/>
    }<br/>
}</p>

<p>投掷方法不能覆盖一个重新抛出方法和投掷方法不能满足对重新抛出方法的协议要求。这就是说，一个重新抛出方法可以覆盖一个投掷方法，和一重新抛出方法能满足一投掷方法的协议的要求。</p>

<p>函数永远不会返回</p>

<p>迅速限定Never类型，这表明一个函数或方法不返回到它的调用者。与函数和方法Never返回类型被称为nonreturning。Nonreturning功能，要么方法导致不可恢复错误或开始工作的序列无限期持续。这意味着，代码永远不会执行通话结束后，否则将立即执行。投掷和重新抛出功能可以在程序的控制转移到一个合适的catch块，即使他们nonreturning。</p>

<p>一个nonreturning函数或方法可以调用缔结else保护语句的WHERE子句，如在讨论保护声明。</p>

<p>您可以覆盖一个nonreturning方法，但该方法必须保持它的返回类型和nonreturning行为。</p>

<p>函数声明的语法</p>

<p>函数声明 → 函数头函数名称通用参数子句选择功能签名仿制 where子句选择功能体选择<br/>
函数头 → 属性选择申报修饰语选择func­<br/>
函数名 → 标识符运营商<br/><br/>
函数签名 → 参数子句选择 功能 ，因此选择throws­<br/>
函数签名 → 参数子句函数的结果选择rethrows­<br/>
函数结果 → 属性选择类型-&gt;­<br/>
函数体 → 代码块 ­<br/>
参数子句 → 参数列表 ­ (­)­  (­)­<br/>
参数列表 → 参数参数 参数列表 ­  ,­<br/>
参数 → 外部参数名称选择本地参数名称类型注释默认参数子句选择<br/>
参数 → 外部参数名称选择本地参数名称类型注释 ­<br/>
参数 → 外部参数名称选择本地参数名称类型注释 ­...­<br/>
外部参数名 → 标识 ­<br/>
本地参数名称 → 标识符 ­<br/>
默认参数的子句 → 表达 ­=­<br/>
枚举声明</p>

<p>一个枚举声明引入了一个名为枚举类型到你的程序。</p>

<p>枚举声明有两种基本形式，并使用声明enum关键字。枚举的机身采用两种形式包含零个或多个值的所谓声明列举案例 -和任何数量的声明，包括计算性能，实例方法，类型的方法，初始化，类型别名，甚至其他枚举，结构和类声明。枚举声明不能包含deinitializer或协议的声明。</p>

<p>枚举类型可以采用任何数量的协议，但不能从类，结构，或其他枚举继承。</p>

<p>不同于类和结构，枚举类型没有一个隐含提供的默认初始值; 所有初始化必须显式声明。初始化可以委托给在枚举其他初始化，但初始化过程完成后才会初始化分配的枚举的情况下一个self。</p>

<p>状结构但不同班，枚举是值类型; 当分配给变量或常量，或者当作为参数传递给函数调用传递一个枚举的实例被复制。有关值类型的信息，请参阅结构和枚举是值类型。</p>

<p>你可以用一个扩展声明延长枚举类型的行为，如讨论扩展声明。</p>

<p>与任何类型的案件枚举</p>

<p>下面的表格声明中包含任何类型的列举案例枚举类型：</p>

<p>枚举 枚举名称：采用协议 {<br/>
    案例 列举案例1<br/>
    案例 列举案例2（相关值类型）<br/>
}<br/>
在这种形式中声明枚举有时也被称为可识别联合其他编程语言。</p>

<p>在这种形式下，每个case块包含的case关键字后跟一个或一个以上列举的情况下，用逗号分隔。每个案例的名称必须是唯一的。每一种情况下还可以指定其存储给定类型的值。这些类型在指定的关联值类型的元组，立即对案件的名称下面。</p>

<p>存储关联值枚举的情况下，可以用作建立与指定的相关联的值的枚举的实例的功能。就这样的功能，你可以得到一个枚举案例的引用，后面的代码应用它。</p>

<p>enum Number {<br/>
    case integer(Int)<br/>
    case real(Double)<br/>
}<br/>
let f = Number.integer<br/>
// f is a function of type (Int) -&gt; Number</p>

<p>// Apply f to create an array of Number instances with integer values<br/>
let evenInts: [Number] = [0, 2, 4, 6].map(f)<br/>
欲了解更多信息并查看相关联的价值类型的案件示例，请参阅关联值。</p>

<p>与间接寻址枚举</p>

<p>枚举可以递归结构，也就是说，它们可以与属于枚举类型本身的实例相关联的值的情况。然而，枚举类型的实例具有值语义，这意味着它们在内存中一个固定的布局。为了支持递归，编译器必须插入一个间接层。</p>

<p>要启用一个特定的枚举间接的情况下，用它标记indirect声明修饰符。</p>

<p>enum Tree<T> {<br/>
    case empty<br/>
    indirect case node(value: T, left: Tree, right: Tree)<br/>
}<br/>
为了使间接为枚举所有的情况下，标记与在整个枚举indirect修改，这是方便的，当枚举包含许多情况下，将每一个需要被打上了indirect修改。</p>

<p>这是标有一个枚举的情况下indirect修改必须有关联的值。标有该枚举indirect修饰符可以包含有相关的价值观和案件那些不这样做的情况下的混合物。这就是说，它不能包含还标有任何情况下indirect修改。</p>

<p>与原始值类型案件枚举</p>

<p>下面的表格声明包含相同的基本类型的枚举案件枚举类型：</p>

<p>枚举 枚举名称：原始值类型，采用协议 {<br/>
    案例 列举案例1 = 原始值1<br/>
    案例 列举案例2 = 原始值2<br/>
}<br/>
在这种形式下，每个case块包含的case关键字，后面跟着一个或多个列举的情况下，用逗号分隔。不像第一种形式的案件，每个案件都有一个基础值，称为原始值，相同的基本类型。类型这些值是在指定的原始值型和必须代表一个整数，浮点数，字符串或单个字符。尤其是，原始值类型必须符合Equatable协议的下列协议之一：ExpressibleByIntegerLiteral字面上，整型变量，ExpressibleByFloatLiteral浮点文本，ExpressibleByStringLiteral对于包含任何数量的字符字符串和ExpressibleByUnicodeScalarLiteral或ExpressibleByExtendedGraphemeClusterLiteral只包含一个字符串字符。每个案例必须具有唯一的名称，并分配一个唯一的原始值。</p>

<p>如果原始值类型被指定为Int你不分配一个值来明确的情况下，他们被隐式分配的值0，1，2，等。类型的每个未分配的情况下，Int被隐式分配，它会自动从以前的情况下的原始值递增一个原始值。</p>

<p>enum ExampleEnum: Int {<br/>
    case a, b, c = 5, d<br/>
}<br/>
另外，在上述例子中，原始值ExampleEnum.a就是0和的值ExampleEnum.b是1。而且由于值ExampleEnum.c被明确设置为5，的值ExampleEnum.d是自动地从递增5，因此6。</p>

<p>如果原始值类型被指定为String和你没有明确指定值的情况下，每个未分配的情况下，被隐式分配有相同的文字作为案例的名称的字符串。</p>

<p>enum GamePlayMode: String {<br/>
    case cooperative, individual, competitive<br/>
}<br/>
另外，在上述例子中，原始值GamePlayMode.cooperative是<q>cooperative</q>，的原始值GamePlayMode.individual是<q>individual</q>。与原始值GamePlayMode.competitive的<q>competitive</q>。</p>

<p>具有原始值类型的案件枚举隐含符合RawRepresentable协议中，雨燕标准库中定义。其结果是，他们有一个rawValue属性以及与签名的failable初始化init?(rawValue: RawValue)。您可以使用rawValue属性来访问枚举情况下的原始值，如ExampleEnum.B.rawValue，你也可以使用原始值来查找相应的情况下，如果有一个，通过调用枚举的failable初始化，如ExampleEnum(rawValue: 5)，它返回一个可选案件。欲了解更多信息，并看到原始值类型的案件示例，请参阅原始值。</p>

<p>访问枚举案例</p>

<p>引用一个枚举类型的情况下，使用点（.）语法，如EnumerationType.enumerationCase当枚举类型可以根据上下文来推断，你可以省略（点仍是必需的），如描述枚举语法和隐式成员表达式。</p>

<p>要检查的枚举情况下，价值，使用switch的语句，如图匹配枚举值与switch语句。反对的情况下块枚举例模式枚举类型模式匹配的switch语句，描述枚举案例模式。</p>

<p>枚举声明的语法</p>

<p>枚举声明 → 属性选择访问级别修饰符选择工会的风格，枚举 ­<br/>
枚举声明 → 属性选择访问级别修饰符选择原始值的风格，枚举 ­<br/>
工会的风格，枚举 → 选择枚举名称通用参数子句选择型继承子句选择仿制 where子句选择工会的风格，枚举成员选择indirect­enum­{­}­<br/>
工会的风格，枚举成员 → 工会的风格，枚举成员工会的风格，枚举成员选择<br/>
工会的风格，枚举成员 → 报关工会风格枚举情况子句编译器的控制语句 ­<br/><br/>
工会的风格，枚举区分条款 → 属性选择 选择 工会的风格，枚举案例列表 ­indirect­case­<br/>
工会的风格，枚举案例列表 → 工会的风格，枚举情况下，工会的风格，枚举情况下，工会的风格，枚举案例列表 ­  ,­<br/>
工会的风格，枚举情况下 → 枚举案例名称元组类型选择<br/>
枚举名 → 标识 ­<br/>
枚举区分名 → 标识 ­<br/>
原始值的风格，枚举 → 枚举名称通用参数子句选择型继承子句仿制 where子句选择原始值的风格，枚举成员 ­enum­{­}­<br/>
原始值的风格，枚举成员 → 原始值的风格，枚举成员的原始值的风格，枚举成员选择<br/>
原始值的风格，枚举成员 → 报关原始值的风格，枚举情况子句编译器的控制语句 ­<br/><br/>
原始值的风格，枚举区分条款 → 属性选择原始值的风格，枚举案例列表 ­case­<br/>
原始值的风格，枚举案例列表 → 原始值的风格，枚举情况下，原始值的风格，枚举情况下，原始值的风格，枚举案例列表 ­  ,­<br/>
原始值的风格，枚举情况下 → 枚举案例名称原始值赋值选择<br/>
原始值赋值 → 原始值字面 ­=­<br/>
原始值字面 → 数字字面静态字符串字面布尔字面 ­<br/><br/>
结构声明</p>

<p>一个结构声明引入了一个名为结构类型到你的程序。声明结构，使用声明的struct关键字，并具有以下形式：</p>

<p>结构 结构名称：采用协议 {<br/>
    声明<br/>
}<br/>
一种结构体包含零个或多个声明。这些声明可以包括存储和计算的性质，类型属性，实例方法，类型的方法，初始化，下标，类型别名，甚至其他结构，类和枚举声明。结构声明不能包含deinitializer或协议的声明。对于讨论，包括各种类型的声明结构的几个例子，见类和结构。</p>

<p>结构类型可以采用任何数量的协议，但不能从类，枚举，或其他结构继承。</p>

<p>有三种方法创建一个先前声明的结构的实例：</p>

<p>调用结构内声明的初始化之一，描述初始化器。<br/>
如果没有初始化声明，称该结构的成员逐一初始化，如描述的结构类型按成员初始化器。<br/>
如果没有初始化的声明，并在结构声明的所有属性被赋予初始值，调用结构的默认初始值，如描述默认初始化器。<br/>
初始化结构的声明的属性的方法，描述初始化。</p>

<p>结构实例的属性可以使用点（访问.）语法中所述，访问属性。</p>

<p>结构是值类型; 当分配给变量或常量，或者当作为参数传递给函数调用传递结构的情况下被复制。有关值类型的信息，请参阅结构和枚举是值类型。</p>

<p>你可以用一个扩展声明扩展结构类型的行为，如讨论扩展声明。</p>

<p>结构声明的语法</p>

<p>结构声明 → 属性选择访问级别修饰符选择结构名称通用参数子句选择型继承子句选择仿制 where子句选择结构体 ­struct­<br/>
结构名 → 标识 ­<br/>
结构体 → 结构成员选择{­}­<br/>
结构成员 → 结构成员结构 ，成员选择<br/>
结构成员 → 声明编译器的控制语句 ­<br/><br/>
类声明</p>

<p>一类声明引入了一个名为类类型到你的程序。声明类，使用声明的class关键字，并具有以下形式：</p>

<p>类 类名：超类，通 ​​过的议定书 {<br/>
    声明<br/>
}<br/>
一类体内含有零个或多个声明。这些声明可以包括存储和计算的性能，实例方法，类型的方法，初始化，单deinitializer，下标，类型别名，甚至其他类，结构和枚举声明。类声明不能包含协议声明。对于讨论的，包括各种类型的声明类的几个例子，见类和结构。</p>

<p>类类型只能从一个父类，它继承父类，但可以采用任何数量的协议。该超后首次出现的类名和冒号，然后是任何通过的议定书。泛型类可以从其他通用的，非泛型类继承，但非泛型类只能从其他非通用类继承。当您在冒号后面写一个通用的超类的名字，必须包含泛型类的全名，包括它的泛型参数子句。</p>

<p>正如所讨论的初始化程序声明，类可以有指定的和便利的初始化。类的指定初始化必须初始化所有类的声明的属性和调用任何其超类的指定初始化之前，它必须这样做。</p>

<p>一个类可以重写属性，方法，下标，它的超类的初始化。重写属性，方法，下标，和指定的初始必须标明该override声明修饰符。</p>

<p>若要求子类实现超类的初始化，标志着超与初始化required声明修饰符。该初始化的子类的实现也必须标明required声明修饰。</p>

<p>虽然在声明的属性和方法超由当前类继承，在声明的指定初始化超时，子类符合描述的条件仅继承自动初始化程序继承。斯威夫特类不从通用基类继承。</p>

<p>有两种方法创建一个先前声明的类的实例：</p>

<p>调用类中声明的初始化之一，描述初始化器。<br/>
如果没有初始化声明，类声明的所有属性被赋予初始值，调用类的默认初始值，如描述默认初始化器。<br/>
用点（一个类的实例的访问属性.）语法，如描述的访问属性。</p>

<p>类是引用类型; 一个类的实例被称为，而不是复制的，在分配给变量或常量，或者当作为参数传递给函数调用传递。有关引用类型的信息，请参阅结构和枚举是值类型。</p>

<p>你可以用一个扩展声明扩展类类型的行为，如讨论扩展声明。</p>

<p>一类声明的语法</p>

<p>类声明 → 属性选择访问级别修饰符选择 选择 类名通用参数子句选择型继承子句选择仿制 where子句选择类结构体 ­final­class­<br/>
类声明 → 属性选择访问级别修饰符选择类名通用参数子句选择型继承子句选择仿制 where子句选择类结构体 ­final­class­<br/>
类名 → 标识 ­<br/>
类体 → 类成员选择{­}­<br/>
类成员 → 类成员类成员选择<br/>
类成员 → 声明编译器的控制语句 ­<br/><br/>
协议声明</p>

<p>一个协议声明引入了一个名为协议类型到你的程序。协议声明使用在全局范围内声明的protocol关键字，并具有以下形式：</p>

<p>协议 协议名称：继承协议 {<br/>
    协议成员声明<br/>
}<br/>
协议的主体包含零个或多个协议成员声明，它描述了任何类型采用的协议必须满足一致性要求。特别是，协议可以声明符合类型必须实现某些属性，方法，初始化，和下标。协议还可以声明特殊类型的类型别名，叫相关的类型，可以指定协议的各种宣言之间的关系。协议的声明不能包含类，结构，枚举，或其他协议的声明。该协议成员声明将在下面详细讨论。</p>

<p>协议类型可以从任何数目的其他协议继承。当一个协议类型从其它协议继承，该组的从那些其他协议的要求被聚集，并且从当前协议继承的任何类型必须符合所有这些要求。有关如何使用协议继承示例，请参见协议继承。</p>

<p>注意</p>

<p>您也可以聚合的使用协议的组合类型多种协议的一致性要求，如描述的协议组合类型和协议组合。</p>

<p>您可以采用协议在该类型的扩展声明协议一致性添加到先前声明的类型。在扩展，你必须实现所有的协议采取的要求。如果类型已经实现了所有的要求，你可以离开了扩展声明空的身体。</p>

<p>默认情况下，符合协议类型必须实现所有的属性，方法，并在协议中声明标。这就是说，你可以标记与这些协议的成员声明optional声明修饰符来指定其实施由符合要求的类型是可选的。所述optional改性剂可以仅适用于标有成员objc属性，并仅在标有协议的成员objc属性。其结果是，只有类类型可以采用，并符合包含可选构件要求的协议。有关如何使用的详细信息optional申报修改以及有关如何访问任择议定书的成员，例如，当你不能确定一个符合要求的类型是否实现了指导他们看的任择议定书的要求。</p>

<p>要限制通过一项议定书，只类类型，标记与该协议class通过写要求class的关键字作为第一项继承协议冒号后名单。例如，下面的协议只能由类类型采用：</p>

<p>protocol SomeProtocol: class {<br/>
    /* Protocol members go here */<br/>
}<br/>
从该公司打上了一个协议继承的任何协议class的要求同样可以通过类类型仅采用。</p>

<p>注意</p>

<p>如果协议标有objc属性，所述class需求被隐式应用于该协议; 有没有必要，以纪念与该协议class明确要求。</p>

<p>协议命名的类型，因此，它们可以出现在代码作为其它命名类型都是一样的地方，如在讨论的协议作为类型。但是，你不能构造一个协议的实例，因为协议没有实际他们指定要求提供的实现。</p>

<p>您可以使用协议来声明哪些方法类或结构的代表应该实现，如描述的代表团。</p>

<p>协议声明的语法</p>

<p>协议声明 → 属性选择访问级别修饰符选择协议名称类型继承子句选择协议体 ­protocol­<br/>
协议的名称 → 标识符 ­<br/>
协议体 → 协议成员选择{­}­<br/>
协议成员 → 协议会员协议会员选择<br/>
协议成员 → 协议成员声明编译器的控制语句 ­<br/><br/>
协议成员声明 → 协议财产申报 ­<br/>
协议成员声明 → 协议的方法声明 ­<br/>
协议成员声明 → 协议初始化声明 ­<br/>
协议成员声明 → 协议标声明 ­<br/>
协议成员声明 → 协议相关的类型声明 ­<br/>
协议成员声明 → typealias声明 ­<br/>
协议财产申报</p>

<p>协议声明符合类型必须由包括实行财产协议，财产申报在协议声明体。协议属性声明有变量声明的一种特殊形式：</p>

<p>VAR  属性名：类型 { 获取 设置 }<br/>
与其他协议成员声明，​​这些属性声明只宣布该符合协议类型的getter和setter的要求。这样一来，你不执行getter或直接在声明它的协议制定者。</p>

<p>的获取和设置的需求可以通过在各种方式作为规定类型来满足。如果财产申报既包括get和set关键字，一个符合要求的类型可以与存储变量属性或属性计算是可以读取和写入（即一个同时实现了一个getter和一个setter）实现它。然而，该属性声明不能被实现为恒定属性或一个只读计算属性。如果属性声明仅包括get关键字，它可以被实现为任何类型的属性。对于符合实现协议的性能要求类型的例子，看看性能要求。</p>

<p>又见变量声明。</p>

<p>协议属性声明的语法</p>

<p>协议的财产申报 → 变量声明头变量名类型注释消气 setter方法的关键字块 ­<br/>
协议方法声明</p>

<p>协议声明符合类型必须通过在协议声明体的协议方法声明实现的方法。协议方法声明具有相同形式的函数声明，但有两个例外：他们不包含函数体，你可以不提供任何默认参数值的函数声明的一部分。对符合标准的实施协议的方法要求类型的示例，请参阅方法的要求。</p>

<p>要声明一个类或静态方法要求在协议声明，标志着在方法声明static声明修饰符。实现这个方法的类声明的方法class修改。实现它的结构必须声明的方法static声明修饰符来代替。如果你正在实施一个扩展的方法，使用class修改器，如果你扩展一个类和static如果你扩展的结构改性剂。</p>

<p>另请参见函数声明。</p>

<p>协议方法声明的语法</p>

<p>协议的方法声明 → 函数头函数名称通用参数子句选择功能签名仿制 where子句选择<br/>
协议初始化器声明</p>

<p>协议声明符合类型必须通过在协议声明体的协议初始化声明实施初始化。协议初始化声明具有相同的形式初始化的声明，但它们不包括初始化的身体。</p>

<p>一个符合类型可以通过实现nonfailable初始化或满足nonfailable协议初始化要求init!failable初始化。一个符合类型可以通过实施任何一种初始的满足failable协议初始化要求。</p>

<p>当一个类实现一个初始化，以满足协议的初始化要求，初始化必须与被标记required声明修饰符如果该类尚未打上final声明修饰符。</p>

<p>又见初始化程序宣言。</p>

<p>协议初始化声明的语法</p>

<p>协议的初始申报 → 初始化头通用参数子句选择参数子句选择 仿制 where子句选择throws­<br/>
协议的初始申报 → 初始化头通用参数子句选择参数子句仿制 where子句选择rethrows­<br/>
协议标宣言</p>

<p>协议声明符合类型必须通过在协议声明体的协议标申报实行标。协议声明标有标声明的一种特殊形式：</p>

<p>标（参数） - &gt; 返回类型 { 得到 设定 }<br/>
标声明只宣布该符合协议类型的最低getter和setter实施要求。如果标声明既包括get和set关键字，符合要求一类必须实现一个getter和一个setter条款。如果标声明仅包含get关键字作为规定类型必须实现至少一个getter条款和可选可以实现一个二传手条款。</p>

<p>又见标宣言。</p>

<p>协议标声明的语法</p>

<p>协议标申报 → 标头标 ，结果消气 setter方法的关键字块 ­<br/>
协议相关类型声明</p>

<p>协议声明使用相关类型associatedtype的关键字。相关联的类型提供的别名，是用于作为协议的声明的一部分的类型。相关类型类似于输入泛型参数条款参数，但他们正在与相关联Self在其在声明的协议。在这种情况下，Self指的是符合协议的最终类型。欲了解更多信息和示例，请参见相关类型。</p>

<p>另请参见类型别名宣言。</p>

<p>协议相关的类型声明的语法</p>

<p>协议相关的类型声明 → 属性选择访问级别修饰符选择 typealias名称类型继承子句选择 typealias赋值选择associatedtype­<br/>
初始化声明</p>

<p>一个初始化声明引入了类，结构或枚举到你的程序的初始化。初始化声明使用声明的init关键字，有两种基本形式。</p>

<p>结构，枚举和类类型可以有任意数量的初始化，但对于类初始化的规则和相关的行为是不同的。不同结构和枚举，类有两种初始化的：指定初始化和方便初始化，如描述的初始化。</p>

<p>下面的表格声明了结构，枚举和指定类初始化初始化：</p>

<p>初始化（参数）{<br/>
    声明<br/>
}<br/>
一类的指定初始化直接初始化所有类的属性。它不能调用同一类的其他任何初始化，如果类有一个父类，它必须调用父类的指定初始化之一。如果类继承自其超的任何属性，超类的初始化指定一个必须在任何这些属性可以设置或当前类修改调用。</p>

<p>指定的初始值只能在一类声明的上下文中声明，所以无法使用扩展声明被添加到一个类。</p>

<p>在结构和枚举初始化器可以调用其他申报初始化委托部分或全部初始化过程。</p>

<p>要为类声明的便利初始化，标记的初始化声明convenience声明修饰符。</p>

<p>便利 的init（参数）{<br/>
    声明<br/>
}<br/>
便利初始化可以委托初始化过程到另一个方便初始化或类的指定初始化之一。这就是说，在初始化过程必须到指定的初始化，最终初始化类的属性通话结束。便利初始化不能调用父类的初始化。</p>

<p>您可以标记指定，并与便利初始化required声明修饰符来要求每个子类中实现初始化。该初始化的子类的实现也必须标明required声明修饰。</p>

<p>默认情况下，在一个超类中声明初始化不由子类继承。这就是说，如果一个子类初始化所有的存储属性使用默认值，并没有定义任何自己的初始化，它继承了所有超类的初始化的。如果子类覆盖了所有超类的指定初始化的，它继承了超类的初始化方便。</p>

<p>至于方法，属性和下标，您需要标记与重写指定初始化override声明修饰符。</p>

<p>注意</p>

<p>如果标记与一个初始化required声明修饰符，你不也标志着与初始化override修改器在覆盖在子类中所需的初始化。</p>

<p>就像函数和方法，初始化可以抛出或重新抛出错误。就如同函数和方法，可以使用throws或rethrows一个初始化的参数之后，关键字来表示适当的行为。</p>

<p>要在不同的类型声明初始化的示例，请参阅初始化。</p>

<p>Failable初始化器</p>

<p>一个failable初始化是一种初始化的，产生一个可选的实例或初始化声明的类型的隐式展开的可选实例。其结果是，一个failable初始化可以返回nil，以指示初始化失败。</p>

<p>要声明产生一个可选的实例的初始化failable，一个问号追加到init关键字在初始化声明（init?）。要声明产生一种含蓄展开可选实例的初始化failable，添加一个感叹号，而不是（init!）。下面的示例显示了init?产生结构的一个可选实例failable初始化。</p>

<p>struct SomeStruct {<br/>
    let property: String<br/>
    // produces an optional instance of &#39;SomeStruct&#39;<br/>
    init?(input: String) {<br/>
        if input.isEmpty {<br/>
            // discard &#39;self&#39; and return &#39;nil&#39;<br/>
            return nil<br/>
        }<br/>
        property = input<br/>
    }<br/>
}<br/>
你叫一个init?在你调用一个nonfailable初始化，除了你必须处理结果的可选性以同样的方式failable初始化。</p>

<p>if let actualInstance = SomeStruct(input: <q>Hello</q>) {<br/>
    // do something with the instance of &#39;SomeStruct&#39;<br/>
} else {<br/>
    // initialization of &#39;SomeStruct&#39; failed and the initializer returned &#39;nil&#39;<br/>
}<br/>
一个failable初始化可以返回nil在任何时候在初始化的身体落实。</p>

<p>一个failable初始化可以委托给任何初始化的。一个nonfailable初始化可以委托给另一nonfailable初始化或一个init!failable初始化。一个nonfailable初始化可以委托给一个init?由力展开超类的初始化，例如的结果，通过写failable初始化super.init()!。</p>

<p>初始化失败初始化通过传播代表团。特别是，如果一个failable初始化委托给失败并返回一个初始化nil，那么委派初始化也失败并隐式返回nil。如果nonfailable初始化委托给一个init!失败并返回failable初始化nil，然后运行时引发错误（因为如果你使用的!操作员打开那有一个可选的nil值）。</p>

<p>一个failable指定的初始化可以在子类中的任何一种指定初始化的覆盖。一个nonfailable指定的初始化可以在子类只由nonfailable指定初始化覆盖。</p>

<p>欲了解更多信息，并看到failable初始化的示例，请参阅Failable初始化器。</p>

<p>一个初始化声明的语法</p>

<p>初始申报 → 初始化头通用参数子句选择参数子句选择 仿制 where子句选择初始体 ­throws­<br/>
初始申报 → 初始化头通用参数子句选择参数子句仿制 where子句选择初始体 ­rethrows­<br/>
初始化头 → 属性选择申报修饰语选择init­<br/>
初始化头 → 属性选择申报修饰语选择init­?­<br/>
初始化头 → 属性选择申报修饰语选择init­!­<br/>
初始化体 → 代码块 ­<br/>
Deinitializer宣言</p>

<p>一个deinitializer声明声明一个类类型deinitializer。Deinitializers没有参数并具有以下形式：</p>

<p>DEINIT {<br/>
    声明<br/>
}<br/>
当不再有一类对象的任何引用一个deinitializer被自动调用，类对象被释放之前。一个deinitializer只能在类的主体被宣布的声明，而不是在一个类，每类的扩展可以最多只能有一个。</p>

<p>子类继承其父类的deinitializer，这是隐式调用子类对象被释放之前。子类对象不释放，直到其继承链中的所有deinitializers已执行完毕。</p>

<p>Deinitializers并不被直接调用。</p>

<p>有关如何使用类声明一个deinitializer示例，请参见反初始化。</p>

<p>一个DEINITIALIZER声明的语法</p>

<p>deinitializer申报 → 属性选择的代码块 ­deinit­<br/>
扩展声明</p>

<p>一个扩展声明，您可以扩展现有的类，结构和枚举类型的行为。扩展声明使用声明的extension关键字，并具有以下形式：</p>

<p>扩展 类型的名称：采用协议 {<br/>
    声明<br/>
}<br/>
延期申报的主体包含零个或多个声明。这些声明包括计算性能，计算类型属性，实例方法，类型的方法，初始化，标声明，甚至类，结构和枚举声明。扩展声明不能包含deinitializer或协议的声明，存储性能，财产观察员，或其他扩展声明。对于讨论和扩展，包括各种类型的声明的几个例子，看看扩展。</p>

<p>扩展声明可以在协议一致性添加到现有的类，结构和枚举类型采用的协议。扩展声明不能继承类添加到现有的类，因此，你可以指定只后的协议列表类型名称和结肠癌。</p>

<p>现有类型的属性，方法和初始化不能在该类型的扩展覆盖。</p>

<p>扩展声明可以包含初始化声明。也就是说，如果你伸出的类型在其他模块的定义，一个初始化声明必须委托给该模块中已经定义的初始化，以确保该类型的成员被正确初始化。</p>

<p>一个扩展声明的语法</p>

<p>扩展申报 → 属性选择访问级别修饰符选择类型标识符类型继承子句选择延伸体 ­extension­<br/>
扩展申报 → 属性选择访问级别修饰符选择类型标识符仿制 where子句延伸体 ­extension­<br/>
延伸体 → 扩展成员选择{­}­<br/>
扩展成员 → 扩展名成员组成的扩展成员选择<br/>
扩展名成员 → 声明编译器的控制语句 ­<br/><br/>
标宣言</p>

<p>一个标声明，允许你添加下标运算支持特定类型的对象，而通常用来访问在收集，列表或序列中的元素提供了一个方便的语法。标声明使用声明的subscript关键字，并具有以下形式：</p>

<p>标（参数） - &gt; 返回类型 {<br/>
    得到 {<br/>
        声明<br/>
    }<br/>
    集（setter方法名）{<br/>
        声明<br/>
    }<br/>
}<br/>
标声明只能在类，结构，枚举，扩展或协议声明的情况下出现。</p>

<p>该参数指定用于访问相应的类型的元件在标表达一个或多个索引（例如，i在表达式object[i]）。尽管用于访问元素的索引可以是任何类型的，每个参数都必须包括一个类型注释指定每个索引的类型。该返回类型指定被访问的元件的类型。</p>

<p>与计算性能，标声明的支持读写访问元素的值。吸气剂是用来读取的值，并且设置器用于写入的值。二传手子句是可选的，只需要一个getter方法​​时，可以省略这两个条款，并简单地直接返回请求的值。这就是说，如果你提供了一个二传手条款，还必须提供一个getter条款。</p>

<p>在二传手的名称和圆括号是可选的。如果提供一个设置器的名字，它被用作参数的设定器的名称。如果你不提供一个setter名称，默认参数名称设置器value。该类型的setter方法名称必须是一样的返回类型。</p>

<p>您可以在声明它的类型重载一个标声明，只要参数或者返回类型从你超载的不同。您还可以覆盖从超类继承下标声明。当你这样做的话，你必须标记与重写的标声明override声明修饰符。</p>

<p>缺省情况下，下标所使用的参数不具有自变量的标签，与功能，方法和初始化。但是，可以提供使用该功能，方法和初始化使用相同的语法显式的参数标签。</p>

<p>您也可以在协议声明的上下文声明标，如描述的协议标宣言。</p>

<p>有关下标，并看到标声明的示例的详细信息，请参阅下标。</p>

<p>一个标声明的语法</p>

<p>标申报 → 标头标 ，结果代码块 ­<br/>
标申报 → 标头标 ，结果消气二传手块 ­<br/>
标申报 → 标头标 ，结果消气 setter方法的关键字块 ­<br/>
标头 → 属性选择申报修饰语选择参数子句 ­subscript­<br/>
标-结果 → 属性选择类型-&gt;­<br/>
运营商宣言</p>

<p>一个操作符声明引入了一个新的中缀，前缀或后缀操作员到你的程序，并使用声明operator关键字。</p>

<p>你可以声明三种不同的固定边界运营商：中缀，前缀和后缀。的固定性的操作者指定操作者其操作数的相对位置。</p>

<p>有运营商申报的三种基本形式，每个固定性。运营商的固定性通过标记与操作声明中指定infix，prefix或postfix在申报之前修改operator关键字。在每个窗体中，运营商的名称只能包含定义操作字符运算。</p>

<p>下面的表格声明了一个新的中缀操作符：</p>

<p>缀 运营商 的运营商名称：优先级组<br/>
一个中缀操作符是它的两个操作数，如大家熟悉的加法运算符（书面之间的二进制运算符+表达式）1 + 2。</p>

<p>中缀运算符可以选择指定优先级组。如果省略的优先级组操作，雨燕使用默认优先级组DefaultPrecedence，它指定了优先级只高出TernaryPrecedence。欲了解更多信息，请参阅优先级组宣言。</p>

<p>下面的表格声明了一个新的前缀操作符：</p>

<p>前缀 运营商 运营商的名称<br/>
一个前缀运算符是其操作数之前立即写入，如前缀逻辑非运算符（一元操作符!表达式）!a。</p>

<p>前缀运算符声明不指定优先级。前缀经营者非结合。</p>

<p>下面的表格声明了一个新的后缀运算符：</p>

<p>后缀 运营商 运营商的名称<br/>
一个后缀运算符是它的操作后立即写了一元运算符，如后缀强制展开操作符（!表达式）a!。</p>

<p>作为前缀运营商，后缀运算符声明不指定优先级。Postfix的经营者非结合。</p>

<p>宣布一个新的操作后，可以通过声明具有相同的名称作为操作的静态方法实现它。静态方法是其值的运算符采用作为参数-例如类型之一的一个成员，即乘以一个操作者Double通过一个Int被实现为一个静态方法在任一Double或Int结构。如果你正在实施一个前缀或后缀操作符，还必须标明具有相应的方法声明prefix或postfix声明修饰符。要了解如何创建一个实例，并实施新的运 ​​营商，看到运营商定制。</p>

<p>运算符声明的语法</p>

<p>经营者申报 → 前缀运营商申报后缀运营商申报缀运营商的声明 ­<br/><br/>
前缀运营商申报 → 运营商 ­prefix­operator­<br/>
后缀运营商申报 → 运营商 ­postfix­operator­<br/>
缀运营商申报 → 运营商缀操作员组选择infix­operator­<br/>
缀操作员组 → 优先级组名 ­:­<br/>
优先级组宣言</p>

<p>一个优先级组声明，介绍了中缀运算符优先级一个新的分组到程序中。操作者的优先级指定操作者如何紧密结合其操作数，在没有分组括号。</p>

<p>一个优先组声明有以下形式：</p>

<p>precedencegroup  优先级组名 {<br/>
    higherThan：较低的组名<br/>
    lowerThan：较高的组名<br/>
    关联：关联<br/>
    分配：分配<br/>
}<br/>
在较低的组名和较高的组名称列出指定新的优先级组的关系现有的优先级组。的lowerThan优先级组属性只可用于指当前模块的外部声明优先基团。当两个操作员例如在表达彼此对它们的操作数，竞争2 + 3 * 5，具有较高相对优先权操作结合更紧密，以它的操作数。</p>

<p>注意</p>

<p>使用彼此相关的优先级组低级组名称和更高组名必须适合单个关系的层次结构，但它们不具有形成一个线性的层次结构。这意味着可以有一个与未定义的相对优先级的优先级组。从这些优先级组运营商不能在没有分组括号旁边彼此使用。</p>

<p>斯威夫特无数定义优先级组与标准库提供的运营商一起去。例如，在加入（+）和减（-）算属于AdditionPrecedence组，和乘法（*）和分裂（/）算属于MultiplicationPrecedence组。对于由雨燕标准库提供的运算符和优先级组的完整列表，请参阅雨燕标准库操作员参考。</p>

<p>该关联操作的指定使用相同的优先级运营商的序列是如何组合在一起在没有分组括号。通过编写上下文敏感的关键字之一指定运营商的关联left，right或者none-如果你省略了相关性，则默认为none。这是左结合Operators组左到右。例如，减法运算符（-）被左结合的，所以表达式4 - 5 - 6被分组为(4 - 5) - 6和的计算结果为-7。是与一个关联指定运算符是从右到左右结合基，和运营商none不相关联的。相同的优先级水平的非结合运营商不能出现相邻其他。例如，&lt;操作者的关联性none，这意味着1 &lt; 2 &lt; 3不是有效的表达。</p>

<p>的分配在包括可选的链接的操作使用时，一个优先级组的指定操作的优先级。当设置为true，相应的优先级组中的操作者可选的链接从标准库中的赋值运算符中使用相同的分组规则。否则，当设置为false或省略，优先级组的运营商遵循相同的可选链接规则，不执行赋值操作符。</p>

<p>一个优先组声明的语法</p>

<p>优先级组申报 → 优先级组名称优先级组的属性选择precedencegroup­{­}­<br/>
优先级组属性 → 优先级组属性优先级组的属性选择<br/>
优先级组属性 → 优先级组关系 ­<br/>
优先级组属性 → 优先级组分配 ­<br/>
优先级组属性 → 优先级组关联 ­<br/>
优先级组关系 → 优先级组的名称 ­higherThan­:­<br/>
优先级组关系 → 优先级组的名称 ­lowerThan­:­<br/>
优先级组分配 → 布尔字面 ­assignment­:­<br/>
优先级组关联 → associativity­:­left­<br/>
优先级组关联 → associativity­:­right­<br/>
优先级组关联 → associativity­:­none­<br/>
优先级组的名称 → 优先级组名称优先级组名称优先级组的名称 ­  ,­<br/>
优先级组名 → 标识 ­<br/>
声明修饰符</p>

<p>声明修饰符是关键字或上下文敏感的关键字，修改声明的行为或意义。您可以通过写一个声明的属性之间的适当的关键字或上下文敏感的关键字（如果有的话），并且引入了声明关键字指定一个声明修饰符。</p>

<p>dynamic<br/>
应用此修改器，可以通过Objective-C的表示的类中的任何成员。当你标记一个成员声明的dynamic修改，获得该成员始终是动态使用Objective-C运行调度。正在访问该成员从不内联或由编译器devirtualized。</p>

<p>由于标有报关单dynamic修改使用Objective-C运行出动，他们含蓄地标有objc属性。</p>

<p>final<br/>
应用此修饰符的类或属性，方法，或下标一类的成员。它适用于一类以指示该类不能被继承。它适用于一个属性，方法或类的下标来表示类成员不能在任何的子类覆盖。有关如何使用一个例子final属性，请参阅防止覆盖。</p>

<p>lazy<br/>
应用此修改器类或结构的存储变量属性表明属性的初始值计算和存储最多一次，当第一次访问该属性。有关如何使用一个例子lazy修改，见懒惰存储性能。</p>

<p>optional<br/>
应用此修改器协议的属性，方法或标委员表示，以实现这些成员符合要求的类型不是必需的。</p>

<p>您可以将optional修改器只标有协议objc的属性。其结果是，只有类类型可以采用，并符合包含可选构件要求的协议。有关如何使用的详细信息optional修改以及有关如何访问任择议定书的成员，例如，当你不能确定一个符合要求的类型是否实现了指导他们看的任择议定书的要求。</p>

<p>required<br/>
应用此修改器一类的指定或便利初始化，以表明每个子类必须实现初始化。子类的实现，初始化的，还必须标有required修改。</p>

<p>weak<br/>
所述weak改性剂被施加到一个可变或存储变量属性以指示变量或属性具有弱参照存储作为其值的对象。类型的变量或属性必须是一个可选的类型。使用weak改性剂，以避免强烈的参考周期。有关的例子，更多信息weak修改，见弱引用。</p>

<p>访问控制级别</p>

<p>雨燕提供了访问控制的五个层次：开放的，公开的，内部的，私人文件和私人。您可以标记与下面的访问级别修饰符的一个声明指定报关的访问级别。访问控制中详细讨论访问控制。</p>

<p>open<br/>
应用此修饰符来声明，表示该声明可以访问和在同一模块的声明由代码的子类。标有声明open的访问修饰符级还可以访问并导入包含该声明的模块一个模块通过代码的子类。</p>

<p>public<br/>
应用此修饰符来声明，表示该声明可以访问和在同一模块的声明由代码的子类。标有声明public的访问修饰符级也可以通过代码导入包含声明该模块的模块中进行访问（但不包括子类）。</p>

<p>internal<br/>
应用此修饰符来声明，表示该声明只能由同一代码模块的声明进行访问。默认情况下，大多数的声明被隐式标有internal访问层次修饰符。</p>

<p>fileprivate<br/>
应用此修饰符来声明，表示该声明只能通过代码相同的源文件的声明进行访问。</p>

<p>private<br/>
应用此修饰符来声明，表示该声明只能由该声明的直接封闭范围内的代码进行访问。</p>

<p>每个访问级别的修改器上方选择性地接受一个参数，它由的set括号括起来（例如，关键字private(set)）。当你想指定变量或下标这是小于或等于变量或下标本身的访问级别，作为讨论的setter方法的访问级别使用这种形式的访问级别修饰符的getter和setter。</p>

<p>声明修饰符的语法</p>

<p>声明改性剂 → class­  convenience­  dynamic­  final­  infix­  lazy­  optional­ override­  postfix­  prefix­  required­  static­  unowned­  unowned­(­safe­)­ unowned­(­unsafe­)­  weak­<br/>
声明修饰符 → 访问级别修饰符 ­<br/>
声明修饰符 → 突变修改 ­<br/>
声明修饰语 → 声明修饰符声明修饰语选择<br/>
访问级别修饰符 → private­  private­(­set­)­<br/>
访问级别修饰符 → fileprivate­  fileprivate­(­set­)­<br/>
访问级别修饰符 → internal­  internal­(­set­)­<br/>
访问级别修饰符 → public­  public­(­set­)­<br/>
访问级别修饰符 → open­  open­(­set­)­<br/>
突变修饰 → mutating­  nonmutating­</p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743601868497.html"  title="Previous Post: 声明">&laquo; 声明</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743602336703.html" 
	        title="Next Post: 属性">属性 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743602139425.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
