<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  初始化 - Swift 3.0 自翻译 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 自翻译 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 自翻译 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 自翻译 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
          
            <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="功能" href="14743597582027.html">功能</a></li>
          
            <li><a title="关闭" href="14743597798199.html">关闭</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标" href="14743598556978.html">下标</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="初始化" href="14743599314901.html">初始化</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
                        
                          <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="功能" href="14743597582027.html">功能</a></li>
                        
                          <li><a title="关闭" href="14743597798199.html">关闭</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标" href="14743598556978.html">下标</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="初始化" href="14743599314901.html">初始化</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>初始化</h1>

<p>初始化是制备类，结构或枚举使用的一个实例的过程。这一过程包括设置在该实例中的每个存储的属性的初始值和前执行新的实例即可使用所需的任何其他设置或初始化。</p>

<p>通过定义实现这个初始化过程初始化，这就像特殊的方法，可以调用创建特定类型的新实例。与Objective-C的初始化，初始化雨燕没有返回值。其主要作用是保证一个类型的新情况下，它们被用于在首次使用前被正确初始化。</p>

<p>类类型的实例也可以实现deinitializer，它执行这个类的一个实例被释放之前任何自定义清理。有关deinitializers的更多信息，请参阅反初始化。</p>

<p>初始值设定为存储性能</p>

<p>类和结构必须所有的存储属性设置到由创建该类或结构的一个实例的时间的适当的初始值。存储的属性不能处于不确定的状态。</p>

<p>您可以为初始化内存储的属性，或者通过为属性定义的一部分分配默认属性值设置的初始值。这些动作将在以下各节中描述。</p>

<p>注意</p>

<p>当你指定一个默认值来存储的属性，或者一个初始化中设置其初始值，该属性的值被直接设置，而无需调用任何财产观察员。</p>

<p>初始化器</p>

<p>初始化被调用以创建一个特定类型的新实例。在最简单的形式，一个初始化就像一个实例方法不带参数，采用书面init关键字：</p>

<p>init() {<br/>
    // perform some initialization here<br/>
}<br/>
下面的例子定义了一个名为新的结构Fahrenheit来存储在华氏温标表示的温度。该Fahrenheit结构有一个存储的属性，temperature其类型为的Double：</p>

<p>struct Fahrenheit {<br/>
    var temperature: Double<br/>
    init() {<br/>
        temperature = 32.0<br/>
    }<br/>
}<br/>
var f = Fahrenheit()<br/>
print(<q>The default temperature is (f.temperature)° Fahrenheit</q>)<br/>
// Prints <q>The default temperature is 32.0° Fahrenheit</q><br/>
该结构定义了一个初始化，init，不带任何参数，它与值初始化存储温度32.0（水华氏度冰点）。</p>

<p>默认属性值</p>

<p>可以从一个初始化中设置一个存储属性的初始值，如上所示。另外，指定一个默认的属性值的属性的声明的一部分。您可以通过定义时将初始值的属性指定一个默认的属性值。</p>

<p>注意</p>

<p>如果属性总是相同的初始值，提供一个默认值，而不是一个初始化中设置的值。最终的结果是一样的，但默认值更紧密地联系在一起的财产的初始化它的声明。它使短，更清晰的初始化，使您能够推断它的默认值的属性的类型。默认值也使得它更容易让你利用默认初始化和初始化继承，如本章后面介绍。</p>

<p>你可以写在Fahrenheit上面提供其默认值结构简单的形式temperature在该属性声明的点属性：</p>

<p>struct Fahrenheit {<br/>
    var temperature = 32.0<br/>
}<br/>
自定义初始化</p>

<p>可以用输入参数和可选属性类型，或通过在初始化期间分配恒定属性定制的初始化过程中，如在以下部分中描述。</p>

<p>初始化参数</p>

<p>您可以提供初始化参数作为初始化定义的一部分，定义类型和自定义初始化过程值的名称。初始化参数具有相同的功能和语法函数和方法的参数。</p>

<p>下面的例子定义了一个名为结构Celsius，它存储在摄氏度表示的温度。该Celsius结构实现了两个称为定制初始化init(fromFahrenheit:)和init(fromKelvin:)，其初始化与来自不同的温度刻度值结构的一个新实例：</p>

<p>struct Celsius {<br/>
    var temperatureInCelsius: Double<br/>
    init(fromFahrenheit fahrenheit: Double) {<br/>
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8<br/>
    }<br/>
    init(fromKelvin kelvin: Double) {<br/>
        temperatureInCelsius = kelvin - 273.15<br/>
    }<br/>
}<br/>
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)<br/>
// boilingPointOfWater.temperatureInCelsius is 100.0<br/>
let freezingPointOfWater = Celsius(fromKelvin: 273.15)<br/>
// freezingPointOfWater.temperatureInCelsius is 0.0<br/>
第一初始化具有的参数标签单个初始化参数fromFahrenheit和参数名称fahrenheit。第二初始化具有的参数标签单个初始化参数fromKelvin和参数名称kelvin。这两个初始化转换自己的一个参数为相应的摄氏温度值，并存储在名为属性与此值temperatureInCelsius。</p>

<p>参数名称参数和标签</p>

<p>至于功能和方法参数，初始化参数可以同时用于初始化的身体内使用的参数名称并调用初始化时使用的参数标签。</p>

<p>但是，初始化没有将其在函数和方法的方式做括号前有一个确定的函数名。因此，名称和类型初始化器的参数，确定哪些初始化应该叫发挥特别重要的作用。正因为如此，雨燕提供了一个自动参数标签，每在一个初始化参数，如果你不提供的。</p>

<p>下面的例子定义了一个名为结构Color，有三个不变的属性叫red，green和blue。这些属性存储之间的值0.0和1.0指示的红色，绿色和蓝色的量。</p>

<p>Color提供类型的三个适当命名参数的初始值设定Double为它的红，绿，和蓝分量。Color还提供了一个单一的第二初始化white参数，这是用于提供对所有三个颜色成分相同的值。</p>

<p>struct Color {<br/>
    let red, green, blue: Double<br/>
    init(red: Double, green: Double, blue: Double) {<br/>
        self.red   = red<br/>
        self.green = green<br/>
        self.blue  = blue<br/>
    }<br/>
    init(white: Double) {<br/>
        red   = white<br/>
        green = white<br/>
        blue  = white<br/>
    }<br/>
}<br/>
既初始化可用于创建新的Color实例，通过对每个初始化参数提供命名值：</p>

<p>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)<br/>
let halfGray = Color(white: 0.5)<br/>
注意，这是不可能调用这些初始化，而无需使用一个参数的标签。参数标签必须始终在初始化中使用，如果它们被定义，并忽略他们来说是一个编译时错误：</p>

<p>let veryGreen = Color(0.0, 1.0, 0.0)<br/>
// this reports a compile-time error - argument labels are required<br/>
初始化参数没有参数标签</p>

<p>如果你不希望使用参数标签的初始化参数，写一个下划线（_），而不是该参数来覆盖缺省行为一个明确的说法标签。</p>

<p>下面是的扩展版本Celsius较早，有一个额外的初始化创建一个新的例子Celsius，从一个实例Double已在摄氏温标值：</p>

<p>struct Celsius {<br/>
    var temperatureInCelsius: Double<br/>
    init(fromFahrenheit fahrenheit: Double) {<br/>
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8<br/>
    }<br/>
    init(fromKelvin kelvin: Double) {<br/>
        temperatureInCelsius = kelvin - 273.15<br/>
    }<br/>
    init(_ celsius: Double) {<br/>
        temperatureInCelsius = celsius<br/>
    }<br/>
}<br/>
let bodyTemperature = Celsius(37.0)<br/>
// bodyTemperature.temperatureInCelsius is 37.0<br/>
初始化调用Celsius(37.0)是在其明确的意图，而不需要一个参数的标签。因此，有必要写这初始化因为init(_ celsius: Double)这样它可以通过提供一个无名被称为Double价值。</p>

<p>可选属性类型</p>

<p>如果您的自定义类型有一个逻辑上允许有一个存储财产“没有价值”-perhaps，因为它的价值不能在初始化过程中进行设置，或者是因为它允许在以后的某个点申报与财产有“没有价值” 可选类型。可选类型的属性自动的值进行初始化nil，表明属性是故意旨在初始化期间具有“无值尚”。</p>

<p>下面的例子定义了一个名为类SurveyQuestion，使用可选的String所谓财产response：</p>

<p>class SurveyQuestion {<br/>
    var text: String<br/>
    var response: String?<br/>
    init(text: String) {<br/>
        self.text = text<br/>
    }<br/>
    func ask() {<br/>
        print(text)<br/>
    }<br/>
}<br/>
let cheeseQuestion = SurveyQuestion(text: <q>Do you like cheese?</q>)<br/>
cheeseQuestion.ask()<br/>
// Prints <q>Do you like cheese?</q><br/>
cheeseQuestion.response = <q>Yes, I do like cheese.</q><br/>
一项调查问题的回答不能知道，直到有人问，所以response财产都被定义类型String?，或“可选String”。它是自动分配的默认值nil，意思是“没有字符串没有”，当一个新的实例的SurveyQuestion初始化。</p>

<p>分配常数初始化属性时</p>

<p>可以在初始化过程中在任何点分配一个值到一个恒定属性，只要它被设置为通过时间初始化完成一个确定的值。一旦一个恒定属性分配一个值，它不能被进一步改性。</p>

<p>注意</p>

<p>对于类实例，一个恒定属性可以初始化期间仅由介绍它的类改性。它不能由子类进行修改。</p>

<p>可以修改SurveyQuestion从上面的例子中使用的恒定属性而不是可变属性的text问题的属性，以指示该问题并不一次的实例改变SurveyQuestion被创建。虽然text属性现在一个常数，它仍然可以在类的初始化中设置：</p>

<p>class SurveyQuestion {<br/>
    let text: String<br/>
    var response: String?<br/>
    init(text: String) {<br/>
        self.text = text<br/>
    }<br/>
    func ask() {<br/>
        print(text)<br/>
    }<br/>
}<br/>
let beetsQuestion = SurveyQuestion(text: <q>How about beets?</q>)<br/>
beetsQuestion.ask()<br/>
// Prints <q>How about beets?</q><br/>
beetsQuestion.response = <q>I also like beets. (But not with cheese.)</q><br/>
默认初始化器</p>

<p>雨燕提供了一个默认初始值的，对于其所有属性提供了默认值，并且不提供至少一个初始化本身的任何结构或类。默认初始化只是简单地创建了所有其属性设置为默认值的新实例。</p>

<p>这个例子定义了一个名为类ShoppingListItem，它封装在购物列表中的项目的名称，数量，以及购买状态：</p>

<p>class ShoppingListItem {<br/>
    var name: String?<br/>
    var quantity = 1<br/>
    var purchased = false<br/>
}<br/>
var item = ShoppingListItem()<br/>
因为所有属性ShoppingListItem类有默认值，因为它是一个没有超基类，ShoppingListItem自动获取与所有其属性设置为默认值，创建一个新的实例的默认初始实现。（该name属性是一个可选的String属性，所以它会自动接收到的默认值nil，即使这个值是不是写在代码中）。上面的示例使用默认初始化为ShoppingListItem类创建初始化类的新实例语法，写成ShoppingListItem()，并且这个新的实例分配给一个称为变量item。</p>

<p>按成员初始化器的结构类型</p>

<p>结构类型自动接收按成员初始化，如果他们不定义任何自己的自定义初始化的。不同于默认初始值，结构接收即使它存储了没有默认值的属性一个成员逐一初始化。</p>

<p>该成员逐一初始化是初始化新的结构实例的成员属性的简便方法。新实例的属性的初始值都可以通过名字传递给成员逐一初始化。</p>

<p>下面的例子定义了一个名为结构Size具有两个属性叫width和height。两个属性推断为类型的Double通过分配的一默认值0.0。</p>

<p>该Size结构会自动收到一个init(width:height:)按成员初始化，您可以用它来 ​​初始化一个新Size的实例：</p>

<p>struct Size {<br/>
    var width = 0.0, height = 0.0<br/>
}<br/>
let twoByTwo = Size(width: 2.0, height: 2.0)<br/>
初始化代表团值类型</p>

<p>初始化函数可以调用其他初始化执行一个实例的初始化的一部分。这一过程，被称为初始化代表团，避免了跨多个初始化翻炒代码。</p>

<p>对于初始代表团是如何工作的，以及允许哪些形式代表团的规则，是值类型和类类型不同。值类型（结构和枚举）不支持继承，所以他们的初始授权过程比较简单，因为它们只能委托给另一个初始化他们提供自己。类，但是，可以从其他类继承，如描述的传承。这意味着，类有责任确保他们继承了所有存储的属性在初始化过程中被分配一个合适的值额外的责任。这些责任中描述类的继承和初始化下面。</p>

<p>对于值类型，您可以使用self.init编写自定义的初始化时参考来自同一个值类型为其他初始化。你可以调用self.init从初始化中只。</p>

<p>请注意，如果你定义自定义初始化的值类型，您将不再能够访问默认初始值（或按成员初始化，如果它是一个结构）为该类型。这个约束防止了在更复杂的初始化提供了更多的基本设置意外通过使用自动初始化一个人规避的情况。</p>

<p>注意</p>

<p>如果你希望你的自定义值类型为initializable使用默认初始化和初始化按成员，并与自己的自定义初始化，编写自定义初始值设定在扩展，而不是作为值类型的原始实现的一部分。欲了解更多信息，请参见扩展。</p>

<p>下面的例子定义一个定制的Rect结构来表示几何矩形。的例子需要两个叫做支承结构Size和Point，这两者提供的默认值0.0对于所有的属性：</p>

<p>struct Size {<br/>
    var width = 0.0, height = 0.0<br/>
}<br/>
struct Point {<br/>
    var x = 0.0, y = 0.0<br/>
}<br/>
可以初始化Rect由方式-使用其默认中的三分之一以下结构零初始化origin和size属性值，通过提供特定的原点和大小，或通过提供一个特定的中心点和大小。这些初始化选项是由该第三部分定制初始化代表Rect结构的定义：</p>

<p>struct Rect {<br/>
    var origin = Point()<br/>
    var size = Size()<br/>
    init() {}<br/>
    init(origin: Point, size: Size) {<br/>
        self.origin = origin<br/>
        self.size = size<br/>
    }<br/>
    init(center: Point, size: Size) {<br/>
        let originX = center.x - (size.width / 2)<br/>
        let originY = center.y - (size.height / 2)<br/>
        self.init(origin: Point(x: originX, y: originY), size: size)<br/>
    }<br/>
}<br/>
首先Rect初始化，init()在功能一样，如果它没有自己的定制初始化结构将收到的默认初始值。这个初始化有一个空的机构，由一对空花括号来表示{}。调用此初始化返回一个Rect实例，其origin与size特性与的默认值都初始化Point(x: 0.0, y: 0.0)并Size(width: 0.0, height: 0.0)从它们的属性定义：</p>

<p>let basicRect = Rect()<br/>
// basicRect&#39;s origin is (0.0, 0.0) and its size is (0.0, 0.0)<br/>
第二Rect初始化，init(origin:size:)在功能一样，如果它没有自己的定制初始化结构将收到的按成员初始化。这只是初始分配origin和size参数值到适当的存储性能：</p>

<p>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),<br/>
                      size: Size(width: 5.0, height: 5.0))<br/>
// originRect&#39;s origin is (2.0, 2.0) and its size is (5.0, 5.0)<br/>
第三Rect初始化，init(center:size:)是稍微复杂一些。它开始通过计算根据一个适当的原点center点和size值。然后调用（或委托）的init(origin:size:)初始化，存储在相应的属性中的新的来源和大小值：</p>

<p>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),<br/>
                      size: Size(width: 3.0, height: 3.0))<br/>
// centerRect&#39;s origin is (2.5, 2.5) and its size is (3.0, 3.0)<br/>
在init(center:size:)初始化可能分配的新值origin，并size以相应的属性本身。然而，它是（在意图和清晰）更方便的init(center:size:)初始取已提供正是功能的现有初始化的优势。</p>

<p>注意</p>

<p>对于另一种方式来写这个例子中没有定义init()和init(origin:size:)初始化自己，看看扩展。</p>

<p>类继承和初始化</p>

<p>所有类的存储特性，包括类从它继承superclass-任何属性的，必须初始化过程中被分配一个初始值。</p>

<p>斯威夫特定义了两种初始化为类类型，以帮助确保所有存储的性能收到的初始值。这些被称为指定初始化和便利的初始化。</p>

<p>指定初始化和便利的初始化</p>

<p>指定的初始值是一类主要的初始化。一个指定的初始化完全初始化由该类引入的所有属性和调用适当的超初始化继续初始化过程了超链。</p>

<p>类往往有极少数指定的初始值，这是很常见的一类只有一个。指定的初始值是通过初始化操作，并且通过初始化过程持续了超链“漏斗”之分。</p>

<p>每个类必须至少有一个指定的初始化。在某些情况下，这个要求是由继承一个或从超更指定的初始值，具体说明满足自动初始化程序继承的下方。</p>

<p>便利初始化是一类二级，支持初始化。您可以定义一个快捷的初始化从同一类的一些设置为默认值指定初始化函数的参数，方便初始化调用指定初始化。您也可以定义一个快捷的初始化为特定用例或输入值类型创建类的实例。</p>

<p>你不必提供便利的初始化，如果你的类不需要他们。创造便利初始化时的快捷方式常见的初始化模式会节省时间，或使类初始化更清晰的意图。</p>

<p>语法指定和便利的初始化</p>

<p>上课指定的初始值都写在以同样的方式为值类型一样简单初始化：</p>

<p>初始化（参数）{<br/>
    声明<br/>
}<br/>
便利初始化都写在相同的风格，但与convenience改性剂放在前init关键字，用空格分隔：</p>

<p>便利 的init（参数）{<br/>
    声明<br/>
}<br/>
初始化代表团类的类型</p>

<p>为了简化指定和便利的初始化之间的关系，斯威夫特适用于以下三个规则代表团初始化之间的调用：</p>

<p>规则1<br/>
个指定初始化必须调用其直接超类的指定初始化。</p>

<p>规则2<br/>
一个方便的初始化必须调用从另一个初始化同一类。</p>

<p>规则3<br/>
一个方便的初始最终必须调用指定初始化。</p>

<p>一个简单的方法来记住这个：</p>

<p>指定的初始值必须始终委派了。<br/>
便利的初始化必须始终委派跨越。<br/>
这些规则在如下图所示：</p>

<p>图片：../Art/initializerDelegation01_2x.png<br/>
在这里，超有一个单一的指定初始化和两个方便的初始化。一个方便的初始化调用另一个方便的初始化，进而调用一个指定的初始化。这满足规则2和3上面。超类本身没有进一步的超类，所以规则1不适用。</p>

<p>此图中的子类有两个指定的初始值和一个便利的初始化。便利初始化必须调用两个指定的初始值中的一个，因为它只能从同一类调用另一个初始化。这满足规则2和3上面。双方指定的初始化程序必须从超致电单一指定初始化，从上面满足规则1。</p>

<p>注意</p>

<p>这些规则不会影响你的类的用户如何创建每个类的实例。上面的图中的任何初始化可用于创建它们属于类的完全初始化实例。这些规则只影响你如何写类的初始化的实现。</p>

<p>下图显示了四个类更复杂的类层次结构。它说明了如何在此层级充当类初始化“漏斗”点，简化链类之间的相互关系的指定初始化：</p>

<p>图片：../Art/initializerDelegation02_2x.png<br/>
两相初始化</p>

<p>在夫特类初始化是一个两阶段过程。在第一个阶段中，每个存储属性分配由引入它的类的初始值。一旦每个存储属性的初始状态已经确定，第二阶段开始，每类有机会定制前进一步新的实例被认为是准备使用它的存储性能。</p>

<p>使用两阶段初始化过程使初始化安全，同时仍给予完全的灵活性，以每个类中的一类的层次结构。两相初始化防止它们被初始化之前被访问的属性值，并防止由另一个初始化被设置为不同的值出乎意料的属性值。</p>

<p>注意</p>

<p>斯威夫特的两相初始化过程类似于在Objective-C的初始化。主要的区别是，在阶段1，Objective-C的分配为零或空值（如0或nil），以每个属性。斯威夫特的初始化流程是，它可以让你设置自定义的初始值更加灵活，并能与类型为应付这0或nil不是有效的默认值。</p>

<p>斯威夫特的编译器执行四种有益的安全检查，以确保两相初始化完成，没有错误：</p>

<p>安全检查1<br/>
个指定初始化必须确保所有同级车引入的属性都才代表了一个超类初始化初始化。</p>

<p>如上所述，为一个对象的存储器只考虑完全初始化一旦它的所有存储属性的初始状态是已知的。为了使这一规则得到满足，一个指定初始化必须确保所有其自身属性的递给了同比环比前被初始化。</p>

<p>安全检查2<br/>
要继承的属性赋值之前，指定初始化必须委派到一个超类初始化。如果不是这样，新的值指定初始化受让人将由超作为自身初始化的一部分覆盖。</p>

<p>安全检查3<br/>
要分配一个值之前的简便初始化必须委托给另外一个初始化的任何财产（包括由同一个类定义的属性）。如果没有，则新值的便利初始化受让人将被其自己的类的指定初始化覆盖。</p>

<p>安全检查4<br/>
一个初始化不能调用任何实例方法，读取任何实例属性的值，或者是指self作为一个值，直到初始化后的第一阶段已完成。</p>

<p>类的实例并不完全有效，直到第一阶段结束。属性只能被访问，和方法只能叫，一旦类实例是已知的在第一阶段结束时有效。</p>

<p>下面是两相初始化如何发挥出来，根据上述四个安全检查：</p>

<p>阶段1</p>

<p>一个指定的或方便初始化被称为一类。<br/>
内存为类的新实例被分配。存储器尚未初始化。<br/>
对于A级指定初始化证实，由该类引入的所有存储的属性有一个值。这些存储属性存储器现在初始化。<br/>
指定初始化手开了一个超类的初始化执行相同的任务，为自己的存储性能。<br/>
直到达到链的顶部这样下去了类继承链。<br/>
一旦到达链的顶部，并在链中的最后一类已确保其所有存储属性具有值，该实例的存储器被认为是完全初始化，和第1阶段结束。<br/>
阶段2</p>

<p>工作从链的顶部回落，链中的每个指定初始化具有进一步定制实例的选项。初始化器现在可以访问self并可以修改其属性，调用它的实例方法，等等。<br/>
最后，在链中的任何方便的初始化必须定制实例并一起工作的选项self。<br/>
以下是第1阶段如何寻找一个初始化调用了一个假想的子类和超类：</p>

<p>图片：../Art/twoPhaseInitialization01_2x.png<br/>
在这个例子中，初始化开始到子类便利初始化呼叫。这种便利的初始化还不能修改任何属性。它代表整个从同一类中的指定初始化。</p>

<p>指定初始化确保所有子类的属性有一个值，按照安全检查1.然后调用其超类的指定初始化继续初始化环比上涨。</p>

<p>超类的指定初始化确保所有超类属性有一个值。有没有进一步超进行初始化，因此不需要进一步下放。</p>

<p>一旦超类的所有属性的初始值，它的内存被认为是完全初始化，和第一阶段已完成。</p>

<p>以下是第2阶段如何查找相同的初始化电话：</p>

<p>图片：../Art/twoPhaseInitialization02_2x.png<br/>
超类的指定初始化现在有机会进一步定制实例（虽然它不具备）。</p>

<p>一旦超类的指定初始化完成后，子类的指定初始化可以执行其他自定义（虽然再次，它不具备）。</p>

<p>最后，一​​旦子类的指定初始化完成后，最初被称为方便初始化可以执行其他定制。</p>

<p>初始化继承和压倒一切</p>

<p>不像在Objective-C的子类，斯威夫特子类默认不继承父类的初始化。迅速的方法可防止在从一个超类的简单初始化由更专业化的子类继承的，用于创建不完全或正确初始化子类的新实例的情况。</p>

<p>注意</p>

<p>超初始化都继承在某些情况下，但只有当它是安全的，适当的这样做。欲了解更多信息，请参阅自动初始化程序继承下方。</p>

<p>如果你想有一个自定义的子类来呈现一个或多个相同的初始化作为它的父类，你可以提供子类中的初始化的自定义实现。</p>

<p>当你写一个匹配超类的子类初始化指定的初始化，您可以高效地提供的指定初始化的重写。因此，您必须编写override子类的初始化定义之前修改。这是真实的，即使你是一个覆盖自动提供默认初始值，如描述默认初始化器。</p>

<p>与被覆盖的属性，方法或下标，则存在override修改提示斯威夫特检查超类具有匹配指定初始化被覆盖，并验证，作为适用于您的压倒一切的初始化参数已经指定。</p>

<p>注意</p>

<p>你总是写override覆盖超类指定初始化的时候，即使你的子类的实现初始化的是一个方便的初始修改。</p>

<p>相反，如果你写一个匹配超类的子类初始化的便利初始化，即超方便初始化不能直接由你的子类调用，如同上面所描述的规则，初始化器代表团类的类型。因此，子类是不是（严格来说）提供超类初始化的重写。这样一来，你不写override提供了一个方便的超初始化的匹配实现时修改。</p>

<p>下面的例子定义了一个基类Vehicle。这个基类声明了存储的属性称为numberOfWheels，用默认Int值0。该numberOfWheels属性由被称为计算的特性description来创建String的车辆的特征描述：</p>

<p>class Vehicle {<br/>
    var numberOfWheels = 0<br/>
    var description: String {<br/>
        return <q>(numberOfWheels) wheel(s)</q><br/>
    }<br/>
}<br/>
本Vehicle类提供一个默认值其只存储性能，并且不提供任何自定义初始化本身。其结果是，它会自动接收到一个默认初始值，如描述默认初始化器。的默认初始值（当可用时）始终为一类指定初始化，并且可以被用来创建一个新的Vehicle具有一个实例numberOfWheels的0：</p>

<p>let vehicle = Vehicle()<br/>
print(<q>Vehicle: (vehicle.description)</q>)<br/>
// Vehicle: 0 wheel(s)<br/>
下面的例子定义的子类Vehicle叫做Bicycle：</p>

<p>class Bicycle: Vehicle {<br/>
    override init() {<br/>
        super.init()<br/>
        numberOfWheels = 2<br/>
    }<br/>
}<br/>
该Bicycle子类定义自定义指定初始化，init()。这指定的初始化从匹配的超类指定初始化Bicycle，所以Bicycle这个初始版本标有override修改。</p>

<p>该init()用于初始化Bicycle通过调用开始super.init()，这就要求缺省初始化Bicycle类的超类Vehicle。这确保了numberOfWheels继承的属性是由初始化Vehicle之前Bicycle有权修改属性的机会。呼叫后super.init()，原来的值numberOfWheels被替换为一个新的值2。</p>

<p>如果创建的一个实例Bicycle，就可以调用它继承了description计算性能，看看其numberOfWheels性能已更新：</p>

<p>let bicycle = Bicycle()<br/>
print(<q>Bicycle: (bicycle.description)</q>)<br/>
// Bicycle: 2 wheel(s)<br/>
注意</p>

<p>子类可以初始化过程中修改继承变量属性，但不能修改继承不变的属性。</p>

<p>自动初始化程序继承</p>

<p>如上所述，子类默认不继承父类的初始化。然而，超类的初始化是，如果某些条件得到满足自动继承。在实践中，这意味着你不需要编写初始化覆盖在许多常见的场景，并可以继承以最小的努力超类初始化时，它是安全的这样做。</p>

<p>假设你对你在子类中引入任何新的属性提供默认值，以下两条规则：</p>

<p>规则1<br/>
如果你的子类不定义任何指定的初始化程序，它会自动继承其所有的超指定初始化的。</p>

<p>规则2<br/>
如果你的子类提供了一个实现所有其超类指定的初始化-要么通过继承他们按规则1，或通过提供一个自定义实现作为其组成部分的定义，那么它会自动继承了所有超便利的初始化方法。</p>

<p>这些规则适用，即使你的子类中增加了更多的便利初始化。</p>

<p>注意</p>

<p>子类可以实现超类指定初始化为方便子类初始化为满足第2条的一部分。</p>

<p>指定和便利的初始化在行动</p>

<p>下面的示例显示指定初始化，初始化的便利，并在行动中自动初始化继承。这个例子定义了三类所谓的层次结构Food，RecipeIngredient以及ShoppingListItem，并演示了如何自己初始化交互。</p>

<p>在层次结构的基类被称为Food，这是一个简单的类来封装食料的名称。该Food课程介绍一个String叫做物业name并提供两个初始化创建Food实例：</p>

<p>class Food {<br/>
    var name: String<br/>
    init(name: String) {<br/>
        self.name = name<br/>
    }<br/>
    convenience init() {<br/>
        self.init(name: <q>[Unnamed]</q>)<br/>
    }<br/>
}<br/>
下图显示了初始化链Food类：</p>

<p>图片：../Art/initializersExample01_2x.png<br/>
类没有默认的成员逐一初始化，所以Food类提供了一个指定初始化这需要所谓的一个参数name。此初始化可用于创建新的Food具有特定名称的实例：</p>

<p>let namedMeat = Food(name: <q>Bacon</q>)<br/>
// namedMeat&#39;s name is <q>Bacon</q><br/>
在init(name: String)从初始化Food类是提供一个指定的初始化，因为它确保新的所有存储性能Food的实例完全初始化。本Food类没有超类，所以init(name: String)初始化并不需要调用super.init()来完成它的初始化。</p>

<p>该Food级还提供了一个方便的初始化，init()不带参数。该init()初始化通过委派跨越到一个新的食品提供了一个默认的占位符名称Food类的init(name: String)具有name价值[Unnamed]：</p>

<p>let mysteryMeat = Food()<br/>
// mysteryMeat&#39;s name is <q>[Unnamed]</q><br/>
在层次结构中的第二类是的子类Food叫做RecipeIngredient。本RecipeIngredient类机型在烹饪配方的成分。它介绍了一种Int称为属性quantity（除了name它从继承属性Food）和定义了两个初始化用于创建RecipeIngredient实例：</p>

<p>class RecipeIngredient: Food {<br/>
    var quantity: Int<br/>
    init(name: String, quantity: Int) {<br/>
        self.quantity = quantity<br/>
        super.init(name: name)<br/>
    }<br/>
    override convenience init(name: String) {<br/>
        self.init(name: name, quantity: 1)<br/>
    }<br/>
}<br/>
下图显示了初始化链RecipeIngredient类：</p>

<p>图片：../Art/initializersExample02_2x.png<br/>
该RecipeIngredient班 ​​有一个单一的指定初始化，init(name: String, quantity: Int)，可用于填充所有新的属性的RecipeIngredient实例。这个初始化通过指定传递启动quantity参数的quantity属性，它是由引入的唯一的新属性RecipeIngredient。这样做之后，初始化代表到init(name: String)该初始化的Food类。这个过程从满足安全检查1 两阶段初始化以上。</p>

<p>RecipeIngredient还定义了一个方便的初始化，init(name: String)，这是用于创建RecipeIngredient按名称单独实例。这个便利初始假设的数量1对于任何RecipeIngredient被没有明确的数量创建的实例。这种便利初始化的定义，使RecipeIngredient情况更加快捷方便地创建，并创建多个单量时避免重复代码RecipeIngredient实例。这种便利的初始化只是对面的类的指定初始化代表，传递一个quantity值1。</p>

<p>该init(name: String)所提供的便利初始化RecipeIngredient取相同的参数指定的初始化。由于这种便利的初始化覆盖从它的超类的指定初始化，它必须与被标记修饰符（如中所述初始化器继承和压倒一切）。 init(name: String) Foodoverride</p>

<p>即使RecipeIngredient提供了init(name: String)初始的方便初始化，RecipeIngredient也仍然提供了所有其超类的指定初始化的实现。因此，RecipeIngredient自动继承其所有超类的初始化方便的了。</p>

<p>在本实施例中，超类RecipeIngredient是Food，它有一个单一的便利初始化叫做init()。因此，这种初始化是通过继承RecipeIngredient。的继承的版本init()的功能完全相同的方式与Food版本，除了它委托给RecipeIngredient版本的init(name: String)，而不是Food版本。</p>

<p>所有这三个初始值可以被用于创建新的RecipeIngredient实例：</p>

<p>let oneMysteryItem = RecipeIngredient()<br/>
let oneBacon = RecipeIngredient(name: <q>Bacon</q>)<br/>
let sixEggs = RecipeIngredient(name: <q>Eggs</q>, quantity: 6)<br/>
在层次结构中的第三个和最后类的子类RecipeIngredient叫做ShoppingListItem。在ShoppingListItem类模型，因为它出现在购物清单配方成分。</p>

<p>在购物清单中的每个项目开始作为“未购买”。为了表示这个事实，ShoppingListItem引入了一个布尔属性称为purchased，用默认值false，ShoppingListItem还增加了计算的description特性，它提供的文字说明ShoppingListItem的实例：</p>

<p>class ShoppingListItem: RecipeIngredient {<br/>
    var purchased = false<br/>
    var description: String {<br/>
        var output = <q>(quantity) x (name)</q><br/>
        output += purchased ? <q>✔</q> : <q>✘</q><br/>
        return output<br/>
    }<br/>
}<br/>
注意</p>

<p>ShoppingListItem没有定义初始化提供一个初始值purchased，因为在一个购物清单的物品（如仿照这里）总是开始时未购买。</p>

<p>因为它提供了所有属性，引入并没有定义任何初始化本身的默认值，ShoppingListItem自动继承所有自其超指定的和方便的初始化。</p>

<p>下图显示了所有三类整体初始化链：</p>

<p>图片：../Art/initializersExample03_2x.png<br/>
您可以使用所有这三个继承初始化的创建一个新ShoppingListItem的实例：</p>

<p>var breakfastList = [<br/>
    ShoppingListItem(),<br/>
    ShoppingListItem(name: <q>Bacon</q>),<br/>
    ShoppingListItem(name: <q>Eggs</q>, quantity: 6),<br/>
]<br/>
breakfastList[0].name = <q>Orange juice</q><br/>
breakfastList[0].purchased = true<br/>
for item in breakfastList {<br/>
    print(item.description)<br/>
}<br/>
// 1 x Orange juice ✔<br/>
// 1 x Bacon ✘<br/>
// 6 x Eggs ✘<br/>
在这里，所谓的新阵列breakfastList由文字包含三个新的数组创建ShoppingListItem实例。类型阵列的被推断为[ShoppingListItem]。创建阵列之后，的名称ShoppingListItem在阵列的开始是从改变<q>[Unnamed]</q>到<q>Orange juice</q>与它被标记为已被购买。印刷阵列中的每个项目的描述表明，按照预期默认状态被置位。</p>

<p>Failable初始化器</p>

<p>它有时是有益的定义一个类，结构或枚举它的初始化可能会失败。这种故障可能是由无效初始化参数值被触发，由于没有所需的外部资源的，或防止初始化得手一些其它条件。</p>

<p>为了应对初始化条件可能会失败，定义一个或多个failable初始化为一类，结构或枚举定义的一部分。您可以通过放置一个问号后写failable初始化init关键字（init?）。</p>

<p>注意</p>

<p>你不能定义一个failable和相同的参数类型和名称的nonfailable初始化。</p>

<p>一个failable初始化创建一个可选的它初始化类型的值。你写return nil一个failable初始化中，表示在该初始化失败可触发点。</p>

<p>注意</p>

<p>严格来说，初始化没有返回值。相反，它们的作用是保证self是由该初始化结束的时间充分和正确地初始化。虽然你写return nil触发一个初始化失败，您不要使用return关键字来表示初始化成功。</p>

<p>下面的例子定义了一个名为结构Animal，具有恒定String​​叫做财产species。该Animal结构还限定与称为单参数failable初始化species。这个初始化检查，如果species传递给初始值是一个空字符串。如果找到一个空字符串，初始化失败被触发。否则，该species属性的值设置和初始化成功：</p>

<p>struct Animal {<br/>
    let species: String<br/>
    init?(species: String) {<br/>
        if species.isEmpty { return nil }<br/>
        self.species = species<br/>
    }<br/>
}<br/>
您可以使用此failable初始化尝试初始化一个新的Animal实例，并检查是否初始化成功：</p>

<p>let someCreature = Animal(species: <q>Giraffe</q>)<br/>
// someCreature is of type Animal?, not Animal</p>

<p>if let giraffe = someCreature {<br/>
    print(<q>An animal was initialized with a species of (giraffe.species)</q>)<br/>
}<br/>
// Prints <q>An animal was initialized with a species of Giraffe</q><br/>
如果你传递一个空字符串值给failable初始化的species参数，初始化触发初始化失败：</p>

<p>let anonymousCreature = Animal(species: &quot;&quot;)<br/>
// anonymousCreature is of type Animal?, not Animal</p>

<p>if anonymousCreature == nil {<br/>
    print(<q>The anonymous creature could not be initialized</q>)<br/>
}<br/>
// Prints <q>The anonymous creature could not be initialized</q><br/>
注意</p>

<p>检查空字符串值（如<q>，而不是<q>Giraffe</q>）是不一样的检查nil，以指示不存在的可选 String值。在上面的例子中，一个空字符串（</q>）是一个有效的，非可选String。然而，这是不适合的动物有一个空字符串作为它的值species属性。为了模拟这种限制，如果一个空字符串发现failable初始化触发初始化失败。</p>

<p>对于枚举Failable初始化器</p>

<p>可以使用一个failable初始化来选择基于一个或多个参数的适当枚举的情况下。然后初始化可如果提供的参数不匹配适当的枚举情况下失败。</p>

<p>下面的例子定义了一个枚举TemperatureUnit，有三个可能的状态（kelvin，celsius，和fahrenheit）。一个failable初始化来找到一个合适的枚举情况下Character代表的温度符号值：</p>

<p>enum TemperatureUnit {<br/>
    case kelvin, celsius, fahrenheit<br/>
    init?(symbol: Character) {<br/>
        switch symbol {<br/>
        case <q>K</q>:<br/>
            self = .kelvin<br/>
        case <q>C</q>:<br/>
            self = .celsius<br/>
        case <q>F</q>:<br/>
            self = .fahrenheit<br/>
        default:<br/>
            return nil<br/>
        }<br/>
    }<br/>
}<br/>
您可以使用此failable初始化选择适当的枚举情况下的三种可能的状态，并导致初始化，如果该参数不符合这些国家的一个失败：</p>

<p>let fahrenheitUnit = TemperatureUnit(symbol: <q>F</q>)<br/>
if fahrenheitUnit != nil {<br/>
    print(<q>This is a defined temperature unit, so initialization succeeded.</q>)<br/>
}<br/>
// Prints <q>This is a defined temperature unit, so initialization succeeded.</q></p>

<p>let unknownUnit = TemperatureUnit(symbol: <q>X</q>)<br/>
if unknownUnit == nil {<br/>
    print(<q>This is not a defined temperature unit, so initialization failed.</q>)<br/>
}<br/>
// Prints <q>This is not a defined temperature unit, so initialization failed.</q><br/>
Failable的初始化为枚举与原始值</p>

<p>与原始值枚举自动接收failable初始化，init?(rawValue:)，带有一个名为参数rawValue适当的原始值类型和选择，如果找到一个匹配的枚举情况下，如果没有匹配的值存在触发初始化失败。</p>

<p>你可以重写TemperatureUnit例如从上面使用类型的原始数据Character，并采取优势init?(rawValue:)初始化：</p>

<p>enum TemperatureUnit: Character {<br/>
    case kelvin = <q>K</q>, celsius = <q>C</q>, fahrenheit = <q>F</q><br/>
}</p>

<p>let fahrenheitUnit = TemperatureUnit(rawValue: <q>F</q>)<br/>
if fahrenheitUnit != nil {<br/>
    print(<q>This is a defined temperature unit, so initialization succeeded.</q>)<br/>
}<br/>
// Prints <q>This is a defined temperature unit, so initialization succeeded.</q></p>

<p>let unknownUnit = TemperatureUnit(rawValue: <q>X</q>)<br/>
if unknownUnit == nil {<br/>
    print(<q>This is not a defined temperature unit, so initialization failed.</q>)<br/>
}<br/>
// Prints <q>This is not a defined temperature unit, so initialization failed.</q><br/>
初始化失败的传播</p>

<p>类，结构或枚举的failable初始化可以在委托同一类，结构或枚举另一个failable初始化。同样，一个子类failable初始化可以委派到一个超failable初始化。</p>

<p>在这两种情况下，如果委派到使初始化失败另一个初始化，整个初始化过程立即失败，并且执行进一步的初始化代码。</p>

<p>注意</p>

<p>一个failable初始化也可以委托给nonfailable初始化。如果你需要一个潜在的故障状态添加到现有的初始化过程，不因其他原因无法使用此方法。</p>

<p>下面的例子定义的一个子类Product叫CartItem。的CartItem。类车型在在线购物车中的项目CartItem介绍了调用的存储不变的性质quantity，并确保该属性始终具有至少一个值1：</p>

<p>class Product {<br/>
    let name: String<br/>
    init?(name: String) {<br/>
        if name.isEmpty { return nil }<br/>
        self.name = name<br/>
    }<br/>
}</p>

<p>class CartItem: Product {<br/>
    let quantity: Int<br/>
    init?(name: String, quantity: Int) {<br/>
        if quantity &lt; 1 { return nil }<br/>
        self.quantity = quantity<br/>
        super.init(name: name)<br/>
    }<br/>
}<br/>
该failable初始化为CartItem通过验证它已经收到了开始quantity的值1以上。如果quantity是无效的，整个初始化过程立即失败，并且不再执行进一步的初始化代码。同样，failable初始化的Product检查name，如果值，初始化过程立即失败name是空字符串。</p>

<p>如果您创建CartItem一个非空的名称和数量实例1以上，初始化成功：</p>

<p>if let twoSocks = CartItem(name: <q>sock</q>, quantity: 2) {<br/>
    print(<q>Item: (twoSocks.name), quantity: (twoSocks.quantity)</q>)<br/>
}<br/>
// Prints <q>Item: sock, quantity: 2</q><br/>
如果您尝试创建CartItem一个实例quantity的值0，则CartItem初始化引起的初始化失败：</p>

<p>if let zeroShirts = CartItem(name: <q>shirt</q>, quantity: 0) {<br/>
    print(<q>Item: (zeroShirts.name), quantity: (zeroShirts.quantity)</q>)<br/>
} else {<br/>
    print(<q>Unable to initialize zero shirts</q>)<br/>
}<br/>
// Prints <q>Unable to initialize zero shirts</q><br/>
同样，如果您尝试创建CartItem一个空的实例name值，超类Product的初始化引起的初始化失败：</p>

<p>if let oneUnnamed = CartItem(name: &quot;<q>, quantity: 1) {<br/>
    print(</q>Item: (oneUnnamed.name), quantity: (oneUnnamed.quantity)<q>)<br/>
} else {<br/>
    print(</q>Unable to initialize one unnamed product<q>)<br/>
}<br/>
// Prints</q>Unable to initialize one unnamed product&quot;<br/>
覆盖一个Failable初始化器</p>

<p>您可以在子类中覆盖超类failable初始化，就像任何其他初始化。另外，您可以覆盖一个子类的超failable初始化nonfailable初始化。这使您可以定义一个子类初始化它不能失败，即使超类的初始化允许失败。</p>

<p>请注意，如果你重写了nonfailable子类初始化一个failable超初始化，只有这样，才能委托到超初始化很给力，解开了failable超初始化的结果。</p>

<p>注意</p>

<p>您可以覆盖一个failable初始化一个nonfailable初始化而不是周围的其他方式。</p>

<p>下面的例子定义了一个名为类Document。此类模型可以与被初始化一个文件name要么是一个非空字符串值或属性nil，但不能是空字符串：</p>

<p>class Document {<br/>
    var name: String?<br/>
    // this initializer creates a document with a nil name value<br/>
    init() {}<br/>
    // this initializer creates a document with a nonempty name value<br/>
    init?(name: String) {<br/>
        if name.isEmpty { return nil }<br/>
        self.name = name<br/>
    }<br/>
}<br/>
下面的例子定义的一个子类Document叫AutomaticallyNamedDocument。该AutomaticallyNamedDocument子类重写都是由引入的指定初始化的Document。这些覆盖确保一个AutomaticallyNamedDocument实例都有一个初始name值<q>[Untitled]</q>如果实例没有名字初始化，或者一个空字符串传递给init(name:)初始化：</p>

<p>class AutomaticallyNamedDocument: Document {<br/>
    override init() {<br/>
        super.init()<br/>
        self.name = <q>[Untitled]</q><br/>
    }<br/>
    override init(name: String) {<br/>
        super.init()<br/>
        if name.isEmpty {<br/>
            self.name = <q>[Untitled]</q><br/>
        } else {<br/>
            self.name = name<br/>
        }<br/>
    }<br/>
}<br/>
在AutomaticallyNamedDocument覆盖其超 ​​类的failable init?(name:)与nonfailable初始化init(name:)初始化。因为AutomaticallyNamedDocument与在比其超类不同的方式空字符串的情况下对付，它的初始值并不需要失败，所以它提供了初始的一nonfailable版本代替。</p>

<p>您可以使用强制解缠在初始化调用从超一failable初始化作为一个子类的初始化nonfailable的实现的一部分。例如，UntitledDocument下面的子类总是命名<q>[Untitled]</q>，它使用failable init(name:)初始化期间初始化从超类。</p>

<p>class UntitledDocument: Document {<br/>
    override init() {<br/>
        super.init(name: <q>[Untitled]</q>)!<br/>
    }<br/>
}<br/>
在这种情况下，如果init(name:)超类的初始化都曾经与一个空字符串作为名称叫，被迫展开操作将导致运行错误。但是，因为它被称为一个字符串常量，你可以看到初始化不会失败，所以在这种情况下，就不会发生运行时错误。</p>

<p>初始化！Failable初始化器</p>

<p>您通常定义放置一个问号之后创建相应类型的可选实例的初始化failable init关键字（init?）。或者，您可以定义创建相应类型的隐式展开可选实例的初始化failable。由后放置一个惊叹号做这个init关键字（init!），而不是一个问号。</p>

<p>您可以从委托init?到init!，反之亦然，你可以覆盖init?有init!，反之亦然。您也可以从授权init到init!，尽管这样做会引发一个断言，如果init!初始化导致初始化失败。</p>

<p>所需的初始化</p>

<p>写required一个类初始化之前定义修改，以表明类的每个子类必须实现初始化：</p>

<p>class SomeClass {<br/>
    required init() {<br/>
        // initializer implementation goes here<br/>
    }<br/>
}<br/>
你还必须编写required每个子类中实现所需的初始化之前修改，以表明初始化要求适用于链条进一步子类。你不写override覆盖所需的指定初始化时修改：</p>

<p>class SomeSubclass: SomeClass {<br/>
    required init() {<br/>
        // subclass implementation of the required initializer goes here<br/>
    }<br/>
}<br/>
注意</p>

<p>您没有提供一个明确的实施需要初始化，如果你可以继承初始化满足要求。</p>

<p>设置默认属性值与一个封闭或功能</p>

<p>如果存储属性的默认值需要一些定制或设置，你可以使用一个关闭或全局函数提供的属性自定义的默认值。每当类型的新实例财产属于被初始化，关闭或函数被调用，其返回值被指定为属性的默认值。</p>

<p>这些种类的封闭或功能的通常创建的类型相同值来表示所希望的初始状态下的特性，裁缝的临时值，然后返回到可以使用该临时值作为属性的默认值。</p>

<p>下面是一个封闭如何被用来提供一个默认的属性值的骨架轮廓：</p>

<p>class SomeClass {<br/>
    let someProperty: SomeType = {<br/>
        // create a default value for someProperty inside this closure<br/>
        // someValue must be of the same type as SomeType<br/>
        return someValue<br/>
    }()<br/>
}<br/>
需要注意的是封闭的结束大括号后面跟着一对空括号。这告诉斯威夫特立即执行关闭。如果忽略这些括号，你想分配封闭自己的财产，而不是封闭的返回值。</p>

<p>注意</p>

<p>如果您使用闭包来初始化属性，记得实例的其余部分尚未在所执行的闭合点初始化。这意味着你不能从你的封内访问任何其他属性值，即使这些属性具有默认值。你也不能使用隐含self属性，或者调用任何实例的方法。</p>

<p>下面的例子定义了一个名为结构Chessboard，其车型板盘棋。国际象棋是上播放一个8x8板，交替的黑色和白色方块。</p>

<p>图片：../Art/chessBoard_2x.png<br/>
为了表示这个游戏板，Chessboard结构有一个属性叫boardColors，这是64的阵列Bool值。的值true在数组表示一个黑色的正方形和值false代表一个白色正方形。数组中的第一项代表在董事会和数组中的最后一项左上角方形代表在董事会右下角广场。</p>

<p>所述boardColors阵列初始化为闭合设立其颜色值：</p>

<p>struct Chessboard {<br/>
    let boardColors: [Bool] = {<br/>
        var temporaryBoard = <a href="">Bool</a><br/>
        var isBlack = false<br/>
        for i in 1...8 {<br/>
            for j in 1...8 {<br/>
                temporaryBoard.append(isBlack)<br/>
                isBlack = !isBlack<br/>
            }<br/>
            isBlack = !isBlack<br/>
        }<br/>
        return temporaryBoard<br/>
    }()<br/>
    func squareIsBlackAt(row: Int, column: Int) -&gt; Bool {<br/>
        return boardColors[(row * 8) + column]<br/>
    }<br/>
}<br/>
每当一个新Chessboard创建的实例，封闭被执行，并且缺省值boardColors被计算和返回。上面计算例子中的关闭和设置在所谓的临时数组在黑板上每平方米相应的颜色temporaryBoard，而一旦它的设置就完成了返回此临时数组作为封闭的返回值。返回的数组的值存储在boardColors可与该被查询squareIsBlackAtRow的效用函数：</p>

<p>let board = Chessboard()<br/>
print(board.squareIsBlackAt(row: 0, column: 1))<br/>
// Prints <q>true</q><br/>
print(board.squareIsBlackAt(row: 7, column: 7))<br/>
// Prints <q>false</q></p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743598699234.html"  title="Previous Post: 继承">&laquo; 继承</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743599349637.html" 
	        title="Next Post: 反初始化">反初始化 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743599314901.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
