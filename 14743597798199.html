<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  关闭 - Swift 3.0 自翻译 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 自翻译 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 自翻译 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 自翻译 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
          
            <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="功能" href="14743597582027.html">功能</a></li>
          
            <li><a title="关闭" href="14743597798199.html">关闭</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标" href="14743598556978.html">下标</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="初始化" href="14743599314901.html">初始化</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
                        
                          <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="功能" href="14743597582027.html">功能</a></li>
                        
                          <li><a title="关闭" href="14743597798199.html">关闭</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标" href="14743598556978.html">下标</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="初始化" href="14743599314901.html">初始化</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>关闭</h1>

<p>闭包是功能自足块，可以被传递，并在你的代码中使用。在斯威夫特闭包是类似于C块和Objective-C和其他编程语言的lambda表达式。</p>

<p>封可以捕获和存储的引用，以从上下文中定义它们的任何常量和变量。这被称为闭合以上这些常数和变量。斯威夫特处理所有捕获你的内存管理。</p>

<p>注意</p>

<p>如果你不熟悉捕获的概念，不要担心。它被详细解释如下捕获值。</p>

<p>全局和嵌套函数，如推出的功能，实际上是封闭的特殊情况。瓶盖采取三种形式之一：</p>

<p>全球的功能是具有一个名字和不捕获任何值关闭。<br/>
嵌套函数是有一个名称，可以从他们的封闭功能捕捉值关闭。<br/>
关闭表情都写在一个轻量级的语法，可以从周围环境获取值无名关闭。<br/>
斯威夫特的封闭表达式有一个干净，清晰的风格，与鼓励常见的场景简单，整洁的语法优化。这些优化包括：</p>

<p>根据上下文推断参数和返回值类型<br/>
从单封表达含蓄的回报<br/>
速记参数名<br/>
尾随的闭包语法<br/>
关闭表达式</p>

<p>嵌套函数，如在引入嵌套函数，是命名和定义的代码自足块作为一个更大的功能的一部分的方便手段。然而，它有时是有益的写较短版本的功能样构建没有一个完整的声明和名称。当你与函数或采取功能为一体的或更多的参数方法的工作尤其如此。</p>

<p>关闭表情都写在一个简短的内联闭包的方式，重点语法。封闭表达式进行写操作的缩写形式不封清晰度还是意图损失提供了多种语法的优化。下面的闭合表达式示例通过细化的一个例子来说明这些优化sorted(by:)过几个迭代方法，以更简洁的方式每个表达了相同的功能。</p>

<p>排序方法</p>

<p>斯威夫特的标准库提供了一个调用的方法sorted(by:)，这种种已知类型的值数组的基础上，排序结束您提供的输出。一旦完成了分拣过程中，sorted(by:)方法返回相同类型和尺寸与老一新的数组，其在正确的排序顺序元素。原始数组不被修改的sorted(by:)方法。</p>

<p>下面的封闭表达示例使用sorted(by:)方法排序数组String值相反的字母顺序排列。下面就来排序的初始阵列：</p>

<p>let names = [<q>Chris</q>, <q>Alex</q>, <q>Ewa</q>, <q>Barry</q>, <q>Daniella</q>]<br/>
该sorted(by:)方法接受一个闭包，是以相同类型的数组的内容的两个参数，并返回一个Bool值，说是否一旦值进行排序的第一个值应该在第二个值之前或之后出现。分拣封需要返回true如果第一个值应该出现之前，第二个值，false否则。</p>

<p>本实施例是排序的阵列String值，因此分选闭合需要类型的函数(String, String) -&gt; Bool。</p>

<p>提供分拣封的一种方式是编写正确类型的正常功能，并给它作为参数传递给sorted(by:)方法：</p>

<p>func backward(_ s1: String, _ s2: String) -&gt; Bool {<br/>
    return s1 &gt; s2<br/>
}<br/>
var reversedNames = names.sorted(by: backward)<br/>
// reversedNames is equal to [<q>Ewa</q>, <q>Daniella</q>, <q>Chris</q>, <q>Barry</q>, <q>Alex</q>]<br/>
如果第一串（s1）比所述第二串（更大s2），则backward(<u>:</u>:)函数将返回true，指示s1之前应该出现s2排序数组中为止。对于字符串中的字符，“大于”是指“后来出现在字母不是”。这意味着，信<q>B</q>是字母“大于” <q>A</q>和字符串<q>Tom</q>是大于这个字符串<q>Tim</q>。这给出了一个相反的字母排序，使用<q>Barry</q>之前被放置<q>Alex</q>，并依此类推。</p>

<p>然而，这是写什么本质上是一个单一的表达功能（相当啰嗦的方式a &gt; b）。在这个例子中，这将是优选的写分拣闭合联，使用闭合表达式语法。</p>

<p>关闭表达式语法</p>

<p>关闭表达式语法具有以下一般形式：</p>

<p>{（参数） - &gt; 返回类型 的<br/>
    声明<br/>
}<br/>
该参数在封闭表达式语法可以在输出参数，但是他们不能有一个默认值。如果您命名一个可变参数可变参数的参数都可以使用。元组也可以用来作为参数类型和返回类型。</p>

<p>下面的例子显示了一个封闭表达式版本backward(<u>:</u>:)从早期的功能：</p>

<p>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in<br/>
    return s1 &gt; s2<br/>
})<br/>
需要注意的是参数和返回值类型为这个内嵌封的声明是相同的，从申报backward(<u>:</u>:)的功能。在这两种情况下，它被写成(s1: String, s2: String) -&gt; Bool。然而，内联封表达，参数和返回值类型都写里面的花括号，不是外面他们。</p>

<p>封闭件的主体的开始是由引入in关键字。这个关键字表明封闭的参数和返回值类型的定义已完成，封闭的主体为即将开始。</p>

<p>由于封闭的身体是如此短暂，它甚至可以写上一行​​：</p>

<p>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )<br/>
这说明，对整个调用sorted(by:)方法保持不变。一对括号仍然包裹该方法的整个参数。然而，这样的说法现在是一个内联关闭。</p>

<p>推断类型从上下文</p>

<p>由于分拣封作为参数传递给方法传递，斯威夫特可以推断出它的参数的类型和返回值的类型。该sorted(by:)方法被称为一个字符串数组，因此其参数必须是类型的函数(String, String) -&gt; Bool。这意味着，(String, String)和Bool类型不必写成闭合表达式定义的一部分做。因为所有类型的可以推断，返回箭头（-&gt;）和周围的参数的名称的括号也可以省略：</p>

<p>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )<br/>
它总是可以推断参数类型和传递结束时，函数或方法作为内嵌闭合表达式返回类型。其结果是，你永远需要当盖被用作一个函数或方法的参数在其最全的形式来写一个内联关闭。</p>

<p>尽管如此，你仍然可以做出明确的类型，如果你愿意的话，如果它避免了歧义为您的代码的读者这样做时，是鼓励。在的情况下sorted(by:)的方法，该封闭件的目的是从该排序是正在发生的事实清楚，它是安全的读取器的假设，该封闭件有可能与被工作String值，因为它与分拣协助的字符串的数组。</p>

<p>从单表达式闭包隐式返回</p>

<p>单封表达可省略隐式返回的一个表达式的结果return从他们的声明中的关键字，因为在这个版本在前面的例子中：</p>

<p>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )<br/>
在这里，功能型sorted(by:)方法的参数明确指出，一个Bool值必须关闭返回。因为封闭件的主体包含一个表达式（s1 &gt; s2）返回一个Bool值，不存在二义性，并且return可以省略关键字。</p>

<p>速记参数名</p>

<p>迅速自动提供速记参数名内联封闭，其可以被用于通过名称提及的关闭的参数的值\(0，\)1，$2，等。</p>

<p>如果您关闭表达式中使用这些速记参数名称，你可以从它的定义中省略封闭的参数列表，并速记参数名的数量和类型将从预期的功能类型进行推断。的in关键字也可以省略的，因为封闭件表达是由完全其体：</p>

<p>reversedNames = names.sorted(by: { \(0 &gt; \)1 } )<br/>
在这里，\(0并\)1指封闭的第一和第二String参数。</p>

<p>操作方法：</p>

<p>实际上，有一个更短的写在上面封的表现方式。迅速的String类型定义了大于算子（其特定字符串的实现&gt;），为具有类型的两个参数的方法String，并返回类型的值Bool。这完全按所需的方法类型相匹配sorted(by:)方法。因此，你可以简单地通过在大于运营商，和斯威夫特将推断出你想使用它的特定字符串的实现：</p>

<p>reversedNames = names.sorted(by: &gt;)<br/>
欲了解更多有关运算方法，请参阅操作方法。</p>

<p>尾随瓶盖</p>

<p>如果你需要一个封闭表达式传递给函数作为函数的最后一个参数和封闭的表达很长，它可以把它写一个有用的尾随闭合来代替。而结尾的闭包被调用函数的括号后写的，即使它仍然是一个函数参数。当您使用尾随闭包语法，你不写为封参数标签作为函数调用的一部分。</p>

<p>func someFunctionThatTakesAClosure(closure: () -&gt; Void) {<br/>
    // function body goes here<br/>
}</p>

<p>// Here&#39;s how you call this function without using a trailing closure:</p>

<p>someFunctionThatTakesAClosure(closure: {<br/>
    // closure&#39;s body goes here<br/>
})</p>

<p>// Here&#39;s how you call this function with a trailing closure instead:</p>

<p>someFunctionThatTakesAClosure() {<br/>
    // trailing closure&#39;s body goes here<br/>
}<br/>
从字符串分拣封封表达式语法上面的部分可以写在外面sorted(by:)方法的括号内为封闭落后：</p>

<p>reversedNames = names.sorted() { \(0 &gt; \)1 }<br/>
如果一个封闭表达式是作为函数或方法唯一的参数，您提供的表达式作为尾随关闭，你不需要写一对括号的()函数或方法的名称后，当你调用该函数：</p>

<p>reversedNames = names.sorted { \(0 &gt; \)1 }<br/>
当封闭足够长，这是不可能的它的内联写在一行上尾随封是最有用的。作为一个例子，斯威夫特的Array类型都有map(_:)，这需要封闭表达式作为其单个参数的方法。封盖为阵列中的每个项目被调用一次，并返回一个替代映射值（可能的一些其他类型的），选择那些项目。映射和返回值的类型的本质是留给封闭来指定。</p>

<p>施加提供封闭每个数组元素之后，map(_:)方法返回一个包含所有的新映射值的一个新的数组，以相同的顺序与原始阵列中相应的值。</p>

<p>这里是你如何使用map(_:)方法后带上封闭的数组转换Int值到数组String值。该阵列[16, 58, 510]被用来创建新的数组[<q>OneSix</q>, <q>FiveEight</q>, <q>FiveOneZero</q>]：</p>

<p>let digitNames = [<br/>
    0: <q>Zero</q>, 1: <q>One</q>, 2: <q>Two</q>,   3: <q>Three</q>, 4: <q>Four</q>,<br/>
    5: <q>Five</q>, 6: <q>Six</q>, 7: <q>Seven</q>, 8: <q>Eight</q>, 9: <q>Nine</q><br/>
]<br/>
let numbers = [16, 58, 510]<br/>
上面的代码创建整数位，他们的名字的英文版本之间映射的字典。它还定义一个整数数组，准备将被转换成字符串。</p>

<p>现在，您可以使用numbers数组创建数组String值，通过传递闭表达阵列的map(_:)方法作为结尾结束：</p>

<p>let strings = numbers.map {<br/>
    (number) -&gt; String in<br/>
    var number = number<br/>
    var output = &quot;<q><br/>
    repeat {<br/>
        output = digitNames[number % 10]! + output<br/>
        number /= 10<br/>
    } while number &gt; 0<br/>
    return output<br/>
}<br/>
// strings is inferred to be of type [String]<br/>
// its value is [</q>OneSix<q>,</q>FiveEight<q>,</q>FiveOneZero&quot;]<br/>
该map(_:)方法为阵列中的每个项目调用一次的关闭表达。不需要指定闭合的输入参数的类型，number因为该类型可以从该数组中可以推断为被映射。</p>

<p>在本实施例中，变量number被初始化与封闭的值number参数，这样的值可以在封闭件主体内进行修改。（对函数和关闭的参数总是常数。）的封闭表达还指定的返回类型String，以指示将要存储的映射输出阵列中的类型。</p>

<p>闭合表达式生成一个名为字符串output每次调用的时间。它计算的最后一位number通过使用余运算符（number % 10），并使用该数字来查找适当的字符串中的digitNames字典。封闭件可用于创建任何大于零的整数的字符串表示。</p>

<p>注意</p>

<p>到呼叫digitNames字典的标后跟一个感叹号（!），因为字典标返回一个可选值，表明如果该键不存在，字典查找可能会失败。在上面的例子中，它是保证number % 10将总是为一个有效的标键digitNames词典等感叹号用于强制-解开的String存储在标可选的返回值的值。</p>

<p>从检索到的字符串digitNames辞典被添加到前面的output，有效地建立反向一数量的字符串版本。（表达式number % 10给出的值6对16，8对58，和0对510）。</p>

<p>的number变量然后通过分割10。因为它是一个整数，则在分裂过程中向下舍入，所以16成为1，58变得5和510变51。</p>

<p>重复该过程，直至number等于0，在该点的output字符串由封闭件返回，并加入到由输出数组map(_:)方法。</p>

<p>使用在上面的例子中尾随闭包语法的整齐该闭合支持功能之后立即封装了闭合的功能，而不需要包裹内的整个封闭map(_:)方法的外括号。</p>

<p>捕获值</p>

<p>的封闭件可以捕获从定义它的周围上下文的常量和变量。然后封闭可以参考和修改这些常数和变量的值从它的身体内，即使该定义的常量和变量的原始范围不再存在。</p>

<p>在夫特，封闭，可以捕获值的最简单的形式是一个嵌套函数，另一个函数的主体内写入。嵌套函数可以捕获它的任何外部函数的参数，也可以捕捉到外部函数中定义的任何常量和变量。</p>

<p>这里有一个调用的函数的例子makeIncrementer，它包含称为嵌套函数incrementer。嵌套incrementer()函数捕获两个值，runningTotal并且amount从它的周围环境。在捕捉到这些值之后，incrementer被返回makeIncrementer的递增封闭runningTotal由amount每次调用的时间。</p>

<p>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br/>
    var runningTotal = 0<br/>
    func incrementer() -&gt; Int {<br/>
        runningTotal += amount<br/>
        return runningTotal<br/>
    }<br/>
    return incrementer<br/>
}<br/>
的返回类型makeIncrementer为() -&gt; Int。这意味着，它返回一个函数，而不是简单的值。它返回该函数没有参数，并返回一个Int每次调用时间值。要了解函数如何返回等功能，看看函数类型的返回类型。</p>

<p>该makeIncrementer(forIncrement:)函数定义称为整型变量runningTotal，保存当前运行总计将返回增量的。这个变量被初始化为一个值0。</p>

<p>该makeIncrementer(forIncrement:)函数具有单个Int带的参数label参数forIncrement，和参数名称amount。传递给该参数的参数值指定多少runningTotal应各自返回的增量函数调用时被递增。该makeIncrementer函数定义称为嵌套函数incrementer，它执行的实际递增。此功能只是增加了amount到runningTotal，并返回结果。</p>

<p>如果孤立地考虑，嵌套incrementer()函数看起来不寻常的：</p>

<p>func incrementer() -&gt; Int {<br/>
    runningTotal += amount<br/>
    return runningTotal<br/>
}<br/>
该incrementer()函数不具有任何参数，但它是指runningTotal和amount其函数体内。它通过捕获执行此引用，以runningTotal及amount从周围的功能和它自己的功能主体内使用它们。通过引用捕获确保runningTotal和amount不时消失调用makeIncrementer端部，并且还可以确保runningTotal可在下一次incrementer函数被调用。</p>

<p>注意</p>

<p>作为优化，夫特可替代捕获并存储一个拷贝的值，如果该值没有被封闭突变，并且如果在创建关闭后的值不被突变。</p>

<p>斯威夫特也处理涉及不再需要它们时的变量处理所有的内存管理。</p>

<p>下面是一个例子makeIncrementer在行动：</p>

<p>let incrementByTen = makeIncrementer(forIncrement: 10)<br/>
此示例设置一个称为恒incrementByTen指代增加了一个增量的功能10它runningTotal每次调用时间变量。调用函数多次显示了这种行为的行动：</p>

<p>incrementByTen()<br/>
// returns a value of 10<br/>
incrementByTen()<br/>
// returns a value of 20<br/>
incrementByTen()<br/>
// returns a value of 30<br/>
如果你创建第二个增量，它会有自己的存储引用到一个新的，独立的runningTotal变量：</p>

<p>let incrementBySeven = makeIncrementer(forIncrement: 7)<br/>
incrementBySeven()<br/>
// returns a value of 7<br/>
调用原始增量（incrementByTen）再次继续递增其自己的runningTotal变量，并且不影响被捕获的变量incrementBySeven：</p>

<p>incrementByTen()<br/>
// returns a value of 40<br/>
注意</p>

<p>如果您分配一个封闭的类实例的属性，并关闭参照实例或它的成员捕获实例，您将创建关闭和实例之间有很强的参考周期。雨燕采用捕获列表来打破这些有力的参考周期。欲了解更多信息，请参阅闭包强大的参考周期。</p>

<p>闭包是引用类型</p>

<p>在上面的例子中，incrementBySeven和incrementByTen是常数，但这些常数指的是封闭件仍然能够递增runningTotal，他们已经拍摄的变量。这是因为功能和闭包是引用类型。</p>

<p>每当你分配一个函数或封闭常量或变量，你实际上是设置了固定或可变做个参考的功能或关闭。在上面的例子中，它是闭合的，该选择是指那是恒定的，而不是封闭本身的内容。 incrementByTen</p>

<p>这也意味着，如果分配封闭到两个不同的常数或变量，这两个常数或变量的将引用相同的封闭件：</p>

<p>let alsoIncrementByTen = incrementByTen<br/>
alsoIncrementByTen()<br/>
// returns a value of 50<br/>
逃离瓶盖</p>

<p>闭包据说逃跑时关闭作为参数传递给函数，但在函数返回之后被调用的函数。当你声明一个函数，闭包作为它的一个参数，你可以写@escaping参数的类型之前，表明封闭允许逃跑。</p>

<p>一个封闭件可以逃避的一种方式是通过存储在被定义在函数外的变量。作为一个例子，即启动异步操作的许多功能需要关闭参数作为完成处理。它开始运行后，但关闭不叫，直到操作完成后，关闭需要逃跑，稍后调用的函数返回。例如：</p>

<p>var completionHandlers: [() -&gt; Void] = []<br/>
func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {<br/>
    completionHandlers.append(completionHandler)<br/>
}<br/>
该someFunctionWithEscapingClosure(_:)功能需要一个封闭作为参数，并将其添加到的函数外声明的数组。如果您没有标注这个函数的参数@escaping，你会得到一个编译错误。</p>

<p>标记与封闭@escaping意味着你必须参考self封闭内显式。例如，在下面的代码，传递给封闭件someFunctionWithEscapingClosure(<u>:)是一个逸出闭合，这意味着它需要引用self明确。相比之下，传递给closure someFunctionWithNonescapingClosure(</u>:)是一个封闭nonescaping，这意味着它可以参考self隐式。</p>

<p>func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {<br/>
    closure()<br/>
}</p>

<p>class SomeClass {<br/>
    var x = 10<br/>
    func doSomething() {<br/>
        someFunctionWithEscapingClosure { self.x = 100 }<br/>
        someFunctionWithNonescapingClosure { x = 200 }<br/>
    }<br/>
}</p>

<p>let instance = SomeClass()<br/>
instance.doSomething()<br/>
print(instance.x)<br/>
// Prints <q>200</q></p>

<p>completionHandlers.first?()<br/>
print(instance.x)<br/>
// Prints <q>100</q><br/>
Autoclosures</p>

<p>一个autoclosure是自动创建的包装是被公司作为参数传递给函数的表达式关闭。它不带任何参数，当它的名字，它返回的包裹在其内部的表达式的值。这种语法上的方便，您可以通过编写一个正常的表达，而不是一个明确的封闭省略围绕一个函数的参数括号。</p>

<p>这是常见的来电称取autoclosures的功能，但它不是常见的实现那种功能。例如，该assert(condition:message:file:line:)函数接受为其一个autoclosure condition和message参数; 它condition仅在调试参数进行评估，并建立其message只有在参数进行评估condition是false。</p>

<p>一个autoclosure可延迟评价，因为里面的代码不运行，直到您调用关闭。延迟评价是有副作用或耗费计算代码有用，因为它可以让时的代码评估你控制。下面的代码显示了一个闭合延迟如何评价。</p>

<p>var customersInLine = [<q>Chris</q>, <q>Alex</q>, <q>Ewa</q>, <q>Barry</q>, <q>Daniella</q>]<br/>
print(customersInLine.count)<br/>
// Prints <q>5</q></p>

<p>let customerProvider = { customersInLine.remove(at: 0) }<br/>
print(customersInLine.count)<br/>
// Prints <q>5</q></p>

<p>print(<q>Now serving (customerProvider())!</q>)<br/>
// Prints <q>Now serving Chris!</q><br/>
print(customersInLine.count)<br/>
// Prints <q>4</q><br/>
即使第一个元素customersInLine阵列由封闭件内的代码移除，数组元素没有被去掉，直到封闭件被实际调用。如果封闭件没有被调用，封闭内的表达不会求，这意味着该数组元素永远不会被删除。需要注意的是的类型customerProvider是不String但() -&gt; String没有参数返回字符串-a功能。</p>

<p>当你通过一个封闭作为参数传递给函数，你得到延误的评价相同的行为。</p>

<p>// customersInLine is [<q>Alex</q>, <q>Ewa</q>, <q>Barry</q>, <q>Daniella</q>]<br/>
func serve(customer customerProvider: () -&gt; String) {<br/>
    print(<q>Now serving (customerProvider())!</q>)<br/>
}<br/>
serve(customer: { customersInLine.remove(at: 0) } )<br/>
// Prints <q>Now serving Alex!</q><br/>
在serve(customer:)以上列表功能需要一个明确的闭包返回客户的名称。的版本serve(customer:)低于执行相同的操作，但，而不是采取明确的封闭，它通过标记它的参数的同类型采用一个autoclosure @autoclosure属性。现在，您可以调用该函数，就好像它花了String论证，而不是封闭的。该参数被自动转换为封闭的，因为customerProvider参数的类型标有@autoclosure属性。</p>

<p>// customersInLine is [<q>Ewa</q>, <q>Barry</q>, <q>Daniella</q>]<br/>
func serve(customer customerProvider: @autoclosure () -&gt; String) {<br/>
    print(<q>Now serving (customerProvider())!</q>)<br/>
}<br/>
serve(customer: customersInLine.remove(at: 0))<br/>
// Prints <q>Now serving Ewa!</q><br/>
注意</p>

<p>过度使用autoclosures可以使代码难以理解。上下文和函数的名称应明确该评估被推迟。</p>

<p>如果你想被允许离开，同时使用一个autoclosure @autoclosure和@escaping属性。该@escaping属性是在上述避灾瓶盖。</p>

<p>// customersInLine is [<q>Barry</q>, <q>Daniella</q>]<br/>
var customerProviders: [() -&gt; String] = []<br/>
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {<br/>
    customerProviders.append(customerProvider)<br/>
}<br/>
collectCustomerProviders(customersInLine.remove(at: 0))<br/>
collectCustomerProviders(customersInLine.remove(at: 0))</p>

<p>print(<q>Collected (customerProviders.count) closures.</q>)<br/>
// Prints <q>Collected 2 closures.</q><br/>
for customerProvider in customerProviders {<br/>
    print(<q>Now serving (customerProvider())!</q>)<br/>
}<br/>
// Prints <q>Now serving Barry!</q><br/>
// Prints <q>Now serving Daniella!</q><br/>
在上面的代码中，而不调用传递给它的封闭customerProvider参数，collectCustomerProviders(_:)函数将关闭到customerProviders阵列。该阵列的功能，这意味着阵列中的封闭件可以在函数返回之后执行的范围之外声明。其结果是，该值customerProvider参数必须允许离开函数的范围。</p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743597582027.html"  title="Previous Post: 功能">&laquo; 功能</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743597933965.html" 
	        title="Next Post: 枚举">枚举 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743597798199.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
