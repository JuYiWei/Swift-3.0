<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  基础知识 待 - Swift 3.0 官方文档 自整理 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 官方文档 自整理 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 官方文档 自整理 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 官方文档 自整理 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识 待" href="14743596331025.html">基础知识 待</a></li>
          
            <li><a title="基础运算操作 待" href="14743596434163.html">基础运算操作 待</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="控制流" href="14743597355186.html">控制流</a></li>
          
            <li><a title="函数" href="14743597582027.html">函数</a></li>
          
            <li><a title="闭包" href="14743597798199.html">闭包</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743598083496.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标" href="14743598556978.html">下标</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="初始化" href="14743599314901.html">初始化</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识 待" href="14743596331025.html">基础知识 待</a></li>
                        
                          <li><a title="基础运算操作 待" href="14743596434163.html">基础运算操作 待</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="控制流" href="14743597355186.html">控制流</a></li>
                        
                          <li><a title="函数" href="14743597582027.html">函数</a></li>
                        
                          <li><a title="闭包" href="14743597798199.html">闭包</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743598083496.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标" href="14743598556978.html">下标</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="初始化" href="14743599314901.html">初始化</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>基础知识 待</h1>

<ul>
<li>
<a href="#toc_0">简介</a>
</li>
<li>
<a href="#toc_1">常量和变量</a>
<ul>
<li>
<a href="#toc_2">声明常量和变量</a>
</li>
<li>
<a href="#toc_3">类型标识</a>
</li>
<li>
<a href="#toc_4">命名常量和变量</a>
</li>
<li>
<a href="#toc_5">印刷常量和变量</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">注释</a>
</li>
<li>
<a href="#toc_7">分号</a>
</li>
<li>
<a href="#toc_8">整数</a>
<ul>
<li>
<a href="#toc_9">整数边界</a>
</li>
<li>
<a href="#toc_10">INT</a>
</li>
<li>
<a href="#toc_11">UINT</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">浮点数</a>
</li>
<li>
<a href="#toc_13">类型安全和类型推断</a>
</li>
<li>
<a href="#toc_14">数值表示</a>
</li>
<li>
<a href="#toc_15">数值类型转换</a>
<ul>
<li>
<a href="#toc_16">整型转换</a>
</li>
<li>
<a href="#toc_17">整数和浮点转换</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">类型别名</a>
</li>
<li>
<a href="#toc_19">布尔值</a>
</li>
<li>
<a href="#toc_20">元组</a>
</li>
<li>
<a href="#toc_21">可选类型</a>
<ul>
<li>
<a href="#toc_22">nil</a>
</li>
<li>
<a href="#toc_23">if语句，强制解析</a>
</li>
<li>
<a href="#toc_24">可选绑定</a>
</li>
<li>
<a href="#toc_25">可选类型隐式解析</a>
</li>
</ul>
</li>
<li>
<a href="#toc_26">错误处理</a>
</li>
<li>
<a href="#toc_27">断言</a>
<ul>
<li>
<a href="#toc_28">调试使用断言</a>
</li>
<li>
<a href="#toc_29">何时使用断言</a>
</li>
</ul>
</li>
</ul>


<h1 id="toc_0">简介</h1>

<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">The Basics 官方文档</a></p>

<ul>
<li><p>Swift是一个新的编程语言，适用于iOS，macOS，watchOS和tvOS应用开发。尽管如此，基于你的C和Objective-C开发的经验，Swift的许多地方将会非常熟悉。</p></li>
<li><p>Swift提供了所有C和Objective-C基本类型，包括整数Int，浮点数Double和Float，布尔值Bool，字符串String。Swift还提供了三个主要集合类型，Array，Set，和Dictionary。</p></li>
<li><p>像C，Swift使用标识符存储和引用变量。Swift也使得大量使用的常量，其值不能改变，功能比C更加强大。常量在整个Swift中，使代码更安全，意图更清晰。</p></li>
<li><p>除了熟悉的类型，Swift介绍了Objective-C中无法实现的高级类型，如元组，可以使用元组从一个函数返回多个值。</p></li>
<li><p>Swift还引入了可选类型，处理缺省值。可选类型不是有值就是nil，对任何类型有效。可选类型更安全，也是Swift的核心。</p></li>
<li><p>Swift是一个类型安全的语言，实时的检测代码中的类型。如果代码的需要一个String，类型安全会防止传递一个Int的错误。同样，类型安全防止意外传递一个可选的String，必须是非可选String。类型安全可以尽可能尽早的捕捉到开发过程中的错误。</p></li>
</ul>

<h1 id="toc_1">常量和变量</h1>

<p>常量和变量：常量的值恒定一旦设置不能被改变，变量可以被多册设置不同的值。</p>

<h2 id="toc_2">声明常量和变量</h2>

<ul>
<li>在使用之前，常量和变量必须声明。声明常量<code>let</code>关键字和变量<code>var</code>关键字。</li>
</ul>

<pre><code>let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
</code></pre>

<ul>
<li>可以在一行声明多个常量或多个变量，用逗号分隔：</li>
</ul>

<pre><code>var x = 0.0, y = 0.0, z = 0.0
</code></pre>

<h2 id="toc_3">类型标识</h2>

<ul>
<li>当你声明一个常量或变量，可以提供一个类型标识，也就是指定类型。</li>
</ul>

<pre><code>var welcomeMessage: String
</code></pre>

<ul>
<li>welcomeMessage变量现在可以设置为任何字符串值：</li>
</ul>

<pre><code>welcomeMessage = &quot;Hello&quot;
</code></pre>

<ul>
<li>可以定义在一行相同的类型，用逗号隔开，最后的变量名后指定类型</li>
</ul>

<pre><code>var red, green, blue: Double
</code></pre>

<ul>
<li>指定类型不是必须的，Switf可以直接对初始化的变量或常数进行类型推断，从而直接确定了类型。</li>
</ul>

<h2 id="toc_4">命名常量和变量</h2>

<ul>
<li>常量和变量名几乎可以包含任何字符，包括Unicode字符，但还是推荐正常命名规范</li>
</ul>

<pre><code>let π = 3.14159
let 你好 = &quot;你好世界&quot;
let 🐶🐮 = &quot;dogcow&quot;
</code></pre>

<ul>
<li>不允许重名</li>
<li>尽量不使用Swift保留关键字</li>
</ul>

<h2 id="toc_5">印刷常量和变量</h2>

<ul>
<li><code>print</code>打印常量或变量的当前值，支持多值，分割字符，追加字符。</li>
</ul>

<pre><code>print(friendlyWelcome)
print(1,2,3,4 ,separator: &quot;??&quot;, terminator: &quot;000&quot;)
</code></pre>

<ul>
<li>打印格式字符，<code>\()</code>包含常量或者变量</li>
</ul>

<pre><code>print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)
</code></pre>

<h1 id="toc_6">注释</h1>

<ul>
<li>类似C单行注释，以两个正斜杠<code>//</code>开始：</li>
</ul>

<pre><code>// This is a comment.
</code></pre>

<ul>
<li>多行注释以<code>/*</code>开始，并<code>*/</code>结束</li>
</ul>

<pre><code>/* This is also a comment
 but is written over multiple lines. */
</code></pre>

<ul>
<li>多行注释可以嵌套在其他多行注释。</li>
</ul>

<pre><code>/* This is the start of the first multiline comment.
 /* This is the second, nested multiline comment. */
 This is the end of the first multiline comment. */
</code></pre>

<h1 id="toc_7">分号</h1>

<p>语句不要求分号结尾。但是，如果一行上多个独立的语句需要分号分割。</p>

<pre><code>let cat = &quot;🐱&quot;; print(cat)
</code></pre>

<h1 id="toc_8">整数</h1>

<p>整数全是数字，没有小数部分，如42和-23。整数分为有符号（正，零或负的）或无符号（正或零）。<br/>
Swift在8，16，32位和64位的形式提供符号和无符号整数。<br/>
这些整数遵循类似于C的命名约定，8位的无符号整数的类型的UInt8，32位带符号整数的类型的Int32。</p>

<h2 id="toc_9">整数边界</h2>

<ul>
<li>可以获取每个整数类型的最小值和最大值<code>min</code>与<code>max</code>属性：</li>
</ul>

<pre><code>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8
</code></pre>

<h2 id="toc_10">INT</h2>

<ul>
<li>在大多数情况下，不需要选择整数的特定大小。Swift提供额外的整数类型<code>Int</code>，数据大小与当前系统有关：</li>
</ul>

<pre><code>在32位的平台上，Int其大小与相同Int32。
在64位的平台上，Int其大小与相同Int64。
</code></pre>

<ul>
<li>默认类型推断为Int，除非你需要特定大小的整数。</li>
</ul>

<h2 id="toc_11">UINT</h2>

<ul>
<li>Swift提供额外的整数类型<code>UInt</code>，数据大小与当前系统有关：</li>
</ul>

<pre><code>在32位的平台上，UInt其大小与相同UInt32。
在64位的平台上，UInt其大小与相同UInt64。
</code></pre>

<ul>
<li>默认类型推断为Int，除非你需要特定范围与大小的整数。</li>
</ul>

<h1 id="toc_12">浮点数</h1>

<ul>
<li>浮点数是具有小数部分的数字，例如3.14159，0.1，和-273.15。</li>
<li>Double 代表一个64位浮点数。</li>
<li>Float 表示32位浮点数。</li>
<li>Double具有15位的精度，Float具有6位。默认推断为Double，或者按需要选择使用。</li>
</ul>

<h1 id="toc_13">类型安全和类型推断</h1>

<ul>
<li>类型推断：定义常量或者变量，初始化赋值时，可以自动推断类型。</li>
</ul>

<pre><code>let meaningOfLife = 42 // Int
let pi = 3.14159 // Double
let anotherPi = 3 + 0.14159 // Double
</code></pre>

<ul>
<li>类型安全：检查代码赋值时前后类型是否匹配。</li>
</ul>

<pre><code>let anotherPi2 = meaningOfLife + pi // error 因为meaningOfLife是Int，而pi是Double，不能直接计算
</code></pre>

<h1 id="toc_14">数值表示</h1>

<ul>
<li>整数可以写为：</li>
</ul>

<pre><code>一个十进制数，无前缀
一个二进制数字，用0b前缀
一个八进制数，有0o前缀
一个十六进制数字，用0x前缀
</code></pre>

<ul>
<li>以下整数都表示 17</li>
</ul>

<pre><code>let decimalInteger = 17
let binaryInteger = 0b10001       
let octalInteger = 0o21           
let hexadecimalInteger = 0x11     
</code></pre>

<ul>
<li>浮点数值可以是十进制（不带前缀），或十六进制（带有0x前缀）表示。十进制可以有一个可选的指数<code>e</code>，十六进制必须有一个指数<code>p</code>。</li>
</ul>

<pre><code>1.25e2 // 1.25×10^2 = 125.0
1.25e-2 // 1.25×10^-2 = 0.0125
</code></pre>

<pre><code>0xFp2 // 15×2^2 = 60.0
0xFp-2 // 15×2^-2 = 3.75
</code></pre>

<pre><code>let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
</code></pre>

<ul>
<li>可以用额外的零填充并且可以包含下划线，以提高可读性。</li>
</ul>

<pre><code>let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>

<h1 id="toc_15">数值类型转换</h1>

<p>默认系统推断类型，整型 Int，浮点型 Double。如果有特殊需求时会指定其他类型的数值，比如UInt8，那么不同类型数值计算时就需要类型转换，注意防止溢出。</p>

<h2 id="toc_16">整型转换</h2>

<p>整数常量或变量的数值范围，根据类型不同而不同。一个Int8范围在-128和127之间，而UInt8范围是0和255之间。编译时会检查数值是否溢出，并警告。</p>

<pre><code>let cannotBeNegative: UInt8 = -1
let tooBig: Int8 = Int8.max + 1
</code></pre>

<p>下面举例，常数<code>twoThousand</code>是类型的<code>UInt16</code>，而<code>one</code>的类型的<code>UInt8</code>。它们不能直接计算，因为它们是不同。相反，调用UInt16(one)以one创建一个新的UInt16后，类型相同，可以计算了：</p>

<pre><code>let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>

<ul>
<li>SomeType(ofInitialValue)是默认的类型转换方式。在幕后，UInt16有一个接受的初始UInt8值，提供的原始类型必须是目标类型可以初始化的。</li>
</ul>

<h2 id="toc_17">整数和浮点转换</h2>

<ul>
<li>整数转浮点类型。值<code>three</code>被用来创建Double类型的新值，从而使计算两侧是相同类型的。没有这种转换，是不允许的。</li>
</ul>

<pre><code>let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
</code></pre>

<ul>
<li>浮点到整数。转换新的整数值时，浮点值始终截断。例如：4.75变4，-3.9变-3。</li>
</ul>

<pre><code>let integerPi = Int(pi)
</code></pre>

<h1 id="toc_18">类型别名</h1>

<ul>
<li>类型别名为现有类型定义的替代名称。使用<code>typealias</code>定义。一旦定义了类型别名，可以在使用别名的任何地方，使用原来的名字。</li>
</ul>

<pre><code>typealias AudioSample = UInt16
</code></pre>

<ul>
<li>这里，AudioSample定义为UInt16的别名。因为它是一个别名，调用AudioSample.min实际调用UInt16.min。</li>
</ul>

<pre><code>var maxAmplitudeFound = AudioSample.min
</code></pre>

<h1 id="toc_19">布尔值</h1>

<p>Swift有一个基本的布尔类型<code>Bool</code>。布尔值只有<code>true</code>和<code>false</code>。</p>

<pre><code>let orangesAreOrange = true
let turnipsAreDelicious = false
</code></pre>

<ul>
<li>布尔值基本用在<code>if</code>的语句中。更详细的<code>if</code>，看控制流章节。</li>
</ul>

<pre><code>if turnipsAreDelicious {
    print(&quot;Mmm, tasty turnips!&quot;)
} else {
    print(&quot;Eww, turnips are horrible.&quot;)
}
</code></pre>

<ul>
<li>Swift的类型安全防止隐性转换<code>Bool</code>，与OC不同，下面的示例编译时会报错</li>
</ul>

<pre><code>let i = 1
if i {
    // this example will not compile, and will report an error
}
</code></pre>

<ul>
<li>必须使用返回<code>Bool</code>类型的表达式</li>
</ul>

<pre><code>let i = 1
if i == 1 {
    // this example will compile successfully
}
</code></pre>

<h1 id="toc_20">元组</h1>

<ul>
<li>元组是多个值组成的复合值。元组中的值可以是任何类型，并且允许不同类型的组合。下面的例子，描述为“元组类型(Int, String)”</li>
</ul>

<pre><code>let http404Error = (404, &quot;Not Found&quot;)
</code></pre>

<ul>
<li>分解一个元组内容到单独的常量或变量，像往常一样访问，类似字典</li>
</ul>

<pre><code>let (statusCode, statusMessage) = http404Error
print(&quot;The status code is \(statusCode)&quot;)
print(&quot;The status message is \(statusMessage)&quot;)
</code></pre>

<ul>
<li>如果只需要一些元组的值，忽略元组的部分用下划线<code>_</code>表示</li>
</ul>

<pre><code>let (justTheStatusCode, _) = http404Error
print(&quot;The status code is \(justTheStatusCode)&quot;)
</code></pre>

<ul>
<li>另外，从零开始索引访问元组的各个元素值，类似数组</li>
</ul>

<pre><code>print(&quot;The status code is \(http404Error.0)&quot;)
print(&quot;The status message is \(http404Error.1)&quot;)
</code></pre>

<ul>
<li>定义元组时，可以给元组的各个元素命名</li>
</ul>

<pre><code>let http200Status = (statusCode: 200, description: &quot;OK&quot;)
</code></pre>

<ul>
<li>如果元组元素有命名，可以使用元素名称来访问这些元素的值</li>
</ul>

<pre><code>print(&quot;The status code is \(http200Status.statusCode)&quot;)
print(&quot;The status message is \(http200Status.description)&quot;)
</code></pre>

<ul>
<li>元组是作为函数的返回值特别有用，更多信息，请参阅多返回函数。</li>
<li>元组不适合于创建复杂的数据结构。更多信息，请参见类和结构。</li>
</ul>

<h1 id="toc_21">可选类型</h1>

<ul>
<li><p>可选类型代表两种可能：要么是一个值可以解析，要么没有值为<code>nil</code>。</p></li>
<li><p>OC不存在可选类型，只能判断对象是否存在，对于基本数据类型使用特殊值来判断，例如<code>NSNotFound</code>。Swift的可选类型，支持所以数据类型的判断。</p></li>
<li><p>下面举例可选类型，如何用来对付不存在的值。Swift的String类型的值尝试转换为Int数值。然而，不是每个字符串都可以转换成一个整数。字符串<q>123</q>可以被转换成数值123，但该字符串<q>hello, world</q>不具有明显的数字值转换行为。</p></li>
</ul>

<pre><code>let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber)
</code></pre>

<ul>
<li>由于初始化<code>convertedNumber</code>可能会失败，它返回可选的<code>Int</code>，而不是<code>Int</code>。可选<code>Int</code>被写为<code>Int?</code>，不是<code>Int</code>。问号表明它包含的值是可选的，这意味着它可能包含<code>Int</code>值，或者是<code>nil</code>。可以通过<code>if</code>语句来判断。</li>
</ul>

<h2 id="toc_22">nil</h2>

<ul>
<li>可选变量可以设置成<code>nil</code>,表示不存在任何值。非可选变量不能使用<code>nil</code>。</li>
</ul>

<pre><code>var serverResponseCode: Int? = 404
serverResponseCode = nil
</code></pre>

<ul>
<li>如果可选的变量没有提供初始化值，该变量将自动设置为nil。</li>
</ul>

<pre><code>var surveyAnswer: String?
</code></pre>

<h2 id="toc_23">if语句，强制解析</h2>

<ul>
<li>使用if语句直接与<code>nil</code>比较。如果有值，那么<code>!=nil</code>为真。</li>
</ul>

<pre><code>if convertedNumber != nil {
    print(&quot;convertedNumber contains some integer value.&quot;)
}
</code></pre>

<ul>
<li>确定可选确实包含一个值，可以通过<code>!</code>，强制解析其值。</li>
</ul>

<pre><code>if convertedNumber != nil {
    print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)
}
</code></pre>

<ul>
<li>更多有关if语句，请参阅控制流。</li>
<li>试图用<code>!</code>访问不存在的可选值时会触发运行时错误。需要确保可选类型包含非nil值才使用<code>!</code>解开它的值。</li>
</ul>

<h2 id="toc_24">可选绑定</h2>

<p>使用可选类型值初始化其他变量或常量是，该表达式语句可以看做是Bool类型(但不真的是Bool类型)，因此可以使用<code>if</code>语句判断。也就是可选类型为nil时，初始化就失败，反之成功，并且该值可以在内部使用。</p>

<pre><code>if let constantName = someOptional {
    statements
}
</code></pre>

<ul>
<li>可以使用上面<code>possibleNumber</code>可选类型的例子，继续使用可选绑定，而不是强制解析。</li>
</ul>

<pre><code>if let actualNumber = Int(possibleNumber) {
    print(&quot;\&quot;\(possibleNumber)\&quot; has an integer value of \(actualNumber)&quot;)
} else {
    print(&quot;\&quot;\(possibleNumber)\&quot; could not be converted to an integer&quot;)
}
</code></pre>

<ul>
<li>如果可选Int(possibleNumber)包含一个值，那么设置一个新常数actualNumber包含可选类型的值。</li>
<li>如果转换成功，则actualNumber常数，可在if语句第一分支中使用。它已经被初始化为可选类型的值，因此没有必要使用!来解析。</li>
<li><p>常量和变量都可以用作可选的绑定。</p></li>
<li><p>可以在一个if中，混合使用多个可寻绑定，以及Bool条件，但是需要逗号分隔，作用与<code>&amp;&amp;</code>一致。</p></li>
</ul>

<pre><code>if let firstNumber = Int(&quot;4&quot;), let secondNumber = Int(&quot;42&quot;), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {
    print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)
}
 
// 与上面的效果一致
if let firstNumber = Int(&quot;4&quot;) {
    if let secondNumber = Int(&quot;42&quot;) {
        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {
            print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)
        }
    }
}
</code></pre>

<h2 id="toc_25">可选类型隐式解析</h2>

<ul>
<li>有时程序的结构清楚，可选类型明确是一个值，可以假定为有值来处理，隐式解析可选类型，直接使用其值。</li>
<li>使用<code>!</code>对可选类型，隐式解析。</li>
</ul>

<pre><code>let possibleString: String? = &quot;An optional string.&quot;
let forcedString: String = possibleString! 
</code></pre>

<ul>
<li>也可以直接指定类型为隐式解析类</li>
</ul>

<pre><code>let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;
let implicitString: String = assumedString
</code></pre>

<ul>
<li><p>如果一个隐式解析可选的是nil，直接使用其值时，会触发运行时错误。注意要明确有值时，才隐式解析，不然还是用可选绑定吧。</p></li>
<li><p>隐式解析可选类型本质还是可选类型，任然可以使用<code>!=nil</code>去强制解析，以及可选绑定。</p></li>
</ul>

<pre><code>if assumedString != nil {
    print(assumedString)
}
</code></pre>

<pre><code>if let definiteString = assumedString {
    print(definiteString)
}
</code></pre>

<h1 id="toc_26">错误处理</h1>

<ul>
<li>当函数遇执行时到错误，抛出一个错误。然后，调用该函数者可以抓取的错误，并作出适当的处理。</li>
</ul>

<pre><code>func canThrowAnError() throws {
    // this function may or may not throw an error
}
</code></pre>

<ul>
<li>函数通过<code>throws</code>表明它可以抛出错误，函数前面加上<code>try</code>关键字，表示该函数可以抛出错误，并使用<code>catch</code>捕获错误。</li>
</ul>

<pre><code>do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}
</code></pre>

<ul>
<li><code>do</code>语句创建范围，允许误差传播到一个或多个<code>catch</code>。</li>
</ul>

<pre><code>func makeASandwich() throws {
    // ...
}
 
do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
</code></pre>

<ul>
<li>在这个例子中，<code>makeASandwich()</code>如果没有干净的碗可用，或者丢失将抛出异常。由于<code>makeASandwich()</code>可以抛出异常，函数调用使用<code>try</code>，并包装在<code>do</code>语句中，任何被抛出的异常都会被<code>catch</code>捕获。</li>
<li><p>如果没有抛出异常，<code>eatASandwich()</code>被调用。如果抛出异常，与之的匹配<code>SandwichError.outOfCleanDishes</code>情况，则<code>washDishes()</code>被调用。匹配<code>SandwichError.missingIngredients</code>情况，则<code>buyGroceries(_:)</code>被调用。</p></li>
<li><p>更多有关错误处理，请参阅错误处理。</p></li>
</ul>

<h1 id="toc_27">断言</h1>

<p>在某些情况下，根本不可能或者不允许的，可以触发一个断言，并结束代码执行，提供调试信息以修改。</p>

<h2 id="toc_28">调试使用断言</h2>

<ul>
<li>断言是一种运行时检查，布尔为true。也就是说条件不符合，那么就中断执行，如果符合条件，则继续执行。</li>
<li>在调试环境，触发了一次断言，可以看到异常的确切位置，相当于进入了断电调试状态。</li>
</ul>

<pre><code>let age = -3
assert(age &gt;= 0, &quot;A person&#39;s age cannot be less than zero&quot;)
</code></pre>

<ul>
<li><p>age &gt;=0 时，代码正常运行，反之此处断点。</p></li>
<li><p>如果需要，可以省略断言消息。</p></li>
</ul>

<pre><code>assert(age &gt;= 0)
</code></pre>

<ul>
<li>代码会被编译优化，发布配置是默认断言无效。</li>
</ul>

<h2 id="toc_29">何时使用断言</h2>

<ul>
<li><p>断言检查合适的方案包括：1）索引越界。2）无效值传递函数。3）等</p></li>
<li><p>断言导致应用程序终止，提供比较不错的调试环境。断言，确保这些必要条件在开发过程中突出显示。</p></li>
</ul>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743602864403.html"  title="Previous Post: 语法摘要">&laquo; 语法摘要</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743596434163.html" 
	        title="Next Post: 基础运算操作 待">基础运算操作 待 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743596331025.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
