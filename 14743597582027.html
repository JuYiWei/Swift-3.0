<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  功能 - Swift 3.0 官方文档 自整理 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 官方文档 自整理 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 官方文档 自整理 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 官方文档 自整理 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
          
            <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="功能" href="14743597582027.html">功能</a></li>
          
            <li><a title="关闭" href="14743597798199.html">关闭</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标" href="14743598556978.html">下标</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="初始化" href="14743599314901.html">初始化</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
                        
                          <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="功能" href="14743597582027.html">功能</a></li>
                        
                          <li><a title="关闭" href="14743597798199.html">关闭</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标" href="14743598556978.html">下标</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="初始化" href="14743599314901.html">初始化</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>功能</h1>

<p>功能是码自包含块执行特定的任务。你给一个函数的名称，标识它做什么，而这个名字是用来“呼叫”功能在需要时执行任务。</p>

<p>斯威夫特的统一函数的语法具有足够的灵活性来表达无参数的名称从一个简单的C风格的函数的任何一个复杂的Objective-C风格的方法，名称和参数标签，每个参数。参数可以提供默认值，以简化的函数调用，并且可以作为在出参数，一旦功能已经完成其执行该修改传递变量来传递。</p>

<p>在斯威夫特每个函数都有一个类型，包括函数的参数类型和返回类型。您可以使用此类型的像雨燕任何其他类型的，这使得它容易通过功能参数等功能，并从函数返回的功能。函数也可以在其他函数中写入一个嵌套函数范围内封装有用的功能。</p>

<p>定义和调用函数</p>

<p>当你定义一个函数，你可以随意定义一个或多个命名的类型值的函数作为输入，称为参数。还可以任选地定义的类型的值，当它完成，被称为它的功能会传回作为输出返回类型。</p>

<p>每个函数都有一个函数名，它描述了功能执行的任务。要使用的功能，你“呼”，其名称的功能，并将它传递的输入值（称为参数）相匹配的类型函数的参数这一点。函数的参数必须始终以相同的顺序作为函数的参数列表来提供。</p>

<p>在下面的例子中的函数被调用greet(person:)，因为这是它做什么，它需要一个人的名字作为输入，并返回一个问候的那个人。要做到这一点，您可以定义一个输入参数，一个String所谓价值person-和返回类型String，其中将包含该人的问候：</p>

<p>func greet(person: String) -&gt; String {<br/>
    let greeting = <q>Hello,</q> + person + <q>!</q><br/>
    return greeting<br/>
}<br/>
所有这些信息都汇总到函数的定义，这是前缀的func关键字。你指示函数与返回类型返回箭头 -&gt;（连字符接着一个直角括号），随后是返回类型的名称。</p>

<p>该定义描述函数做什么，它希望接收，当它完成它返回什么。该定义便于明确地从代码中的其他地方调用的函数：</p>

<p>print(greet(person: <q>Anna</q>))<br/>
// Prints <q>Hello, Anna!</q><br/>
print(greet(person: <q>Brian</q>))<br/>
// Prints <q>Hello, Brian!</q><br/>
您调用greet(person:)传递它的函数String值后，person参数标签，如greet(person: <q>Anna</q>)。由于该函数返回一个String值，greet(person:)可以被包裹到一个呼叫print(_:separator:terminator:)功能打印该字符串，看看它的返回值，如上图所示。</p>

<p>注意</p>

<p>该print(_:separator:terminator:)功能并没有为它的第一个参数的标签，和它的其他参数是可选的，因为他们有一个默认值。关于函数的语法，这些变化将在下面讨论函数参数标签和参数名和默认参数值。</p>

<p>在身体greet(person:)机能开始通过定义一个新的String称为恒greeting并将其设置为一个简单的问候语。然后，这个问候语传回了使用功能的return关键字。在的代码，指出该行return greeting，函数完成它的执行，并返回的当前值greeting。</p>

<p>您可以调用greet(person:)多次函数不同的输入值。上面的例子表明，如果它被调用的输入值发生了什么<q>Anna</q>，以及输入值<q>Brian</q>。该函数返回在每种情况下定制的问候语。</p>

<p>为了使这个功能更短的身体，你可以结合消息创建和return语句成一行：</p>

<p>func greetAgain(person: String) -&gt; String {<br/>
    return <q>Hello again,</q> + person + <q>!</q><br/>
}<br/>
print(greetAgain(person: <q>Anna</q>))<br/>
// Prints <q>Hello again, Anna!</q><br/>
功能参数和返回值</p>

<p>功能参数和返回值是斯威夫特非常灵活。你可以用一个未命名的参数与表现力的参数名称和不同的参数选项的复变函数定义从一个简单的效用函数什么。</p>

<p>不带参数的函数</p>

<p>功能不要求定义的输入参数。这里是不带输入参数，它总是返回相同的函数String，只要它被称为消息：</p>

<p>func sayHelloWorld() -&gt; String {<br/>
    return <q>hello, world</q><br/>
}<br/>
print(sayHelloWorld())<br/>
// Prints <q>hello, world</q><br/>
该函数名后的函数定义还需要括号，即使它不带任何参数。函数名称也跟着一对空括号当函数被调用。</p>

<p>功能多参量</p>

<p>函数可以有多个输入参数，这些参数的函数的括号，用逗号分隔内写入。</p>

<p>这个函数有一个人的名字，以及他们是否已经迎来作为输入，并返回该人一种合适的问候：</p>

<p>func greet(person: String, alreadyGreeted: Bool) -&gt; String {<br/>
    if alreadyGreeted {<br/>
        return greetAgain(person: person)<br/>
    } else {<br/>
        return greet(person: person)<br/>
    }<br/>
}<br/>
print(greet(person: <q>Tim</q>, alreadyGreeted: true))<br/>
// Prints <q>Hello again, Tim!</q><br/>
您调用greet(person:alreadyGreeted:)传递它既有功能String标记参数值person和Bool标记参数值alreadyGreeted在括号，用逗号隔开。注意，这个功能是从不同的greet(person:)在前面的部分中显示的功能。虽然这两个功能都与名称开头greet的greet(person:alreadyGreeted:)函数有两个参数，但greet(person:)功能只之一。</p>

<p>如果没有返回值的函数</p>

<p>功能不要求定义的返回类型。这里的一个版本greet(person:)功能，打印了自己的String价值，而不是返回它：</p>

<p>func greet(person: String) {<br/>
    print(<q>Hello, (person)!</q>)<br/>
}<br/>
greet(person: <q>Dave</q>)<br/>
// Prints <q>Hello, Dave!</q><br/>
因为它不需要返回值，函数的定义不包括返回箭头（-&gt;）或返回类型。</p>

<p>注意</p>

<p>严格地说，这个版本的greet(person:)功能确实还是返回一个值，即使没有返回值的定义。没有定义返回类型函数返回类型的特殊价值Void。这简直是一个空的元组，这是写作()。</p>

<p>函数的返回值可以被调用时被忽略：</p>

<p>func printAndCount(string: String) -&gt; Int {<br/>
    print(string)<br/>
    return string.characters.count<br/>
}<br/>
func printWithoutCounting(string: String) {<br/>
    let _ = printAndCount(string: string)<br/>
}<br/>
printAndCount(string: <q>hello, world</q>)<br/>
// prints <q>hello, world</q> and returns a value of 12<br/>
printWithoutCounting(string: <q>hello, world</q>)<br/>
// prints <q>hello, world</q> but does not return a value<br/>
第一个函数printAndCount(string:)，打印一个字符串，然后返回其字符数为Int。第二个函数printWithoutCounting(string:)，调用第一个功能，而忽略它的返回值。当第二函数被调用，该消息仍然由第一功能打印，但不使用返回的值。</p>

<p>注意</p>

<p>返回值可以忽略不计，但表示将返回一个值必须始终做到的功能。具有定义返回类型的函数不能让控制跌出功能的底部不返回值，并试图这样做会导致编译时错误。</p>

<p>具有多个返回值的函数</p>

<p>你可以使用一个元组类型的返回类型的函数返回多个值为一体的复合回报价值的一部分。</p>

<p>下面的例子定义了一个调用的函数minMax(array:)，它发现在数组中最小和最大的数字Int值：</p>

<p>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {<br/>
    var currentMin = array[0]<br/>
    var currentMax = array[0]<br/>
    for value in array[1..<array.count] {<br/>
        if value < currentMin {<br/>
            currentMin = value<br/>
        } else if value > currentMax {<br/>
            currentMax = value<br/>
        }<br/>
    }<br/>
    return (currentMin, currentMax)<br/>
}<br/>
该minMax(array:)函数返回一个包含两个元组Int值。这些值标示min并max使得它们可以通过名称查询函数的返回值时进行访问。</p>

<p>所述的本体minMax(array:)功能开始通过设置两个工作变量调用currentMin和currentMax对阵列中的第一个整数的值。该函数然后在阵列和检查中的每个值的剩余的值迭代以确定它是否是比的值较小或较大currentMin和currentMax分别。最后，整体最小值和最大值返回为两个的元组Int值。</p>

<p>因为元组的部件值被命名为函数的返回类型的组成部分，它们可以与点语法来访问以检索的最小和最大发现值：</p>

<p>let bounds = minMax(array: [8, -6, 2, 109, 3, 71])<br/>
print(<q>min is (bounds.min) and max is (bounds.max)</q>)<br/>
// Prints <q>min is -6 and max is 109</q><br/>
请注意，元组的成员并不需要的元组是从函数返回的点被命名，因为他们的名字已经被指定为函数的返回类型的一部分​​。</p>

<p>可选的元组返回类型</p>

<p>如果是从一个函数返回的元组类型必须对整个元组“没有价值”的潜力，你可以使用一个可选的元组返回类型，以反映一个事实，即整个数组即可nil。您可以通过放置一个问号元组类型的右括号后，如写一个可选的元组返回类型(Int, Int)?或(String, Int, Bool)?。</p>

<p>注意</p>

<p>如可选元组类型(Int, Int)?是从包含任选的类型，例如元组不同(Int?, Int?)。与可选的元组类型，整个元组是可选的，而不是仅仅每个单独的元组内的值。</p>

<p>在minMax(array:)上面的函数返回一个包含两个元组Int值。不过，该函数不它传递阵列上执行任何安全检查。如果该array参数包含一个空的阵列，所述minMax(array:)的功能，如以上所定义，将试图访问时触发运行时错误array[0]。</p>

<p>为了安全地处理空数组，写minMax(array:)一个可选的元组返回类型的功能和返回值nil当数组为空：</p>

<p>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {<br/>
    if array.isEmpty { return nil }<br/>
    var currentMin = array[0]<br/>
    var currentMax = array[0]<br/>
    for value in array[1..<array.count] {<br/>
        if value < currentMin {<br/>
            currentMin = value<br/>
        } else if value > currentMax {<br/>
            currentMax = value<br/>
        }<br/>
    }<br/>
    return (currentMin, currentMax)<br/>
}<br/>
您可以使用可选的绑定来检查此版本是否minMax(array:)函数返回一个元组的实际值或nil：</p>

<p>if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {<br/>
    print(<q>min is (bounds.min) and max is (bounds.max)</q>)<br/>
}<br/>
// Prints <q>min is -6 and max is 109</q><br/>
函数参数标签和参数名称</p>

<p>每个功能参数既具有论点标签和参数名称。调用函数时的参数标签使用; 每个参数写在它面前它的参数标签的函数调用。参数名称在函数的实现中。默认情况下，参数用它们的参数名称作为它们的参数标签。</p>

<p>func someFunction(firstParameterName: Int, secondParameterName: Int) {<br/>
    // In the function body, firstParameterName and secondParameterName<br/>
    // refer to the argument values for the first and second parameters.<br/>
}<br/>
someFunction(firstParameterName: 1, secondParameterName: 2)<br/>
所有参数都必须具有唯一的名称。虽然有可能为多个参数具有相同的参数的标签，独特的参数标签有助于使你的代码更易读。</p>

<p>指定参数标签</p>

<p>你写的参数名称前一个参数的标签，用空格分隔：</p>

<p>func someFunction(argumentLabel parameterName: Int) {<br/>
    // In the function body, parameterName refers to the argument value<br/>
    // for that parameter.<br/>
}<br/>
这里的的变化greet(person:)，需要一个人的名字和家乡，并返回一个问候的功能：</p>

<p>func greet(person: String, from hometown: String) -&gt; String {<br/>
    return <q>Hello (person)!  Glad you could visit from (hometown).</q><br/>
}<br/>
print(greet(person: <q>Bill</q>, from: <q>Cupertino</q>))<br/>
// Prints <q>Hello Bill!  Glad you could visit from Cupertino.</q><br/>
使用参数标签可以让一个函数在表现力，句子样的方式被调用，同时还提供了一个函数体是可读的和明确的意图。</p>

<p>省略参数标签</p>

<p>如果你不想要一个参数一个参数的标签，写一个下划线（_），而不是该参数的一个明确的说法标签。</p>

<p>func someFunction(_ firstParameterName: Int, secondParameterName: Int) {<br/>
    // In the function body, firstParameterName and secondParameterName<br/>
    // refer to the argument values for the first and second parameters.<br/>
}<br/>
someFunction(1, secondParameterName: 2)<br/>
如果一个参数有一个参数标签，参数必须在调用函数进行标注。</p>

<p>默认参数值</p>

<p>您可以定义一个默认值由该参数的类型后分配值参数在函数的任何参数。如果默认值定义，你可以调用函数时省略该参数。</p>

<p>func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {<br/>
    // If you omit the second argument when calling this function, then<br/>
    // the value of parameterWithDefault is 12 inside the function body.<br/>
}<br/>
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6<br/>
someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12<br/>
有在函数的参数列表的开头不默认值，有默认值参数前广场参数。不具有默认值的参数，通常是对功能的更重要意义的写入第一它们可以更容易地认识到，同样的功能正在被呼叫，而不管是否省略任何默认参数。</p>

<p>可变参数的参数</p>

<p>一个可变参数的参数接受指定类型的零个或多个值。您可以使用可变参数参数指定的参数可以传递不同数量的输入值，当函数被调用。通过插入三期字符（写可变参数的参数...，参数的类型名称之后）。</p>

<p>传递给一个可变参数的参数值是由该函数的体内可作为适当的类型的阵列。例如，具有一名称的可变参数的参数numbers和类型的Double...在功能的身体内提供作为所谓的恒定阵列numbers类型[Double]。</p>

<p>下面的例子中计算算术平均值（也称为平均）为任何长度的号码的列表：</p>

<p>func arithmeticMean(_ numbers: Double...) -&gt; Double {<br/>
    var total: Double = 0<br/>
    for number in numbers {<br/>
        total += number<br/>
    }<br/>
    return total / Double(numbers.count)<br/>
}<br/>
arithmeticMean(1, 2, 3, 4, 5)<br/>
// returns 3.0, which is the arithmetic mean of these five numbers<br/>
arithmeticMean(3, 8.25, 18.75)<br/>
// returns 10.0, which is the arithmetic mean of these three numbers<br/>
注意</p>

<p>函数可以最多只能有一个可变参数的参数。</p>

<p>IN-OUT参数</p>

<p>功能参数默认常量。尝试将功能参数的值从一个编译时间错误，函数结果的主体内变化。这意味着您不能错误地改变一个参数的值。如果你想要一个函数来修改参数的值，并且希望这些变化将持续函数调用结束后，定义参数作为IN-OUT参数来代替。</p>

<p>您通过将写在输出参数inout一个参数的类型之前关键字的权利。一个在出参数具有被传递的值中，由函数修改函数，并传回出的功能来代替原来的值。对于输出参数和相关编译器优化的行为的详细讨论，请参阅输入-输出参数。</p>

<p>你只能传递一个变量作为一个在输出参数的说法。你不能传递一个常量或文字值作为参数，因为常量和文字不能被修改。你把一个符号（&amp;当你把它作为参数传递给一个在输出参数，以表明它可通过函数修改直接变量的名称前）。</p>

<p>注意</p>

<p>在输出参数不能有默认值，可变参数的参数不能被标记为inout。</p>

<p>这里有一个调用的函数的例子swapTwoInts(<u>:</u>:)，其中有两个出整型参数叫a和b：</p>

<p>func swapTwoInts(_ a: inout Int, _ b: inout Int) {<br/>
    let temporaryA = a<br/>
    a = b<br/>
    b = temporaryA<br/>
}<br/>
该swapTwoInts(<u>:</u>:)功能只是交换价值b成a，和值a成b。功能执行该交换通过存储的值a中的临时恒定叫temporaryA，分配的值b来a，然后分配temporaryA到b。</p>

<p>您可以调用swapTwoInts(<u>:</u>:)函数类型的两个变量Int交换它们的值。注意的名称someInt和anotherInt与当它们被传递到一个符号前缀swapTwoInts(<u>:</u>:)功能：</p>

<p>var someInt = 3<br/>
var anotherInt = 107<br/>
swapTwoInts(&amp;someInt, &amp;anotherInt)<br/>
print(<q>someInt is now (someInt), and anotherInt is now (anotherInt)</q>)<br/>
// Prints <q>someInt is now 107, and anotherInt is now 3</q><br/>
上面的例子表明，原始值someInt和anotherInt被修改的swapTwoInts(<u>:</u>:)功能，即使他们最初的功能之外定义。</p>

<p>注意</p>

<p>在超时参数不一样从函数返回一个值。在swapTwoInts上面的例子不定义返回类型或返回一个值，但它仍然改变的价值观someInt和anotherInt。在出参数是一个函数具有其功能体的范围之外的效果的另一种方法。</p>

<p>功能类型</p>

<p>每个函数都有一个特定的功能类型，由参数类型和函数的返回类型。</p>

<p>例如：</p>

<p>func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {<br/>
    return a + b<br/>
}<br/>
func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {<br/>
    return a * b<br/>
}<br/>
这个例子定义了两个简单的数学函数调用addTwoInts和multiplyTwoInts。这些函数的每个取两个Int值，并返回一个Int值，它是执行一个适当的数学运算的结果。</p>

<p>该型这两种功能是(Int, Int) -&gt; Int。这可以理解为：</p>

<p>“具有两个参数都类型，一个功能类型Int，并返回类型的值Int”。</p>

<p>这里是另外一个例子，对于不带参数或者返回值的函数：</p>

<p>func printHelloWorld() {<br/>
    print(<q>hello, world</q>)<br/>
}<br/>
类型此功能是() -&gt; Void，或“没有参数，并返回一个功能Void。”</p>

<p>使用功能类型</p>

<p>您可以使用函数类型，就像任何其他类型的斯威夫特。例如，您可以定义一个常量或变量是一个函数类型，并为其指定相应的函数变量：</p>

<p>var mathFunction: (Int, Int) -&gt; Int = addTwoInts<br/>
这可以理解为：</p>

<p>“定义一个名为变量mathFunction，它的类型为”取两个函数Int值，并返回一个Int值。“ 设置这个新的变量引用调用的函数addTwoInts“。</p>

<p>该addTwoInts(<u>:</u>:)函数具有相同类型的mathFunction变量，因此该分配由斯威夫特的类型检查器允许的。</p>

<p>现在，您可以调用名为分配的功能mathFunction：</p>

<p>print(<q>Result: (mathFunction(2, 3))</q>)<br/>
// Prints <q>Result: 5</q><br/>
具有相同的匹配的类型不同的功能可以被分配给相同的变量，以同样的方式，作为非功能类型：</p>

<p>mathFunction = multiplyTwoInts<br/>
print(<q>Result: (mathFunction(2, 3))</q>)<br/>
// Prints <q>Result: 6</q><br/>
与任何其他类型，可以留给斯威夫特，当你一个函数分配给一个常量或变量来推断函数类型：</p>

<p>let anotherMathFunction = addTwoInts<br/>
// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int<br/>
功能类型作为参数类型</p>

<p>您可以使用函数类型，如(Int, Int) -&gt; Int作为参数类型其他功能。这使您可以留下一个函数的实现的某些方面的函数的调用者提供当函数被调用。</p>

<p>下面就来打印从上面的数学函数的结果的例子：</p>

<p>func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {<br/>
    print(<q>Result: (mathFunction(a, b))</q>)<br/>
}<br/>
printMathResult(addTwoInts, 3, 5)<br/>
// Prints <q>Result: 8</q><br/>
这个例子定义了一个调用的函数printMathResult(<u>:</u>:_:)，它有三个参数。第一个参数被称为mathFunction，并且是类型(Int, Int) -&gt; Int。您可以传递一个类型作为这个第一个参数一个参数的任何功能。第二和第三个参数被称为a和b，并且都是类型Int。这些被用作用于提供数学函数的两个输入值。</p>

<p>当printMathResult(<u>:</u>:<u>:)被调用时，它被传递的addTwoInts(</u>:_:)功能，并且整数值3和5。它与值调用提供功能3和5，并打印的结果8。</p>

<p>的作用printMathResult(<u>:</u>:<u>:)是要打印到一个适当的类型的一个数学函数的调用的结果。不要紧，那是什么功能的实现实际上确实，它的事项只有该功能是正确的类型。这使printMathResult(</u>:<u>:</u>:)以手断它的某些功能的功能的一个类型安全的方式调用者。</p>

<p>功能类型的返回类型</p>

<p>您可以使用函数类型作为另一个函数的返回类型。您可以通过返回箭头（后马上写一个完整的功能类型做-&gt;返回功能）。</p>

<p>下面的例子定义了两个简单的函数调用stepForward(<u>:)和stepBackward(</u>:)。该stepForward(<u>:)函数返回小于其输入值的值多一个，并且所述stepBackward(</u>:)函数返回一个值一个比它的输入值。这两个函数的类型为(Int) -&gt; Int：</p>

<p>func stepForward(_ input: Int) -&gt; Int {<br/>
    return input + 1<br/>
}<br/>
func stepBackward(_ input: Int) -&gt; Int {<br/>
    return input - 1<br/>
}<br/>
这里有一个调用的函数chooseStepFunction(backward:)，它的返回类型为(Int) -&gt; Int。该chooseStepFunction(backward:)函数返回stepForward(<u>:)函数或stepBackward(</u>:)基于称为布尔参数的函数backward：</p>

<p>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {<br/>
    return backward ? stepBackward : stepForward<br/>
}<br/>
您现在可以使用chooseStepFunction(backward:)获得的功能将在一个方向或其他步骤：</p>

<p>var currentValue = 3<br/>
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)<br/>
// moveNearerToZero now refers to the stepBackward() function<br/>
如前述示例确定的正或负步骤是否被移动一个称为可变需要currentValue逐渐接近零。currentValue具有的初始值3，这意味着currentValue &gt; 0返回true，造成chooseStepFunction(backward:)返回stepBackward(_:)功能。到返回的函数的引用存储在一个所谓的恒定moveNearerToZero。</p>

<p>现在，moveNearerToZero指的是正确的功能，它可以被用来计数到零：</p>

<p>print(<q>Counting to zero:</q>)<br/>
// Counting to zero:<br/>
while currentValue != 0 {<br/>
    print(<q>(currentValue)...</q>)<br/>
    currentValue = moveNearerToZero(currentValue)<br/>
}<br/>
print(<q>zero!</q>)<br/>
// 3...<br/>
// 2...<br/>
// 1...<br/>
// zero!<br/>
嵌套函数</p>

<p>在座的各位都在本章中迄今为止遇到的功能一直是例子全局函数，这是在全球范围内定义。您还可以将其他的功能，被称为身体里定义函数嵌套函数。</p>

<p>嵌套功能从外界默认是隐藏的，但仍然可以调用，其封闭函数使用。一个封闭函数也可以返回其嵌套的功能之一，以允许在另一个范围中使用的嵌套函数。</p>

<p>你可以重写chooseStepFunction(backward:)上面的例子使用和返回嵌套函数：</p>

<p>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {<br/>
    func stepForward(input: Int) -&gt; Int { return input + 1 }<br/>
    func stepBackward(input: Int) -&gt; Int { return input - 1 }<br/>
    return backward ? stepBackward : stepForward<br/>
}<br/>
var currentValue = -4<br/>
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)<br/>
// moveNearerToZero now refers to the nested stepForward() function<br/>
while currentValue != 0 {<br/>
    print(<q>(currentValue)...</q>)<br/>
    currentValue = moveNearerToZero(currentValue)<br/>
}<br/>
print(<q>zero!</q>)<br/>
// -4...<br/>
// -3...<br/>
// -2...<br/>
// -1...<br/>
// zero!</p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743597355186.html"  title="Previous Post: 此篇以下未整理仅谷歌翻译">&laquo; 此篇以下未整理仅谷歌翻译</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743597798199.html" 
	        title="Next Post: 关闭">关闭 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743597582027.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
