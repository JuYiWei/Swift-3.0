<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Swift 之旅 待 - Swift 3.0 官方文档 自整理 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 官方文档 自整理 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 官方文档 自整理 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 官方文档 自整理 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
          
            <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="控制流" href="14743597355186.html">控制流</a></li>
          
            <li><a title="函数" href="14743597582027.html">函数</a></li>
          
            <li><a title="闭包*" href="14743597798199.html">闭包*</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构 待2" href="14743598083496.html">类和结构 待2</a></li>
          
            <li><a title="属性 待2" href="14743598294467.html">属性 待2</a></li>
          
            <li><a title="方法 待2" href="14743598422216.html">方法 待2</a></li>
          
            <li><a title="下标语法 待2" href="14743598556978.html">下标语法 待2</a></li>
          
            <li><a title="继承 待2" href="14743598699234.html">继承 待2</a></li>
          
            <li><a title="初始化 待2" href="14743599314901.html">初始化 待2</a></li>
          
            <li><a title="反初始化 待2" href="14743599349637.html">反初始化 待2</a></li>
          
            <li><a title="自动引用计数 待2" href="14743599484388.html">自动引用计数 待2</a></li>
          
            <li><a title="可选链接 待2" href="14743599610249.html">可选链接 待2</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换 cool" href="14743599908626.html">类型转换 cool</a></li>
          
            <li><a title="嵌套类型 待2" href="14743600051579.html">嵌套类型 待2</a></li>
          
            <li><a title="扩展 待2" href="14743600183280.html">扩展 待2</a></li>
          
            <li><a title="协议 待2" href="14743600314526.html">协议 待2</a></li>
          
            <li><a title="泛型 待2" href="14743600461552.html">泛型 待2</a></li>
          
            <li><a title="访问控制 待" href="14743600592705.html">访问控制 待</a></li>
          
            <li><a title="高级操作员 待" href="14743600739128.html">高级操作员 待</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考 待</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="语句？" href="14743601868497.html">语句？</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
                        
                          <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="控制流" href="14743597355186.html">控制流</a></li>
                        
                          <li><a title="函数" href="14743597582027.html">函数</a></li>
                        
                          <li><a title="闭包*" href="14743597798199.html">闭包*</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构 待2" href="14743598083496.html">类和结构 待2</a></li>
                        
                          <li><a title="属性 待2" href="14743598294467.html">属性 待2</a></li>
                        
                          <li><a title="方法 待2" href="14743598422216.html">方法 待2</a></li>
                        
                          <li><a title="下标语法 待2" href="14743598556978.html">下标语法 待2</a></li>
                        
                          <li><a title="继承 待2" href="14743598699234.html">继承 待2</a></li>
                        
                          <li><a title="初始化 待2" href="14743599314901.html">初始化 待2</a></li>
                        
                          <li><a title="反初始化 待2" href="14743599349637.html">反初始化 待2</a></li>
                        
                          <li><a title="自动引用计数 待2" href="14743599484388.html">自动引用计数 待2</a></li>
                        
                          <li><a title="可选链接 待2" href="14743599610249.html">可选链接 待2</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换 cool" href="14743599908626.html">类型转换 cool</a></li>
                        
                          <li><a title="嵌套类型 待2" href="14743600051579.html">嵌套类型 待2</a></li>
                        
                          <li><a title="扩展 待2" href="14743600183280.html">扩展 待2</a></li>
                        
                          <li><a title="协议 待2" href="14743600314526.html">协议 待2</a></li>
                        
                          <li><a title="泛型 待2" href="14743600461552.html">泛型 待2</a></li>
                        
                          <li><a title="访问控制 待" href="14743600592705.html">访问控制 待</a></li>
                        
                          <li><a title="高级操作员 待" href="14743600739128.html">高级操作员 待</a></li>
                        

                    
                      <li class="side-title"><span>语法参考 待</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="语句？" href="14743601868497.html">语句？</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>Swift 之旅 待</h1>

<ul>
<li>
<a href="#toc_0">准备</a>
</li>
<li>
<a href="#toc_1">简单的值</a>
</li>
<li>
<a href="#toc_2">控制流</a>
</li>
<li>
<a href="#toc_3">函数和闭包</a>
</li>
<li>
<a href="#toc_4">对象和类</a>
</li>
<li>
<a href="#toc_5">枚举和结构</a>
</li>
<li>
<a href="#toc_6">协议和扩展</a>
</li>
<li>
<a href="#toc_7">错误处理</a>
</li>
<li>
<a href="#toc_8">泛型</a>
</li>
</ul>


<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1">A Swift Tour 官方文档</a></p>

<h1 id="toc_0">准备</h1>

<ul>
<li>第一行代码，hello world！</li>
</ul>

<pre><code>print(&quot;Hello, world!&quot;)
</code></pre>

<ul>
<li><p>如果您编写过C或Objective-C的代码，对swift的开始使用应该熟悉，这行代码是一个完整的程序，程序的入口已经封装在AppDelegate了，所以你不需要自己写<code>main()</code>。<strong>另外不同OC的是，你也不需要在每一个语句结尾写分号</strong>。</p></li>
<li><p>这篇预览文章，展示如何用Swift完成各种编程任务。如果不明白本次预览的内容，具体细节在本书的其余部分解释。</p></li>
<li><p>为了获得最佳体验，打开playground，允许编辑代码，并立即看到结果。<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip">下载playground</a></p></li>
</ul>

<h1 id="toc_1">简单的值</h1>

<ul>
<li>用<code>let</code>初始化常量和<code>var</code>初始化变量。一个常量的值并不需要在编译时就已知，但必须只分配一次值。</li>
</ul>

<pre><code>var myVariable = 42
myVariable = 50
let myConstant = 42
</code></pre>

<ul>
<li>要分配值时，必须具有相同的类型。</li>
<li>但当你创建一个常量或变量，并提供了一个值，那么编译器会推断其类型。在上面的例子中，编译器推断<code>myVariable</code>是整型，因为它的初始值是一个整型。</li>
<li>如果初始值不提供足够的信息（或者如果没有初始值），需要用冒号隔开，写指定类型。</li>
</ul>

<pre><code>let implicitInteger = 70
let implicitDouble = 70.0
let explicitDouble: Double = 70
</code></pre>

<pre><code>练习：创建一个值为4的Float类型常数。
</code></pre>

<ul>
<li>值类型不会隐式转换为另一种类型，如果需要转换为不同类型，需要明确地进行的类型转换。</li>
</ul>

<pre><code>let label = &quot;The width is &quot;
let width = 94
let widthLabel = label + String(width)
</code></pre>

<pre><code>练习：尝试最后一行不使用String转换，你得到什么错误？
</code></pre>

<ul>
<li>更简单的方法（类似格式化字符串），在字符串中使用<code>(\value)</code>包含值，括在数值和字符串。例如：</li>
</ul>

<pre><code>let apples = 3
let oranges = 5
let appleSummary = &quot;I have \(apples) apples.&quot;
let fruitSummary = &quot;I have \(apples + oranges) pieces of fruit.&quot;
</code></pre>

<pre><code>练习：在字符串中使用\()包含浮点计算表达式。
</code></pre>

<ul>
<li>用括号<code>[]</code>创建数组和字典，通过写在括号内的索引或关键词访问其内容。最后一个元素之后允许逗号。</li>
</ul>

<pre><code>var shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;]
shoppingList[1] = &quot;bottle of water&quot;
 
var occupations = [
    &quot;Malcolm&quot;: &quot;Captain&quot;,
    &quot;Kaylee&quot;: &quot;Mechanic&quot;,
]
occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;
</code></pre>

<ul>
<li>创建一个空数组或字典，使用初始化语法。</li>
</ul>

<pre><code>let emptyArray = [String]()
let emptyDictionary = [String: Float]()
</code></pre>

<ul>
<li>如果类型信息可以推断，你可以写一个空数组作为<code>[]</code>和一个空的字典作为<code>[:]</code>。例如，当你为一个变量设置一个新值或给函数传递参数。</li>
</ul>

<pre><code>shoppingList = []
occupations = [:]
</code></pre>

<h1 id="toc_2">控制流</h1>

<ul>
<li>使用<code>if</code>和<code>switch</code>制作条件语句，并使用<code>for-in</code>，<code>for</code>，<code>while</code>和<code>repeat-while</code>进行循环。条件或循环变量括号是可选的。主体括号是必需的。</li>
</ul>

<pre><code>let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score &gt; 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
print(teamScore)
</code></pre>

<ul>
<li>在一个if语句，条件必须是布尔表达式，而不会隐式与零比较，这意味着<code>if score { ... }</code>是一个错误。</li>
<li>可以使用<code>if</code>语句，<code>let</code>赋值可选类型的值（即可选绑定）。可选类型的值要么是<code>值</code>要么是<code>nil</code>。使用问号<code>?</code>跟在类型之后，表示该值是可选类型。</li>
</ul>

<pre><code>var optionalString: String? = &quot;Hello&quot;
print(optionalString == nil)
 
var optionalName: String? = &quot;John Appleseed&quot;
var greeting = &quot;Hello!&quot;
if let name = optionalName {
    greeting = &quot;Hello, \(name)&quot;
}
</code></pre>

<pre><code>练习：将optionalName变为nil。你得到什么？添加else，设置不同的问候语。
</code></pre>

<ul>
<li>如果可选的值为<code>nil</code>，条件是<code>false</code>在括号中的代码被跳过。反之，该可选值被解析并分配给<code>let</code>的常量，并在代码块中的可用。</li>
<li>处理可选值的另一种方法，提供一种使运算符<code>??</code>。如果可选的值为nil，则使用默认值。</li>
</ul>

<pre><code>let nickName: String? = nil
let fullName: String = &quot;John Appleseed&quot;
let informalGreeting = &quot;Hi \(nickName ?? fullName)&quot;
</code></pre>

<ul>
<li>switch支持任何类型的数据和各种比较操作。</li>
</ul>

<pre><code>let vegetable = &quot;red pepper&quot;
switch vegetable {
case &quot;celery&quot;:
    print(&quot;Add some raisins and make ants on a log.&quot;)
case &quot;cucumber&quot;, &quot;watercress&quot;:
    print(&quot;That would make a good tea sandwich.&quot;)
case let x where x.hasSuffix(&quot;pepper&quot;):
    print(&quot;Is it a spicy \(x)?&quot;)
default:
    print(&quot;Everything tastes good in soup.&quot;)
}
</code></pre>

<pre><code>练习：尝试删除默认的情况下。你得到什么错误？
</code></pre>

<ul>
<li><p>执行匹配的代码后，程序从<code>switch</code>语句退出。不继续执行下一个<code>case</code>，所以没有必要在每个<code>case</code>结束时明确地使用<code>break</code>。</p></li>
<li><p>使用<code>for-in</code>为每个键-值对迭代。字典是一个无序集合，所以它们的键和值以任意顺序进行迭代。</p></li>
</ul>

<pre><code>let interestingNumbers = [
    &quot;Prime&quot;: [2, 3, 5, 7, 11, 13],
    &quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8],
    &quot;Square&quot;: [1, 4, 9, 16, 25],
]
var largest = 0
for (kind, numbers) in interestingNumbers {
    for number in numbers {
        if number &gt; largest {
            largest = number
        }
    }
}
print(largest)
</code></pre>

<pre><code>练习：添加另一个变量来跟踪哪个类型的数量是最多的，以及最大的。
</code></pre>

<ul>
<li>使用<code>while</code>循环，<code>repeat-while</code>循环</li>
</ul>

<pre><code>var n = 2
while n &lt; 100 {
    n = n * 2
}
print(n)
 
 
var m = 2
repeat {
    m = m * 2
} while m &lt; 100
print(m)
</code></pre>

<ul>
<li>使用<code>..&lt;</code>半封闭范围，使用<code>...</code>封闭范围。</li>
</ul>

<pre><code>var total = 0
for i in 0..&lt;4 {
    total += i
}
print(total)
</code></pre>

<h1 id="toc_3">函数和闭包</h1>

<ul>
<li>使用<code>func</code>声明函数，<code>()</code>中指定参数，<code>-&gt;</code>指定返回类型。</li>
</ul>

<pre><code>func greet(person: String, day: String) -&gt; String {
    return &quot;Hello \(person), today is \(day).&quot;
}
greet(person: &quot;Bob&quot;, day: &quot;Tuesday&quot;)
</code></pre>

<pre><code>练习：删除day参数。添加新参数。
</code></pre>

<ul>
<li>默认情况下，函数使用参数名称作为参数标签，参数名前也可以自定义参数标签，或写<code>_</code>为不显示参数标签。</li>
</ul>

<pre><code>func greet(_ person: String, on day: String) -&gt; String {
    return &quot;Hello \(person), today is \(day).&quot;
}
greet(&quot;John&quot;, on: &quot;Wednesday&quot;)
</code></pre>

<ul>
<li>使用元组做复合值，从一个函数返回多个值，一个元组的元素可以通过名称或数字来获取。</li>
</ul>

<pre><code>func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0
    
    for score in scores {
        if score &gt; max {
            max = score
        } else if score &lt; min {
            min = score
        }
        sum += score
    }
    
    return (min, max, sum)
}
let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])
print(statistics.sum)
print(statistics.2)
</code></pre>

<ul>
<li>采用可变数目的参数，收集他们到一个参数数组。</li>
</ul>

<pre><code>func sumOf(numbers: Int...) -&gt; Int {
    var sum = 0
    for number in numbers {
        sum += number
    }
    return sum
}
sumOf()
sumOf(numbers: 42, 597, 12)
</code></pre>

<pre><code>练习：计算它的参数的平均值。
</code></pre>

<ul>
<li>函数可以嵌套，嵌套函数可以访问外部函数中声明的变量。</li>
</ul>

<pre><code>func returnFifteen() -&gt; Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
</code></pre>

<ul>
<li>函数可以返回另一个函数作为返回值。</li>
</ul>

<pre><code>func makeIncrementer() -&gt; ((Int) -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre>

<ul>
<li>函数作为参数。</li>
</ul>

<pre><code>func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
</code></pre>

<ul>
<li>函数闭包实际上是一个特例，闭包代码块可以之后调用。闭包中的代码可以访问其外部变量。已经在嵌套函数中看过这个例子了。匿名函数闭包，周围的代码与括号<code>({ })</code>，使用<code>in</code>分离参数和返回类型。</li>
</ul>

<pre><code>numbers.map({
    (number: Int) -&gt; Int in
    let result = 3 * number
    return result
})
</code></pre>

<pre><code>练习：重写修改所有奇数返回零。
</code></pre>

<ul>
<li>更简明地写闭包，当闭包类型是已知的，诸如委托回调，可以省略参数，返回类型，或两者都省略。（不明觉厉）</li>
</ul>

<pre><code>let mappedNumbers = numbers.map({ number in 3 * number })
print(mappedNumbers)
</code></pre>

<ul>
<li>通过数而不是名称，这种方法在某些闭包特别有用。作为最后一个参数传递给函数的闭包可以在括号后立即出现。当一个闭包是一个函数唯一的参数，你完全可以省略括号。（不明觉厉）</li>
</ul>

<pre><code>let sortedNumbers = numbers.sorted { $0 &gt; $1 }
print(sortedNumbers)
</code></pre>

<h1 id="toc_4">对象和类</h1>

<ul>
<li>使用<code>class</code>的类名来创建一个类。类属性声明常量或变量是相同的，方法和函数声明是相同的。</li>
</ul>

<pre><code>class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
        return &quot;A shape with \(numberOfSides) sides.&quot;
    }
}
</code></pre>

<pre><code>练习：添加一个常量，并添加一个需要一个参数的方法。
</code></pre>

<ul>
<li>创建一个类的实例。使用点语法来访问属性和实例的方法。</li>
</ul>

<pre><code>var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre>

<ul>
<li>Shape类缺少一些东西：初始化设置，使用<code>init</code>创建。</li>
</ul>

<pre><code>class NamedShape {
    var numberOfSides: Int = 0
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func simpleDescription() -&gt; String {
        return &quot;A shape with \(numberOfSides) sides.&quot;
    }
}
</code></pre>

<ul>
<li><p>注意<code>self</code>来区分的<code>name</code>是属性还是参数。当类的实例初始化时，每个属性都应该分配默认值，无论是在声明时（类似<code>numberOfSides</code>）或初始化时（类似<code>name</code>）。</p></li>
<li><p>使用deinit，在对象被释放之前进行一些清理工作。</p></li>
<li><p>子类可以继承父类，用冒号分隔。没有要求子类必须继承标准的根类。</p></li>
<li><p>子类中的方法重写父类的实现，需要标有<code>override</code>。编译器会检测方法是否正确<code>override</code>。</p></li>
</ul>

<pre><code>class Square: NamedShape {
    var sideLength: Double
    
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }
    
    func area() -&gt;  Double {
        return sideLength * sideLength
    }
    
    override func simpleDescription() -&gt; String {
        return &quot;A square with sides of length \(sideLength).&quot;
    }
}
let test = Square(sideLength: 5.2, name: &quot;my test square&quot;)
test.area()
test.simpleDescription()
</code></pre>

<pre><code>制作的另一个子类NamedShape叫做Circle采用一个半径和名作为参数传递给它的初始化。实施area()和simpleDescription()对方法Circle的类。
</code></pre>

<ul>
<li>除了存储简单的属性，属性可以有一个<code>getter</code>和一个<code>setter</code>。</li>
</ul>

<pre><code>class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0
    
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }
    
    var perimeter: Double {
        get {
            return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }
    
    override func simpleDescription() -&gt; String {
        return &quot;An equilateral triangle with sides of length \(sideLength).&quot;
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;)
print(triangle.perimeter)
triangle.perimeter = 9.9
print(triangle.sideLength)
</code></pre>

<ul>
<li><p>在<code>setter</code>方法<code>perimeter</code>中，新的值有隐含的名字<code>newValue</code>。</p></li>
<li><p>请注意这个初始化<code>EquilateralTriangle</code>类有三个步骤：</p></li>
</ul>

<pre><code>1 设置类声明属性的值。
2 调用父类的初始化。
3 改变由超类中定义的属性的值。使用方法的getter，setter方法​​或其他设置工作。
</code></pre>

<ul>
<li><code>willSet</code>和<code>didSet</code>，set之前之后额外处理。例如，下面类确保其三角形的边长是总是相同的正方形的边长。</li>
</ul>

<pre><code>class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: &quot;another test shape&quot;)
print(triangleAndSquare.square.sideLength)
print(triangleAndSquare.triangle.sideLength)
triangleAndSquare.square = Square(sideLength: 50, name: &quot;larger square&quot;)
print(triangleAndSquare.triangle.sideLength)
</code></pre>

<ul>
<li>使用可选类型时，当可选值为<code>nil</code>之后，带有可选标记<code>?</code>的实例操作将被忽略。反之则正常解析处理。</li>
</ul>

<pre><code>let optionalSquare: Square? = Square(sideLength: 2.5, name: &quot;optional square&quot;)
let sideLength = optionalSquare?.sideLength
</code></pre>

<h1 id="toc_5">枚举和结构</h1>

<ul>
<li>使用<code>enum</code>创建枚举，与类和所有其他类型一样，枚举可以有相关联的方法。</li>
</ul>

<pre><code>enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king
    func simpleDescription() -&gt; String {
        switch self {
        case .ace:
            return &quot;ace&quot;
        case .jack:
            return &quot;jack&quot;
        case .queen:
            return &quot;queen&quot;
        case .king:
            return &quot;king&quot;
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
</code></pre>

<pre><code>练习：写两个比较函数Rank通过比较其原始值的值。
</code></pre>

<ul>
<li><p>默认情况下，Swift开始分配的原始值为零并且每次递增，但你可以明确指定的值。在上面的例子中，Ace明确给出的原始值1，其余部分递增1。还可以使用字符串或浮点数作为原始值，使用<code>rawValue</code>属性来访问枚举的原始值。</p></li>
<li><p>使用<code>init?(rawValue:)</code>初始化，通过原始值获取枚举值，当然返回的是可选类型。</p></li>
</ul>

<pre><code>if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
</code></pre>

<ul>
<li>枚举值是实际值，而不仅仅是原始值的另一种方式。事实上，原始值没有意义的情况下，可以忽略原始值。</li>
</ul>

<pre><code>enum Suit {
    case spades, hearts, diamonds, clubs
    func simpleDescription() -&gt; String {
        switch self {
        case .spades:
            return &quot;spades&quot;
        case .hearts:
            return &quot;hearts&quot;
        case .diamonds:
            return &quot;diamonds&quot;
        case .clubs:
            return &quot;clubs&quot;
        }
    }
}
let hearts = Suit.hearts
let heartsDescription = hearts.simpleDescription()
</code></pre>

<pre><code>练习：添加color()方法，黑桃和梅花返回“black”，红心和方块返回“red”。
</code></pre>

<ul>
<li>使用<code>struct</code>创建结构。结构支持许多相同的行为，如类，包括方法和初始化。其中结构和类之间最重要的区别是，结构始终复制，但类按引用传递。</li>
</ul>

<pre><code>struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -&gt; String {
        return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;
    }
}
let threeOfSpades = Card(rank: .three, suit: .spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
</code></pre>

<pre><code>练习：添加一个方法创建牌，用点数和花色组合一张卡。
</code></pre>

<ul>
<li>枚举的一个实例可以与实例关联的值。（不明觉厉，不太理解怎么搞，这个举例有点奇葩）</li>
</ul>

<pre><code>enum ServerResponse {
    case result(String, String)
    case failure(String)
}
 
let success = ServerResponse.result(&quot;6:00 am&quot;, &quot;8:09 pm&quot;)
let failure = ServerResponse.failure(&quot;Out of cheese.&quot;)
 
switch success {
case let .result(sunrise, sunset):
    print(&quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;)
case let .failure(message):
    print(&quot;Failure...  \(message)&quot;)
}
</code></pre>

<pre><code>练习：ServerResponse添加第三种情况，并重新switch。
</code></pre>

<h1 id="toc_6">协议和扩展</h1>

<ul>
<li>使用<code>protocol</code>申明协议。</li>
</ul>

<pre><code>protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
</code></pre>

<ul>
<li>类，枚举和结构可以采用协议。</li>
</ul>

<pre><code>class SimpleClass: ExampleProtocol {
    var simpleDescription: String = &quot;A very simple class.&quot;
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += &quot;  Now 100% adjusted.&quot;
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription
 
struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = &quot;A simple structure&quot;
    mutating func adjust() {
        simpleDescription += &quot; (adjusted)&quot;
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
</code></pre>

<pre><code>练习：编写符合本协议的枚举。
</code></pre>

<ul>
<li><p>注意使用的<code>mutating</code>关键字来申明<code>SimpleStructure</code>时标记修改结构的方法。声明<code>SimpleClass</code>类则不需要。</p></li>
<li><p>使用<code>extension</code>添加拓展，如新的方法和计算的属性。</p></li>
</ul>

<pre><code>extension Int: ExampleProtocol {
    var simpleDescription: String {
        return &quot;The number \(self)&quot;
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)
</code></pre>

<pre><code>练习：写的一个Double的拓展，增加了一个absoluteValue属性。
</code></pre>

<ul>
<li>使用协议名称，就像任何其他类型的命名。当使用值类型继承协议类型时，协议定义之外的方法不可用。</li>
</ul>

<pre><code>let protocolValue: ExampleProtocol = a
print(protocolValue.simpleDescription)
// print(protocolValue.anotherProperty)  // Uncomment to see the error
</code></pre>

<ul>
<li>即使变量<code>protocolValue</code>具有一个运行时类型<code>SimpleClass</code>，编译器将其视为给定类型的<code>ExampleProtocol</code>。这意味着不能访问除了该类协议以外的实现方法或属性。</li>
</ul>

<h1 id="toc_7">错误处理</h1>

<ul>
<li>使用错误的Error协议。</li>
</ul>

<pre><code>enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}
</code></pre>

<ul>
<li>用<code>throws</code>标记，使用<code>throw</code>抛出一个错误。如果在一个函数抛出一个错误，函数立即返回，调用该函数的代码处理错误。</li>
</ul>

<pre><code>func send(job: Int, toPrinter printerName: String) throws -&gt; String {
    if printerName == &quot;Never Has Toner&quot; {
        throw PrinterError.noToner
    }
    return &quot;Job sent&quot;
}
</code></pre>

<ul>
<li>有几种方法来处理错误。一种方法是使用<code>do-catch</code>。里面<code>do</code>标记代码，通过<code>try</code>尝试执行带有<code>throws</code>的函数，<code>catch</code>块抓取错误，自动赋予的名称<code>error</code>，除非你给它一个不同的名称。</li>
</ul>

<pre><code>do {
    let printerResponse = try send(job: 1040, toPrinter: &quot;Bi Sheng&quot;)
    print(printerResponse)
} catch {
    print(error)
}
</code></pre>

<pre><code>练习：更改打印机名称&quot;Never Has Toner&quot;，这样send(job:toPrinter:)函数抛出一个错误。
</code></pre>

<ul>
<li>提供多个<code>catch</code>用于处理特定错误，如图<code>case</code>一样。</li>
</ul>

<pre><code>do {
    let printerResponse = try send(job: 1440, toPrinter: &quot;Gutenberg&quot;)
    print(printerResponse)
} catch PrinterError.onFire {
    print(&quot;I&#39;ll just put this over here, with the rest of the fire.&quot;)
} catch let printerError as PrinterError {
    print(&quot;Printer error: \(printerError).&quot;)
} catch {
    print(error)
}
</code></pre>

<pre><code>练习：添加代码以抛出内部的错误。你需要什么样的错误抛出，这样的错误是由第一catch处理？第二和第三呢？
</code></pre>

<ul>
<li>处理错误的另一种方法是使用<code>try?</code>将结果转换到可选类型。如果函数抛出一个错误，具体的错误将被丢弃，结果是nil。否则，结果是包含该函数的返回值的可选类型。</li>
</ul>

<pre><code>let printerSuccess = try? send(job: 1884, toPrinter: &quot;Mergenthaler&quot;)
let printerFailure = try? send(job: 1885, toPrinter: &quot;Never Has Toner&quot;)
</code></pre>

<ul>
<li>用<code>defer</code>在函数中标记，在函数返回之前，所有其它代码执行后再执行<code>defer</code>代码块。不管函数是否会引发错误都会执行。</li>
</ul>

<pre><code>var fridgeIsOpen = false
let fridgeContent = [&quot;milk&quot;, &quot;eggs&quot;, &quot;leftovers&quot;]
 
func fridgeContains(_ food: String) -&gt; Bool {
    fridgeIsOpen = true
    defer {
        fridgeIsOpen = false
    }
    
    let result = fridgeContent.contains(food)
    return result
}
fridgeContains(&quot;banana&quot;)
print(fridgeIsOpen)
</code></pre>

<h1 id="toc_8">泛型</h1>

<ul>
<li>用<code>&lt;&gt;</code>包含的名称做一个泛型函数或类型。</li>
</ul>

<pre><code>func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {
    var result = [Item]()
    for _ in 0..&lt;numberOfTimes {
        result.append(item)
    }
    return result
}
makeArray(repeating: &quot;knock&quot;, numberOfTimes:4)
</code></pre>

<ul>
<li>泛型支持函数和方法一般形式，以及类，枚举和结构。</li>
</ul>

<pre><code>// Reimplement the Swift standard library&#39;s optional type
enum OptionalValue&lt;Wrapped&gt; {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue&lt;Int&gt; = .none
possibleInteger = .some(100)
</code></pre>

<ul>
<li>使用<code>where</code>可选选择性过滤。</li>
</ul>

<pre><code>func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool
    where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element {
        for lhsItem in lhs {
            for rhsItem in rhs {
                if lhsItem == rhsItem {
                    return true
                }
            }
        }
        return false
}
anyCommonElements([1, 2, 3], [3])
</code></pre>

<pre><code>练习：修改anyCommonElements(_:_:)功能，使返回的任何两个数组具有共同的元素的数组。
</code></pre>

<ul>
<li><T: Equatable> 与 <T> ... where T: Equatable&gt; 是一样的。</li>
</ul>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743413991106.html"  title="Previous Post: 关于 Swift">&laquo; 关于 Swift</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743413996803.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
