<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  方法 - Swift 3.0 官方文档 自整理 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 官方文档 自整理 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 官方文档 自整理 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 官方文档 自整理 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
          
            <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="功能" href="14743597582027.html">功能</a></li>
          
            <li><a title="关闭" href="14743597798199.html">关闭</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标" href="14743598556978.html">下标</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="初始化" href="14743599314901.html">初始化</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
                        
                          <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="功能" href="14743597582027.html">功能</a></li>
                        
                          <li><a title="关闭" href="14743597798199.html">关闭</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标" href="14743598556978.html">下标</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="初始化" href="14743599314901.html">初始化</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>方法</h1>

<p>方法是与特定类型的相关联的功能。类，结构和枚举都可以限定实例方法，该封装特定任务和功能与给定类型的实例的工作。类，结构和枚举也可以定义类型的方法，这是与类型本身相关联。类型方法类似于在Objective-C类的方法。</p>

<p>该结构和枚举可以定义斯威夫特方法的事实是从C和Objective-C的主要区别。在Objective-C，类是可以定义方法的唯一类型。在斯威夫特，你可以选择是否要定义一个类，结构或枚举，仍然可以灵活地定义您创建的类型的方法。</p>

<p>实例方法</p>

<p>实例方法是属于一个特定的类，结构或枚举的实例功能。它们支持这些实例的功能性，无论是通过提供方法，或通过提供与该实例的目的功能来访问和修改实例属性。实例方法具有完全相同的语法功能，所描述的功能。</p>

<p>你写它属于该类型的开幕式和闭幕式括号内的实例方法。一个实例方法有该类型的所有其他实例方法和属性的隐式访问。一个实例方法只能在它所属的类型的特定实例调用。不能孤立地称为没有现成的实例。</p>

<p>以下是定义了一个简单的例子Counter类，它可用于计算次数的动作时发生的数量：</p>

<p>class Counter {<br/>
    var count = 0<br/>
    func increment() {<br/>
        count += 1<br/>
    }<br/>
    func increment(by amount: Int) {<br/>
        count += amount<br/>
    }<br/>
    func reset() {<br/>
        count = 0<br/>
    }<br/>
}<br/>
本Counter类定义了三个实例方法：</p>

<p>increment()递增计数器1。<br/>
increment(by: Int) 通过增加一个指定的整数量计数器。<br/>
reset() 将计数器复位到零。<br/>
本Counter类还声明一个变量属性count，以跟踪当前计数器值。</p>

<p>你叫具有相同点语法为属性实例方法：</p>

<p>let counter = Counter()<br/>
// the initial counter value is 0<br/>
counter.increment()<br/>
// the counter&#39;s value is now 1<br/>
counter.increment(by: 5)<br/>
// the counter&#39;s value is now 6<br/>
counter.reset()<br/>
// the counter&#39;s value is now 0<br/>
（调用函数时使用）函数的参数可以同时拥有一个名称（函数体中使用）和一个参数的标签，如描述函数参数标签和参数名。这同样适用于方法参数真的，因为方法只是那些与类型相关联的功能。</p>

<p>自房产</p>

<p>一个类型的每个实例有一个名为一个隐含的财产self，这是完全等同于该实例本身。您可以使用self属性来引用当前实例自己的实例方法中。</p>

<p>在increment()上面可以写这样的例子方法：</p>

<p>func increment() {<br/>
    self.count += 1<br/>
}<br/>
在实践中，你不需要写self在你的代码非常频繁。如果你不明确写入self，斯威夫特假定你是指无论你使用一个方法中的一个已知的属性或方法的名称当前实例的属性或方法。这个假设是通过使用证明count（而不是self.count三个实例方法为内部）Counter。</p>

<p>当参数名的实例方法具有相同的名称作为实例的属性时，会出现主要的例外。在这种情况下，参数名称优先，并提及的属性在一个更加限定的方式，成为必要。您可以使用self属性参数名和属性名加以区分。</p>

<p>在这里，selfdisambiguates称为方法参数之间x和实例的属性，也被称为x：</p>

<p>struct Point {<br/>
    var x = 0.0, y = 0.0<br/>
    func isToTheRightOf(x: Double) -&gt; Bool {<br/>
        return self.x &gt; x<br/>
    }<br/>
}<br/>
let somePoint = Point(x: 4.0, y: 5.0)<br/>
if somePoint.isToTheRightOf(x: 1.0) {<br/>
    print(<q>This point is to the right of the line where x == 1.0</q>)<br/>
}<br/>
// Prints <q>This point is to the right of the line where x == 1.0</q><br/>
如果没有self前缀，斯威夫特会认为两者的用途x简称调用的方法参数x。</p>

<p>从内部实例方法修改值类型</p>

<p>结构和枚举是值类型。默认情况下，值类型的属性，不能从它的实例方法中修改。</p>

<p>但是，如果你需要一个特定的方法中修改结构或枚举的属性，你可以选择到变异行为的方法。然后，该方法可以突变（即，改变）的属性从方法中，并且它使当该方法结束被写回原来的结构的任何变化。该方法还可以分配一个完全新的实例其隐含的self财产，而这个新的实例将取代现有之一，当该方法结束。</p>

<p>您可以通过将选择在这种行为mutating的关键字之前，func该方法关键字：</p>

<p>struct Point {<br/>
    var x = 0.0, y = 0.0<br/>
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {<br/>
        x += deltaX<br/>
        y += deltaY<br/>
    }<br/>
}<br/>
var somePoint = Point(x: 1.0, y: 1.0)<br/>
somePoint.moveBy(x: 2.0, y: 3.0)<br/>
print(<q>The point is now at ((somePoint.x), (somePoint.y))</q>)<br/>
// Prints <q>The point is now at (3.0, 4.0)</q><br/>
在Point上述结构定义了一个突变moveBy(x:y:)的方法，它移动一个Point由一定量的实例。而不是返回一个新的点，这种方法实际上修改其所调用点。所述mutating关键字被添加到它的定义，使其能够修改其属性。</p>

<p>请注意，您不能调用结构类型的常数的变异方法，因为它的属性不能改变，即使它们是可变的属性，如描述的固定结构实例存储特性：</p>

<p>let fixedPoint = Point(x: 3.0, y: 3.0)<br/>
fixedPoint.moveBy(x: 2.0, y: 3.0)<br/>
// this will report an error<br/>
分配到自我在一个不同诱变方法</p>

<p>变异的方法可以完全新的实例分配给隐含self属性。在Point上面所示的例子可能已经写在代替以下方式：</p>

<p>struct Point {<br/>
    var x = 0.0, y = 0.0<br/>
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {<br/>
        self = Point(x: x + deltaX, y: y + deltaY)<br/>
    }<br/>
}<br/>
这个变异版本的moveBy(x:y:)方法创建一个全新的结构，其x和y值设置到目标位置。调用该方法的这个替代版本的最终结果将是完全一样调用早期版本。</p>

<p>突变方法枚举可以设置隐式self参数是从同一枚举不同的情况：</p>

<p>enum TriStateSwitch {<br/>
    case off, low, high<br/>
    mutating func next() {<br/>
        switch self {<br/>
        case .off:<br/>
            self = .low<br/>
        case .low:<br/>
            self = .high<br/>
        case .high:<br/>
            self = .off<br/>
        }<br/>
    }<br/>
}<br/>
var ovenLight = TriStateSwitch.low<br/>
ovenLight.next()<br/>
// ovenLight is now equal to .high<br/>
ovenLight.next()<br/>
// ovenLight is now equal to .off<br/>
这个例子定义了一个三态开关枚举。三种不同的功率状态（之间的切换周期off，low和high）每其时间next()方法被调用。</p>

<p>类型方法</p>

<p>实例方法中，如上所述，是被称为在一个特定的类型的实例方法。您也可以定义号召类型本身的方法。这些类型的方法被称为类型的方法。您指示由写类型的方法static方法的前关键字func关键字。类也可以使用class关键词来允许子类覆盖超类的实现该方法的。</p>

<p>注意</p>

<p>在Objective-C，你可以定义仅适用于Objective-C类型级别的方法。在斯威夫特，你可以定义为所有类，结构和枚举类型级别的方法。每种方法明确范围，以支持的类型。</p>

<p>类型方法调用点语法，像实例方法。但是，您拨打的类型类型的方法，而不是那个类型的实例。这里是你如何调用一个叫做类类型的方法SomeClass：</p>

<p>class SomeClass {<br/>
    class func someTypeMethod() {<br/>
        // type method implementation goes here<br/>
    }<br/>
}<br/>
SomeClass.someTypeMethod()<br/>
内的类型的方法的正文中，隐含self属性指的是类型本身，而不是该类型的一个实例。这意味着，你可以使用self类型属性和类型的方法参数之间的歧义，就像你的实例属性和实例方法参数做。</p>

<p>更一般地，你一个类型的方法在体内使用的任何不合格的方法和属性名称将参考其他类型级别的方法和属性。A型方法可以调用与其他方法的名称另一种方法，而无需与类型名称前缀它。同样地，在结构和枚举类型的方法可以通过使用类型属性的名称没有一个类型名称前缀访问类型属性。</p>

<p>下面的例子定义了一个名为结构LevelTracker，通过游戏的不同层次或阶段跟踪玩家的进展。它是一个单人游戏，但是可以存储在单个设备上多个玩家的信息。</p>

<p>当第一次玩游戏的所有游戏的水平（除了一个级别）被锁定。每当玩家完成一个级别，该级别是解锁设备上的所有球员。该LevelTracker结构使用类型属性和方法来跟踪哪些游戏的水平已被解锁。它还跟踪单个球员目前的水平。</p>

<p>struct LevelTracker {<br/>
    static var highestUnlockedLevel = 1<br/>
    var currentLevel = 1</p>

<pre><code>static func unlock(_ level: Int) {
    if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
}

static func isUnlocked(_ level: Int) -&gt; Bool {
    return level &lt;= highestUnlockedLevel
}

@discardableResult
mutating func advance(to level: Int) -&gt; Bool {
    if LevelTracker.isUnlocked(level) {
        currentLevel = level
        return true
    } else {
        return false
    }
}
</code></pre>

<p>}<br/>
该LevelTracker结构记录任何球员已经解锁的最高水平。此值存储在称为类型属性highestUnlockedLevel。</p>

<p>LevelTracker还定义了两种类型的功能与工作highestUnlockedLevel特性。首先是所谓的一种功能unlock(<u>:)，这将更新的价值highestUnlockedLevel，每当一个新的水平解锁。第二个是叫做便利型函数isUnlocked(</u>:)，返回true如果一个特定的级别数已解除锁定。（请注意，这些类型的方法可以访问highestUnlockedLevel，而不需要你写它作为type属性LevelTracker.highestUnlockedLevel）。</p>

<p>除了 ​​其类型属性和类型的方法，LevelTracker跟踪通过游戏个体玩家的进步。它使用一种称为实例属性currentLevel来跟踪玩家当前正在播放的水平。</p>

<p>为了帮助管理currentLevel属性，LevelTracker定义了一个名为一个实例方法advance(to:)。更新前currentLevel，这个方法检查是否要求新的水平已解除锁定。该advance(to:)方法返回一个布尔值，以表明它是否是真正能够设置currentLevel。因为它不一定代码错误调用advance(to:)忽略方法的返回值，这个函数是标有@discardableResult属性。有关此属性的详细信息，请参阅属性。</p>

<p>该LevelTracker结构用于与Player类，如下所示，以跟踪和更新个人播放器的进展：</p>

<p>class Player {<br/>
    var tracker = LevelTracker()<br/>
    let playerName: String<br/>
    func complete(level: Int) {<br/>
        LevelTracker.unlock(level + 1)<br/>
        tracker.advance(to: level + 1)<br/>
    }<br/>
    init(name: String) {<br/>
        playerName = name<br/>
    }<br/>
}<br/>
在Player类创建的一个新实例LevelTracker来跟踪玩家的进展。它也提供了一个名为方法complete(level:)，每当一个玩家完成一个特定的水平时调用。这种方法解锁所有玩家一个新的水平，并更新玩家的进度将其移动到一个新的水平。（的布尔返回值advance(to:)被忽略，因为电平是已知的已被调用解锁LevelTracker.unlock(_:)上一行）。</p>

<p>您可以创建一个实例Player为一个新的球员 ​​类，看看当玩家完成一个级别会发生什么：</p>

<p>var player = Player(name: <q>Argyrios</q>)<br/>
player.complete(level: 1)<br/>
print(<q>highest unlocked level is now (LevelTracker.highestUnlockedLevel)</q>)<br/>
// Prints <q>highest unlocked level is now 2</q><br/>
如果创建了第二个玩家，就是你尝试移动到一个还没有在游戏中任何玩家解锁的水平，设置玩家的当前级别的尝试失败：</p>

<p>player = Player(name: <q>Beto</q>)<br/>
if player.tracker.advance(to: 6) {<br/>
    print(<q>player is now on level 6</q>)<br/>
} else {<br/>
    print(<q>level 6 has not yet been unlocked</q>)<br/>
}<br/>
// Prints <q>level 6 has not yet been unlocked</q></p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743598294467.html"  title="Previous Post: 属性">&laquo; 属性</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743598556978.html" 
	        title="Next Post: 下标">下标 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743598422216.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
