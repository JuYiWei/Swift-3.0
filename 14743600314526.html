<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  协议 - Swift 3.0 官方文档 自整理 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 官方文档 自整理 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 官方文档 自整理 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 官方文档 自整理 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识 待" href="14743596331025.html">基础知识 待</a></li>
          
            <li><a title="基础运算操作 待" href="14743596434163.html">基础运算操作 待</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="控制流" href="14743597355186.html">控制流</a></li>
          
            <li><a title="函数" href="14743597582027.html">函数</a></li>
          
            <li><a title="闭包" href="14743597798199.html">闭包</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标语法" href="14743598556978.html">下标语法</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743599314901.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅 待" href="14743413996803.html">Swift 之旅 待</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识 待" href="14743596331025.html">基础知识 待</a></li>
                        
                          <li><a title="基础运算操作 待" href="14743596434163.html">基础运算操作 待</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="控制流" href="14743597355186.html">控制流</a></li>
                        
                          <li><a title="函数" href="14743597582027.html">函数</a></li>
                        
                          <li><a title="闭包" href="14743597798199.html">闭包</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标语法" href="14743598556978.html">下标语法</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743599314901.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>协议</h1>

<p>一个协议定义了适合特定任务或一项功能的方法，属性和其他要求的蓝图。该协议可以被采用由一个类，结构，或枚举，以提供一个实际实现的这些要求。满足协议要求的任何类型被认为符合该协议。</p>

<p>除了指定符合类型必须实现的要求，可以延长一个协议来实现其中的一些要求，或实施符合类型可以利用的附加功能。</p>

<p>协议语法</p>

<p>你在一个非常相似的方式来类，结构和枚举定义了协议：</p>

<p>protocol SomeProtocol {<br/>
    // protocol definition goes here<br/>
}<br/>
自定义类型的国家，他们通过将协议名称的类型的名称，用冒号隔开后，作为其定义的一部分采用特定的协议。多协议可以上市，并以逗号分隔：</p>

<p>struct SomeStructure: FirstProtocol, AnotherProtocol {<br/>
    // structure definition goes here<br/>
}<br/>
如果一个类有一个父类，之前它采用任何协议，后跟一个逗号列出超名称：</p>

<p>class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {<br/>
    // class definition goes here<br/>
}<br/>
性能要求</p>

<p>协议可以要求任何符合类型提供一个实例属性或具有特定名称和类型的类型属性。该协议不指定属性是否应该是一个存储的属性或计算的财产，只指定需要的属性名称和类型。该协议还规定每个属性是否必须是或的GetTable的GetTable 和设定。</p>

<p>如果协议需要一个属性为的GetTable和硬性，该属性要求不能由一个恒定存储属性或一个只读计算属性满足。如果协议只需要一个属性为的GetTable，要求可以通过任何种类的财产来满足，这是有效的财产是还可以设置，如果这是你自己的代码很有用。</p>

<p>性能要求总是声明为变量属性，前面带var关键字。和的GetTable可设置的属性可以通过写入表示{ get set }其类型声明之后，和性能的GetTable通过写入表示{ get }。</p>

<p>protocol SomeProtocol {<br/>
    var mustBeSettable: Int { get set }<br/>
    var doesNotNeedToBeSettable: Int { get }<br/>
}<br/>
始终前缀类型性能要求的static，当你在一个协议定义它们的关键字。此规则适用即使type属性的要求可以用前缀class或者static当由类实现关键字：</p>

<p>protocol AnotherProtocol {<br/>
    static var someTypeProperty: Int { get set }<br/>
}<br/>
这里用一个实例属性要求的协议的一个例子：</p>

<p>protocol FullyNamed {<br/>
    var fullName: String { get }<br/>
}<br/>
该FullyNamed协议需要符合的类型提供一个完全合格的名称。协议不指定任何其他有关符合要求的性质类型-它仅指定该类型必须能够为自己提供一个全名。该协议规定，任何FullyNamed类型必须有一个叫做实例的GetTable属性fullName，它的类型的String。</p>

<p>这里有一个简单的结构，采用和符合的例子FullyNamed协议：</p>

<p>struct Person: FullyNamed {<br/>
    var fullName: String<br/>
}<br/>
let john = Person(fullName: <q>John Appleseed</q>)<br/>
// john.fullName is <q>John Appleseed</q><br/>
这个例子定义了一个名为结构Person，它代表一个特定的命名人。它指出它采用FullyNamed协议作为它的定义的第一线的一部分。</p>

<p>的每个实例Person有一个单一的存储的属性称为fullName，这是类型String。这个模式匹配的单一要求FullyNamed的协议，这意味着Person已经正确地顺应了协议。（如果协议要求未满足斯威夫特报道编译时错误。）</p>

<p>下面是一个更复杂的类，它也采用了和符合FullyNamed协议：</p>

<p>class Starship: FullyNamed {<br/>
    var prefix: String?<br/>
    var name: String<br/>
    init(name: String, prefix: String? = nil) {<br/>
        self.name = name<br/>
        self.prefix = prefix<br/>
    }<br/>
    var fullName: String {<br/>
        return (prefix != nil ? prefix! + &quot; <q>:</q><q>) + name<br/>
    }<br/>
}<br/>
var ncc1701 = Starship(name:</q>Enterprise<q>, prefix:</q>USS<q>)<br/>
// ncc1701.fullName is</q>USS Enterprise&quot;<br/>
这个类实现了fullName性能要求作为计算的只读属性的飞船。每个Starship类实例存储的强制性name和可选prefix。该fullName属性使用prefix值，如果它存在，并且它预先考虑到年初name，为飞船创建一个全名。</p>

<p>方法要求</p>

<p>协议可能需要具体实例方法和类方法由符合类型实现。这些方法被写为在完全相同的方式，作为正常实例和类型的方法的协议的定义的一部分，但没有大括号或方法体。可变参数参数是允许的，受到同样的规则进行正常的方法。默认值，但是，不能对方法参数的协议的定义中指定的。</p>

<p>正如type属性的要求，你总是有前缀的类型的方法要求static，当他们在协议中定义的关键字。即使类型的方法要求用前缀这是真的class还是static当由类实现关键字：</p>

<p>protocol SomeProtocol {<br/>
    static func someTypeMethod()<br/>
}<br/>
下面的例子定义了一个实例方法要求的协议：</p>

<p>protocol RandomNumberGenerator {<br/>
    func random() -&gt; Double<br/>
}<br/>
该协议RandomNumberGenerator，规定任何符合类型有称为实例方法random，它返回Double时，它被称为价值。虽然它没有被指定作为协议的一部分，它假设该值将是从许多0.0最多（但不包括）1.0。</p>

<p>该RandomNumberGenerator协议不做出 ​​关于如何每个随机数将被任何假设产生-它仅仅需要发电机提供一种标准的方式来产生一个新的随机数。</p>

<p>下面是采用并符合一类的实现RandomNumberGenerator协议。此类实现所谓的伪随机数生成器算法线性同余方法：</p>

<p>class LinearCongruentialGenerator: RandomNumberGenerator {<br/>
    var lastRandom = 42.0<br/>
    let m = 139968.0<br/>
    let a = 3877.0<br/>
    let c = 29573.0<br/>
    func random() -&gt; Double {<br/>
        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))<br/>
        return lastRandom / m<br/>
    }<br/>
}<br/>
let generator = LinearCongruentialGenerator()<br/>
print(<q>Here&#39;s a random number: (generator.random())</q>)<br/>
// Prints <q>Here&#39;s a random number: 0.37464991998171</q><br/>
print(<q>And another one: (generator.random())</q>)<br/>
// Prints <q>And another one: 0.729023776863283</q><br/>
不同诱变方法要求</p>

<p>有时需要一种方法来修改（或突变）所属的实例。对值类型的实例方法（即，结构和枚举）放置的mutating关键字的方法的概况func的关键字，以指示该方法允许修改它所属的实例和实例的任何属性。这个过程是在描述从在实例方法修改值类型。</p>

<p>如果定义，旨在变异的任何类型的采用协议实例的协议实例方法的要求，标志着与方法mutating关键字作为协议定义的一部分。这使得结构和枚举采用协议和满足这种方法的要求。</p>

<p>注意</p>

<p>如果标记协议实例方法要求的mutating，你不需要写mutating编写一类方法的实现时，关键字。该mutating关键字仅用于结构和枚举。</p>

<p>下面的例子定义了一个所谓的协议Togglable，它定义称为单实例方法的要求toggle。顾名思义，该toggle()法的目的是通常通过修改类型的属性来切换或反转符合要求的任何类型的状态。</p>

<p>该toggle()方法是标有mutating关键字作为部分Togglable协议定义，以指示该方法有望变异相符的实例的状态时，它被称为：</p>

<p>protocol Togglable {<br/>
    mutating func toggle()<br/>
}<br/>
如果实现了Togglable一个结构或枚举协议，该结构或枚举可以通过提供的实现符合协议toggle()，它也被标记为方法mutating。</p>

<p>下面的例子定义了一个枚举OnOffSwitch。两种状态，由枚举表示案件之间的列举切换on和off。枚举的toggle实施被标记为mutating，以匹配Togglable协议的要求：</p>

<p>enum OnOffSwitch: Togglable {<br/>
    case off, on<br/>
    mutating func toggle() {<br/>
        switch self {<br/>
        case .off:<br/>
            self = .on<br/>
        case .on:<br/>
            self = .off<br/>
        }<br/>
    }<br/>
}<br/>
var lightSwitch = OnOffSwitch.off<br/>
lightSwitch.toggle()<br/>
// lightSwitch is now equal to .on<br/>
初始化要求</p>

<p>协议可以要求通过符合类型实现特定的初始化。你写这些初始化在完全相同的方式为正常初始化协议定义的一部分，但没有花括号或初始化体：</p>

<p>protocol SomeProtocol {<br/>
    init(someParameter: Int)<br/>
}<br/>
协议初始化程序要求的类实现</p>

<p>您可以实现对符合要求的类无论是作为指定初始化或初始化方便的协议初始化要求。在这两种情况下，你必须标记的初始化执行required修改：</p>

<p>class SomeClass: SomeProtocol {<br/>
    required init(someParameter: Int) {<br/>
        // initializer implementation goes here<br/>
    }<br/>
}<br/>
使用的required修饰符确保您提供一个明确的或继承的实施对符合要求的类的子类，初始化的要求，这样他们也遵守协议。</p>

<p>有关所需的初始化的更多信息，请参阅所需的初始化。</p>

<p>注意</p>

<p>你并不需要标记协议初始化实现与required上标有类修改final修改，因为最终的类不能被继承。欲了解更多关于final修改，请参阅防止覆盖。</p>

<p>如果一个子类覆盖从超类的指定初始化，并且还实现了从协议的匹配初始化要求，标志着与两个初始化实施required和override修改器：</p>

<p>protocol SomeProtocol {<br/>
    init()<br/>
}</p>

<p>class SomeSuperClass {<br/>
    init() {<br/>
        // initializer implementation goes here<br/>
    }<br/>
}</p>

<p>class SomeSubClass: SomeSuperClass, SomeProtocol {<br/>
    // <q>required</q> from SomeProtocol conformance; <q>override</q> from SomeSuperClass<br/>
    required override init() {<br/>
        // initializer implementation goes here<br/>
    }<br/>
}<br/>
Failable初始化程序要求</p>

<p>协议可以定义failable初始化要求符合类型，定义Failable初始化器。</p>

<p>一个failable初始化要求可以通过在符合要求的类型failable或nonfailable初始化来满足。一个nonfailable初始化要求可以由nonfailable初始化或隐含解开failable初始化来满足。</p>

<p>作为协议的类型</p>

<p>协议实际上没有实现任何功能本身。但是，您创建的任何协议将成为一个不折不扣的类型，在代码中使用。</p>

<p>因为它是一个类型，可以使用在许多地方，其他类型都是允许的，包括协议：</p>

<p>作为一个函数，方法或初始化参数类型或返回类型<br/>
作为常量，变量或属性的类型<br/>
如项目阵列中的，字典，或其他容器的类型<br/>
注意</p>

<p>由于协议的类型，开始他们的名称以大写字母（如FullyNamed和RandomNumberGenerator）来匹配其他类型的雨燕的名称（例如Int，String和Double）。</p>

<p>这里是作为一个类型的协议的一个例子：</p>

<p>class Dice {<br/>
    let sides: Int<br/>
    let generator: RandomNumberGenerator<br/>
    init(sides: Int, generator: RandomNumberGenerator) {<br/>
        self.sides = sides<br/>
        self.generator = generator<br/>
    }<br/>
    func roll() -&gt; Int {<br/>
        return Int(generator.random() * Double(sides)) + 1<br/>
    }<br/>
}<br/>
本实施例定义了一个名为新类Dice，它代表一个Ñ -sided骰子在棋盘游戏使用。Dice实例有所谓的整数属性sides，它表示多少面他们，和一个称为属性generator，它提供了一个随机数发生器从该创建骰子值。</p>

<p>该generator属性的类型的RandomNumberGenerator。因此，您可以将其设置为实例的类型采用RandomNumberGenerator的协议。没有别的需要分配给该属性的实例，除了实例必须采取RandomNumberGenerator协议。</p>

<p>Dice也有一个初始化，设置它的初始状态。这个初始化有一个名为参数generator，这也是类型RandomNumberGenerator。初始化一个新的时，您可以通过任何符合要求的类型的值，该参数Dice的实例。</p>

<p>Dice提供了一个实例方法roll，返回和1之间的整数值两侧的骰子的数量。此方法调用生成的random()方法之间创建一个新的随机数0.0和1.0，并使用该随机数以创建正确的范围内的骰子值。因为generator众所周知采纳RandomNumberGenerator，这是保证有一个random()调用方法。</p>

<p>下面是如何Dice类可用于创建具有六面的骰子LinearCongruentialGenerator实例作为其随机数生成器：</p>

<p>var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())<br/>
for _ in 1...5 {<br/>
    print(<q>Random dice roll is (d6.roll())</q>)<br/>
}<br/>
// Random dice roll is 3<br/>
// Random dice roll is 5<br/>
// Random dice roll is 4<br/>
// Random dice roll is 5<br/>
// Random dice roll is 4<br/>
代表团</p>

<p>团是一个设计图案，使一类或结构手工关闭（或代表）它的某些职责为另一种类型的一个实例。这种设计模式是通过定义封装委派职责，使得符合要求的类型（被称为代表）保证提供已委派功能的协议来实现。团可以用一个特定的动作做出响应，或者无需知道底层类型源的检索来自外部源的数据。</p>

<p>下面的例子定义了基于骰子，棋盘游戏使用两个协议：</p>

<p>protocol DiceGame {<br/>
    var dice: Dice { get }<br/>
    func play()<br/>
}<br/>
protocol DiceGameDelegate {<br/>
    func gameDidStart(_ game: DiceGame)<br/>
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)<br/>
    func gameDidEnd(_ game: DiceGame)<br/>
}<br/>
该DiceGame协议是可以由涉及骰子任何游戏可以采用的一个协议。该DiceGameDelegate协议可以由任何类型的可通过跟踪的一个进展DiceGame。</p>

<p>这里有一个版本的蛇和梯子最初在推出游戏控制流。这个版本是适于使用Dice对于其骰子贴片实例; 采用DiceGame协议; 并通知DiceGameDelegate有关它的进展：</p>

<p>class SnakesAndLadders: DiceGame {<br/>
    let finalSquare = 25<br/>
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())<br/>
    var square = 0<br/>
    var board: [Int]<br/>
    init() {<br/>
        board = Array(repeating: 0, count: finalSquare + 1)<br/>
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br/>
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br/>
    }<br/>
    var delegate: DiceGameDelegate?<br/>
    func play() {<br/>
        square = 0<br/>
        delegate?.gameDidStart(self)<br/>
        gameLoop: while square != finalSquare {<br/>
            let diceRoll = dice.roll()<br/>
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)<br/>
            switch square + diceRoll {<br/>
            case finalSquare:<br/>
                break gameLoop<br/>
            case let newSquare where newSquare &gt; finalSquare:<br/>
                continue gameLoop<br/>
            default:<br/>
                square += diceRoll<br/>
                square += board[square]<br/>
            }<br/>
        }<br/>
        delegate?.gameDidEnd(self)<br/>
    }<br/>
}<br/>
有关的描述蛇和梯子的游戏，看到断裂的部分控制流。</p>

<p>这个版本的游戏被包裹起来作为一个叫做类SnakesAndLadders，即采用DiceGame协议。它提供了一个的GetTable dice属性和play()以符合协议的方法。（该dice属性声明为恒定属性，因为它不需要初始化之后改变，并且协议只要求它的GetTable）。</p>

<p>该蛇和梯子游戏板的设置采用类的范围内进行init()初始化。所有的游戏逻辑移动到该协议的play方法，它使用的协议的要求dice物业提供的骰子值。</p>

<p>请注意，delegate属性定义为一个可选的 DiceGameDelegate，因为为了玩游戏不需要委托。因为它是一个可选的类型的，所述delegate属性被自动设置为一个初始值nil。此后，游戏初始化程序具有的属性设置为合适的委托人的选项。</p>

<p>DiceGameDelegate提供了用于跟踪一个游戏的进行三种方法。这三种方法都被纳入游戏逻辑的内play()上述方法，当一个新的游戏开始，一个新的转折的开始，或者游戏结束时调用。</p>

<p>由于该delegate属性是可选的 DiceGameDelegate，该play()方法使用可选的每 ​​次调用委托方法的时间链。如果delegate属性是零，这些委托调用失败优雅，没有错误。如果delegate财产是非零，委托方法被调用，并通过SnakesAndLadders实例作为参数。</p>

<p>下一个示例展示了一个名为类DiceGameTracker，即采用DiceGameDelegate协议：</p>

<p>class DiceGameTracker: DiceGameDelegate {<br/>
    var numberOfTurns = 0<br/>
    func gameDidStart(_ game: DiceGame) {<br/>
        numberOfTurns = 0<br/>
        if game is SnakesAndLadders {<br/>
            print(<q>Started a new game of Snakes and Ladders</q>)<br/>
        }<br/>
        print(<q>The game is using a (game.dice.sides)-sided dice</q>)<br/>
    }<br/>
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {<br/>
        numberOfTurns += 1<br/>
        print(<q>Rolled a (diceRoll)</q>)<br/>
    }<br/>
    func gameDidEnd(_ game: DiceGame) {<br/>
        print(<q>The game lasted for (numberOfTurns) turns</q>)<br/>
    }<br/>
}<br/>
DiceGameTracker实现所要求的所有三种方法DiceGameDelegate。它使用这些方法来跟踪匝游戏已采取的数目。它重置一个numberOfTurns，当比赛开始，每一个新的转折开始的时间增加了，并打印出的圈总数一旦比赛结束属性设置为零。</p>

<p>实施gameDidStart(<u>:)上述使用game参数打印有关的游戏，是要被打了一些介绍性信息。该game参数有一个类型的DiceGame，不是SnakesAndLadders，所以gameDidStart(</u>:)可以访问和使用仅方法和实施作为的一部分性质DiceGame的协议。然而，该方法仍然能够使用型铸造来查询底层的实例的类型。在这个例子中，它检查是否game实际上是一个实例SnakesAndLadders幕后，如果这样将输出适当的消息。</p>

<p>该gameDidStart(<u>:)方法还访问dice传递的财产game参数。因为game众所周知，符合DiceGame协议，它是保证有一个dice属性，所以gameDidStart(</u>:)方法能够访问和打印骰子的sides财产，不管正在播放什么样的游戏。</p>

<p>下面是如何DiceGameTracker在行动的样子：</p>

<p>let tracker = DiceGameTracker()<br/>
let game = SnakesAndLadders()<br/>
game.delegate = tracker<br/>
game.play()<br/>
// Started a new game of Snakes and Ladders<br/>
// The game is using a 6-sided dice<br/>
// Rolled a 3<br/>
// Rolled a 5<br/>
// Rolled a 4<br/>
// Rolled a 5<br/>
// The game lasted for 4 turns<br/>
添加协议一致性与扩展</p>

<p>可以扩展现有类型采取和符合新的协议，即使没有访问到的源代码的现有类型。扩展可以添加新的属性，方法和标到现有的类型，因此能够添加一个协议可能要求的任何要求。欲了解更多有关扩展，见扩展。</p>

<p>注意</p>

<p>一种类型的现有实例自动采取并且当该一致性被添加到实例的在扩​​展型符合的协议。</p>

<p>例如，该协议中，称为TextRepresentable，可以由具有对被表示为文本的方式的任何类型来实施。这可能是它自己的描述，或者它的当前状态的文本版本：</p>

<p>protocol TextRepresentable {<br/>
    var textualDescription: String { get }<br/>
}<br/>
在Dice从早期类可以延伸到采用并符合TextRepresentable：</p>

<p>extension Dice: TextRepresentable {<br/>
    var textualDescription: String {<br/>
        return <q>A (sides)-sided dice</q><br/>
    }<br/>
}<br/>
此扩展采用完全相同的方式，新的协议，如果Dice已经在其最初的实现提供它。协议的名称类型名称之后提供的，由冒号分隔，而该协议的所有要求的实现，则扩展的大括号内。</p>

<p>任何Dice实例现在可以视为TextRepresentable：</p>

<p>let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())<br/>
print(d12.textualDescription)<br/>
// Prints <q>A 12-sided dice</q><br/>
类似地，SnakesAndLadders游戏类可以扩展到通过和符合TextRepresentable协议：</p>

<p>extension SnakesAndLadders: TextRepresentable {<br/>
    var textualDescription: String {<br/>
        return <q>A game of Snakes and Ladders with (finalSquare) squares</q><br/>
    }<br/>
}<br/>
print(game.textualDescription)<br/>
// Prints <q>A game of Snakes and Ladders with 25 squares</q><br/>
声明协议采用与扩展</p>

<p>如果一个类型已符合所有的协议的要求，但尚未阐明，它采用了该协议，你可以把它采用协议与一个空的扩展：</p>

<p>struct Hamster {<br/>
    var name: String<br/>
    var textualDescription: String {<br/>
        return <q>A hamster named (name)</q><br/>
    }<br/>
}<br/>
extension Hamster: TextRepresentable {}<br/>
的实例Hamster，现在可以用于任何TextRepresentable是所需类型：</p>

<p>let simonTheHamster = Hamster(name: <q>Simon</q>)<br/>
let somethingTextRepresentable: TextRepresentable = simonTheHamster<br/>
print(somethingTextRepresentable.textualDescription)<br/>
// Prints <q>A hamster named Simon</q><br/>
注意</p>

<p>类型不会自动只是满足它的要求采取协议。他们总是必须明确地声明其通过议定书。</p>

<p>协议类型的集合</p>

<p>可使用的协议的类型被存储在集合中诸如数组或字典，如提到的协议作为类型。这个例子创建数组TextRepresentable的东西：</p>

<p>let things: [TextRepresentable] = [game, d12, simonTheHamster]<br/>
现在可以遍历数组中的项目，并打印每个项目的文字描述：</p>

<p>for thing in things {<br/>
    print(thing.textualDescription)<br/>
}<br/>
// A game of Snakes and Ladders with 25 squares<br/>
// A 12-sided dice<br/>
// A hamster named Simon<br/>
需要注意的是thing常量是类型TextRepresentable。它不是类型的Dice，或者DiceGame，或者Hamster，即使在幕后实际的实例是那些类型之一。然而，因为它是类型的TextRepresentable，并且是任何TextRepresentable已知具有一个textualDescription属性，它是安全的访问thing.textualDescription通过每次循环。</p>

<p>协议继承</p>

<p>协议可以继承一个或多个其他协议，并可对继承的要求顶部添加进一步的要求。对于协议继承语法类似于语法类继承，但与选项列出多个继承协议，以逗号分隔：</p>

<p>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {<br/>
    // protocol definition goes here<br/>
}<br/>
下面是继承的协议的例子TextRepresentable从上面的协议：</p>

<p>protocol PrettyTextRepresentable: TextRepresentable {<br/>
    var prettyTextualDescription: String { get }<br/>
}<br/>
这个例子定义了一个新的协议，PrettyTextRepresentable，从继承TextRepresentable。凡是采用PrettyTextRepresentable必须满足所有由强制的要求TextRepresentable，再加上由执行的附加 ​​要求PrettyTextRepresentable。在这个例子中，PrettyTextRepresentable增加了一个单一的要求，以提供被称为的GetTable属性prettyTextualDescription返回一个String。</p>

<p>的SnakesAndLadders类可以扩展到通过并符合PrettyTextRepresentable：</p>

<p>extension SnakesAndLadders: PrettyTextRepresentable {<br/>
    var prettyTextualDescription: String {<br/>
        var output = textualDescription + <q>:\n</q><br/>
        for index in 1...finalSquare {<br/>
            switch board[index] {<br/>
            case let ladder where ladder &gt; 0:<br/>
                output += <q>▲</q><br/>
            case let snake where snake &lt; 0:<br/>
                output += <q>▼</q><br/>
            default:<br/>
                output += <q>○</q><br/>
            }<br/>
        }<br/>
        return output<br/>
    }<br/>
}<br/>
此扩展说，它采用了PrettyTextRepresentable协议和提供的实施prettyTextualDescription属性的SnakesAndLadders类型。凡是是PrettyTextRepresentable也必须TextRepresentable等实施prettyTextualDescription开始通过访问textualDescription从财产TextRepresentable协议，开始输出字符串。它附加一个冒号和一个换行符，并使用此作为其漂亮的文字表示的开始。然后，它通过主板平方的阵列迭代，并附加几何形状来表示每平方米的内容：</p>

<p>如果正方形的值大于0，它是一个阶梯的基础上，和由下式表示▲。<br/>
如果正方形的值小于0，这是一条蛇的头部，并通过代表▼。<br/>
否则，广场的价值是0，它是一个“自由”广场为代表○。<br/>
该prettyTextualDescription物业现在可以印上任何一个漂亮的文字说明SnakesAndLadders的实例：</p>

<p>print(game.prettyTextualDescription)<br/>
// A game of Snakes and Ladders with 25 squares:<br/>
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○<br/>
类只有协议</p>

<p>您可以通过添加限制协议领养类类型（而不是结构或枚举）class关键字到协议的继承列表。该class关键字必须首先出现在协议的继承列表，在此之前任何继承协议：</p>

<p>protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {<br/>
    // class-only protocol definition goes here<br/>
}<br/>
在上面的例子中，SomeClassOnlyProtocol只能由类类型通过。这是写试图采用这样的结构或枚举定义一个编译时错误SomeClassOnlyProtocol。</p>

<p>注意</p>

<p>当该协议的要求定义的行为假设或要求一个符合要求的类型有引用语义，而不是值语义使用唯一一类的协议。欲了解更多有关的参考和值语义，请参阅结构和枚举是值类型和类是引用类型。</p>

<p>协议组合</p>

<p>它可以是有用的，要求一个类型在一次以符合多个协议。您可以将多个协议与一个单一要求的协议组成。协议组合物的形式SomeProtocol &amp; AnotherProtocol。因为你需要，你可以列出许多协议，由＆符号将它们分开（&amp;）。</p>

<p>下面是结合了两种协议被调用的例子Named，并Aged插入一个函数参数有关的协议组成的要求：</p>

<p>protocol Named {<br/>
    var name: String { get }<br/>
}<br/>
protocol Aged {<br/>
    var age: Int { get }<br/>
}<br/>
struct Person: Named, Aged {<br/>
    var name: String<br/>
    var age: Int<br/>
}<br/>
func wishHappyBirthday(to celebrator: Named &amp; Aged) {<br/>
    print(<q>Happy birthday, (celebrator.name), you&#39;re (celebrator.age)!</q>)<br/>
}<br/>
let birthdayPerson = Person(name: <q>Malcolm</q>, age: 21)<br/>
wishHappyBirthday(to: birthdayPerson)<br/>
// Prints <q>Happy birthday, Malcolm, you&#39;re 21!</q><br/>
这个例子定义了一个所谓的协议Named，与一个一个的GetTable单个需求String称为财产name。它还定义了所谓的协议Aged，与一个一个的GetTable单个需求Int称为财产age。这两个协议都被称为结构采用Person。</p>

<p>本例还定义了一个wishHappyBirthday(to:)函数，该类型的celebrator参数是Named &amp; Aged，这意味着“符合两个任何类型Named和Aged不要紧什么具体类型传递给函数，只要它符合两个协议。”要求的协议。</p>

<p>然后，该示例创建一个新的Person称为实例birthdayPerson并将这个新的实例的wishHappyBirthday(to:)功能。由于Person符合两国的协议，这是一个有效的呼叫，而且wishHappyBirthday(to:)功能能够打印出它的生日的祝福。</p>

<p>注意</p>

<p>协议的组合物不定义一个新的，永久性的协议类型。相反，他们定义具有的在组合物中的所有协议的综合要求的临时本地协议。</p>

<p>检查协议一致性</p>

<p>您可以使用is，并as描述运营商类型转换检查协 ​​议一致性，并转换为特定的协议。检查和强制转换为协议遵循完全相同的语法检查和强制转换为类型：</p>

<p>该is运算符返回true某个实例是否符合协议，并返回false，如果它不。<br/>
该as?丧气运营商的版本，返回该协议的类型的可选值，这个值nil如果实例不符合该协议。<br/>
该as!丧气运营商的版本迫使垂头丧气的协议类型，并触发一个运行时错误，如果低垂不会成功。<br/>
这个例子定义了一个名为协议HasArea，具有中的GetTable一个属性要求Double所谓财产area：</p>

<p>protocol HasArea {<br/>
    var area: Double { get }<br/>
}<br/>
这里有两个类，Circle并且Country，这两者都符合HasArea协议：</p>

<p>class Circle: HasArea {<br/>
    let pi = 3.1415927<br/>
    var radius: Double<br/>
    var area: Double { return pi * radius * radius }<br/>
    init(radius: Double) { self.radius = radius }<br/>
}<br/>
class Country: HasArea {<br/>
    var area: Double<br/>
    init(area: Double) { self.area = area }<br/>
}<br/>
本Circle类实现了area性能要求作为一个计算性能，基于存储radius属性。本Country类实现了area直接要求作为存储的属性。这两个类正确顺应HasArea协议。</p>

<p>这里有一个叫做类Animal，它不符合HasArea协议：</p>

<p>class Animal {<br/>
    var legs: Int<br/>
    init(legs: Int) { self.legs = legs }<br/>
}<br/>
的Circle，Country而Animal类没有共享的基类。尽管如此，它们是所有的类，所以所有三种类型的实例可以用于初始化存储类型的值的数组AnyObject：</p>

<p>let objects: [AnyObject] = [<br/>
    Circle(radius: 2.0),<br/>
    Country(area: 243_610),<br/>
    Animal(legs: 4)<br/>
]<br/>
该objects数组初始化为常量，其中包含一个数组Circle用2个单位半径实例; 一个Country与英国平方公里的面积初始化实例; 和一个Animal有四条腿的实例。</p>

<p>的objects阵列现在可以重复，并且阵列中的每个对象都可以被检查，看它是否符合HasArea协议：</p>

<p>for object in objects {<br/>
    if let objectWithArea = object as? HasArea {<br/>
        print(<q>Area is (objectWithArea.area)</q>)<br/>
    } else {<br/>
        print(<q>Something that doesn&#39;t have an area</q>)<br/>
    }<br/>
}<br/>
// Area is 12.5663708<br/>
// Area is 243610.0<br/>
// Something that doesn&#39;t have an area<br/>
每当阵列中的对象符合HasArea协议，由返回的可选值as?算解开具有可选绑定到一个名为不变objectWithArea。该objectWithArea常数是已知的类型HasArea，因此它的area特性可被访问，并在一个类型安全的方式打印。</p>

<p>需要注意的是底层对象不被铸造过程改变。他们继续是一个Circle，一Country和Animal。然而，在它们被存储在该点objectWithArea常数，它们仅已知类型的HasArea，因此只有它们的area可被访问属性。</p>

<p>任择议定书要求</p>

<p>可以定义可选的要求对协议 ​​，这些要求不必由符合该协议类型来实现。可选要求由前缀optional改性剂作为协议的定义的一部分。可选的要求都可以让你可以编写与Objective-C的互操作代码。无论是协议和强制性要求必须标注的@objc属性。请注意，@objc协议只能通过从Objective-C类或者其他类的继承采用@objc的类。他们无法通过结构或枚举通过。</p>

<p>当您在选购要求使用方法或属性，它的类型自动成为可选的。例如，类型的方法(Int) -&gt; String变成((Int) -&gt; String)?。需要注意的是全功能型被包裹在选购的，而不是方法的返回值。</p>

<p>一个可选的协议要求可以具有可选链接调用，以考虑该要求没有被符合该协议的类型实现的可能性。可以通过该方法的名字后面写一个问号，当它被调用时，如检查可选方法的实施someOptionalMethod?(someArgument)。有关可选链接的信息，请参阅可选链接。</p>

<p>下面的例子定义了一个整数计数类Counter，它使用外部数据源提供其增加额。此数据源被定义CounterDataSource协议，该协议有两个可选要求：</p>

<p>@objc protocol CounterDataSource {<br/>
    @objc optional func increment(forCount count: Int) -&gt; Int<br/>
    @objc optional var fixedIncrement: Int { get }<br/>
}<br/>
该CounterDataSource协议定义称为一种可选方法的要求increment(forCount:)，并要求一个可选的性能要求fixedIncrement。这些要求定义数据源为一提供一个适当的增加幅度两种不同方式Counter的实例。</p>

<p>注意</p>

<p>严格地说，您可以编写符合自定义类CounterDataSource没有实现任何协议的要求。它们都是可选的，毕竟。虽然技术上允许的，这不会使一个很好的数据源。</p>

<p>该Counter级，定义如下，有一个可选的dataSource属性类型CounterDataSource?：</p>

<p>class Counter {<br/>
    var count = 0<br/>
    var dataSource: CounterDataSource?<br/>
    func increment() {<br/>
        if let amount = dataSource?.increment?(forCount: count) {<br/>
            count += amount<br/>
        } else if let amount = dataSource?.fixedIncrement {<br/>
            count += amount<br/>
        }<br/>
    }<br/>
}<br/>
在Counter类存储在一个名为变量属性的当前值count。本Counter类还定义了一个名为方法increment，其递增count每次调用该方法时财产。</p>

<p>该increment()方法首先尝试通过寻找的实施方案来检索的增量量increment(forCount:)它的数据源上的方法。该increment()方法使用可选的链接来尝试调用increment(forCount:)，并传递电流count值作为方法的一个参数。</p>

<p>需要注意的是2可选链接的水平是在这里打球。首先，它是可能的dataSource可能nil，因此dataSource有其名称后一个问号，以指示incrementForCount(forCount:)仅当应该叫dataSource不是nil。第二，即使不存在，但不保证它实现，因为它是一个可选的要求。这里，该可能性可能不能实施也由可选链接处理。调用发生仅当存在，也就是说，如果它不是。这是为什么也与它的名称后一个问号写入。 dataSource incrementForCount(forCount:)incrementForCount(forCount:)incrementForCount(forCount:)incrementForCount(forCount:)nilincrementForCount(forCount:)</p>

<p>因为调用incrementForCount(forCount:)失败有以下两种原因，调用将返回一个可选 Int值。这是真实的，即使incrementForCount(forCount:)被定义为返回一个非可选Int的定义中值CounterDataSource。即使有两个可选的链接操作，一个又一个，结果还裹着一个可选的。有关使用多个可选链接操作，详细信息请参阅链接链的多层次性。</p>

<p>打完电话后increment(forCount:)，可选的Int，它返回的是解开到一个名为不变amount，使用可选的绑定。如果可选Int确实包含价值-也就是说，如果委托和方法都存在，并且该方法返回一个值，未包装的amount加入到存储的count属性，而增量就完成了。</p>

<p>如果它是不能够检索来自一个值increment(forCount:)的方法，或者是因为dataSource是nil，或者因为数据源不实现increment(forCount:)-然后该increment()方法试图检索来自数据源的一个值fixedIncrement属性。该fixedIncrement属性也可选的要求，所以它的值是可选的Int值，即使fixedIncrement被定义为一个非可选Int属性作为一部分CounterDataSource协议定义。</p>

<p>下面是一个简单CounterDataSource的实现，其中的数据源返回一个恒定值3每次查询的时间。它通过实施可选的fixedIncrement性能要求：</p>

<p>class ThreeSource: NSObject, CounterDataSource {<br/>
    let fixedIncrement = 3<br/>
}<br/>
您可以使用的一个实例ThreeSource，作为一个新的数据源Counter的实例：</p>

<p>var counter = Counter()<br/>
counter.dataSource = ThreeSource()<br/>
for _ in 1...4 {<br/>
    counter.increment()<br/>
    print(counter.count)<br/>
}<br/>
// 3<br/>
// 6<br/>
// 9<br/>
// 12<br/>
上面的代码创建一个新的Counter实例; 设置其数据源是一个新的ThreeSource实例; 并调用计数器的increment()方法四倍。正如预期的那样，计数器的count财产每次加三级increment()被调用。</p>

<p>这里的所谓一个更复杂的数据源TowardsZeroSource，这使得一个Counter实例，从目前的向上或向下计数向零count值：</p>

<p>@objc class TowardsZeroSource: NSObject, CounterDataSource {<br/>
    func increment(forCount count: Int) -&gt; Int {<br/>
        if count == 0 {<br/>
            return 0<br/>
        } else if count &lt; 0 {<br/>
            return 1<br/>
        } else {<br/>
            return -1<br/>
        }<br/>
    }<br/>
}<br/>
本TowardsZeroSource类实现了可选的increment(forCount:)从方法CounterDataSource的协议，并使用count参数值制定出在计数的方向。如果count已经是零，则该方法返回0到表示没有进一步的计算应该发生。</p>

<p>您可以使用一个实例的TowardsZeroSource与现有的Counter实例，从数-4为零。一旦计数器达到零，没有更多的计数发生：</p>

<p>counter.count = -4<br/>
counter.dataSource = TowardsZeroSource()<br/>
for _ in 1...5 {<br/>
    counter.increment()<br/>
    print(counter.count)<br/>
}<br/>
// -3<br/>
// -2<br/>
// -1<br/>
// 0<br/>
// 0<br/>
协议扩展</p>

<p>协议可以扩展到提供的方法和属性实现，以符合类型。这使您可以在协议规定的行为本身，而不是在每一种类型的个性化的一致性或全局函数。</p>

<p>例如，该RandomNumberGenerator协议可以扩展到提供一种randomBool()方法，它使用了所需的结果random()的方法以返回一个随机Bool值：</p>

<p>extension RandomNumberGenerator {<br/>
    func randomBool() -&gt; Bool {<br/>
        return random() &gt; 0.5<br/>
    }<br/>
}<br/>
通过创建对协议的延伸，所有符合标准的类型自动获得无需任何额外的修改此方法实现。</p>

<p>let generator = LinearCongruentialGenerator()<br/>
print(<q>Here&#39;s a random number: (generator.random())</q>)<br/>
// Prints <q>Here&#39;s a random number: 0.37464991998171</q><br/>
print(<q>And here&#39;s a random Boolean: (generator.randomBool())</q>)<br/>
// Prints <q>And here&#39;s a random Boolean: true</q><br/>
提供了默认的实现</p>

<p>您可以使用协议扩展提供了默认实现该协议的任何方法或计算的性能要求。如果相符的类型提供其自己的执行所需的方法或财产的，即实现将被用来代替由扩展中提供的。</p>

<p>注意</p>

<p>通过扩展提供了默认的实现协议要求从任择议定书的要求是不同的。虽然符合类型没有提供自己的实现任，用默认的实现要求可以称为不可选的链接。</p>

<p>例如，PrettyTextRepresentable协议，它继承了TextRepresentable协议，可以提供其所需的默认实现prettyTextualDescription属性来简单地返回访问结果textualDescription属性：</p>

<p>extension PrettyTextRepresentable  {<br/>
    var prettyTextualDescription: String {<br/>
        return textualDescription<br/>
    }<br/>
}<br/>
添加约束，以协议扩展</p>

<p>当你定义一个协议扩展，可以指定可扩展的方法和属性之前符合类型必须满足约束条件。你，你使用的是通用的延长协议的名称后写这些限制where条款，如描述的通用where子句。</p>

<p>例如，您可以定义的扩展，Collection适用于任何集合，其元素符合协议TextRepresentable从上面的例子协议。</p>

<p>extension Collection where Iterator.Element: TextRepresentable {<br/>
    var textualDescription: String {<br/>
        let itemsAsText = self.map { $0.textualDescription }<br/>
        return <q>[</q> + itemsAsText.joined(separator: <q>,</q>) + <q>]</q><br/>
    }<br/>
}<br/>
该textualDescription特性通过连接集合中的每个元素的文字表述成一个逗号分隔的列表，包含在括号返回整个集合的文本描述。</p>

<p>考虑Hamster从之前的结构，这符合TextRepresentable协议，和数组Hamster值：</p>

<p>let murrayTheHamster = Hamster(name: <q>Murray</q>)<br/>
let morganTheHamster = Hamster(name: <q>Morgan</q>)<br/>
let mauriceTheHamster = Hamster(name: <q>Maurice</q>)<br/>
let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]<br/>
由于Array符合Collection和数组元素符合TextRepresentable协议的阵列可以使用textualDescription属性来获取其内容的文字表述：</p>

<p>print(hamsters.textualDescription)<br/>
// Prints <q>[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]</q><br/>
注意</p>

<p>如果符合要求的类型满足为提供相同的方法或属性实现多约束扩展的要求，SWIFT将使用对应于最专业限制的执行情况。</p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743600183280.html"  title="Previous Post: 扩展">&laquo; 扩展</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743600461552.html" 
	        title="Next Post: 泛型">泛型 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743600314526.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
