<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  泛型 - Swift 3.0 自翻译 - 说了是村长
  
  </title>
 <meta name="description" content="说了是村长，Swift 3.0 中文版">
 <link href="atom.xml" rel="alternate" title="Swift 3.0 自翻译 - 说了是村长" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">Swift 3.0 自翻译 - 说了是村长</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Swift 3.0 自翻译 - 说了是村长</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>欢迎加入 Swift</label></li>

          
            <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
          
            <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>开发指南</label></li>

          
            <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
          
            <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
          
            <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
          
            <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
          
            <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
          
            <li><a title="功能" href="14743597582027.html">功能</a></li>
          
            <li><a title="关闭" href="14743597798199.html">关闭</a></li>
          
            <li><a title="枚举" href="14743597933965.html">枚举</a></li>
          
            <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
          
            <li><a title="属性" href="14743598294467.html">属性</a></li>
          
            <li><a title="方法" href="14743598422216.html">方法</a></li>
          
            <li><a title="下标" href="14743598556978.html">下标</a></li>
          
            <li><a title="继承" href="14743598699234.html">继承</a></li>
          
            <li><a title="初始化" href="14743599314901.html">初始化</a></li>
          
            <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
          
            <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
          
            <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
          
            <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
          
            <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
          
            <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
          
            <li><a title="扩展" href="14743600183280.html">扩展</a></li>
          
            <li><a title="协议" href="14743600314526.html">协议</a></li>
          
            <li><a title="泛型" href="14743600461552.html">泛型</a></li>
          
            <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
          
            <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
          

      
        <li class="divider"></li>
        <li><label>语法参考</label></li>

          
            <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
          
            <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
          
            <li><a title="类型" href="14743601607750.html">类型</a></li>
          
            <li><a title="表达式" href="14743601746767.html">表达式</a></li>
          
            <li><a title="声明" href="14743601868497.html">声明</a></li>
          
            <li><a title="声明" href="14743602139425.html">声明</a></li>
          
            <li><a title="属性" href="14743602336703.html">属性</a></li>
          
            <li><a title="模式" href="14743602627751.html">模式</a></li>
          
            <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
          
            <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>欢迎加入 Swift</span></li>
                        
                          <li><a title="关于 Swift" href="14743413991106.html">关于 Swift</a></li>
                        
                          <li><a title="Swift 之旅" href="14743413996803.html">Swift 之旅</a></li>
                        

                    
                      <li class="side-title"><span>开发指南</span></li>
                        
                          <li><a title="基础知识" href="14743596331025.html">基础知识</a></li>
                        
                          <li><a title="基础运算操作" href="14743596434163.html">基础运算操作</a></li>
                        
                          <li><a title="字符串和字符" href="14743596689452.html">字符串和字符</a></li>
                        
                          <li><a title="集合类型" href="14743596859367.html">集合类型</a></li>
                        
                          <li><a title="此篇以下未整理仅谷歌翻译" href="14743597355186.html">此篇以下未整理仅谷歌翻译</a></li>
                        
                          <li><a title="功能" href="14743597582027.html">功能</a></li>
                        
                          <li><a title="关闭" href="14743597798199.html">关闭</a></li>
                        
                          <li><a title="枚举" href="14743597933965.html">枚举</a></li>
                        
                          <li><a title="类和结构" href="14743598083496.html">类和结构</a></li>
                        
                          <li><a title="属性" href="14743598294467.html">属性</a></li>
                        
                          <li><a title="方法" href="14743598422216.html">方法</a></li>
                        
                          <li><a title="下标" href="14743598556978.html">下标</a></li>
                        
                          <li><a title="继承" href="14743598699234.html">继承</a></li>
                        
                          <li><a title="初始化" href="14743599314901.html">初始化</a></li>
                        
                          <li><a title="反初始化" href="14743599349637.html">反初始化</a></li>
                        
                          <li><a title="自动引用计数" href="14743599484388.html">自动引用计数</a></li>
                        
                          <li><a title="可选链接" href="14743599610249.html">可选链接</a></li>
                        
                          <li><a title="错误处理" href="14743599754782.html">错误处理</a></li>
                        
                          <li><a title="类型转换" href="14743599908626.html">类型转换</a></li>
                        
                          <li><a title="嵌套类型" href="14743600051579.html">嵌套类型</a></li>
                        
                          <li><a title="扩展" href="14743600183280.html">扩展</a></li>
                        
                          <li><a title="协议" href="14743600314526.html">协议</a></li>
                        
                          <li><a title="泛型" href="14743600461552.html">泛型</a></li>
                        
                          <li><a title="访问控制" href="14743600592705.html">访问控制</a></li>
                        
                          <li><a title="高级操作员" href="14743600739128.html">高级操作员</a></li>
                        

                    
                      <li class="side-title"><span>语法参考</span></li>
                        
                          <li><a title="关于语言参考" href="14743601362358.html">关于语言参考</a></li>
                        
                          <li><a title="词法结构" href="14743601580892.html">词法结构</a></li>
                        
                          <li><a title="类型" href="14743601607750.html">类型</a></li>
                        
                          <li><a title="表达式" href="14743601746767.html">表达式</a></li>
                        
                          <li><a title="声明" href="14743601868497.html">声明</a></li>
                        
                          <li><a title="声明" href="14743602139425.html">声明</a></li>
                        
                          <li><a title="属性" href="14743602336703.html">属性</a></li>
                        
                          <li><a title="模式" href="14743602627751.html">模式</a></li>
                        
                          <li><a title="泛型参数和参数" href="14743602774984.html">泛型参数和参数</a></li>
                        
                          <li><a title="语法摘要" href="14743602864403.html">语法摘要</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>泛型</h1>

<p>通用代码，使您能够编写灵活，可重复使用的功能和类型，可以与任何类型的工作，受您定义的要求。你可以写，避免重复，并表示在一个明确的，抽象的方式意图的代码。</p>

<p>泛型是斯威夫特的最强大的功能之一，很多雨燕标准库的建立与通用代码。事实上，你已经使用整个泛型语言指南，即使你没有意识到这一点。例如，斯威夫特Array和Dictionary类型都是泛型集合。您可以创建包含数组Int值，或者保存一个数组String值，或者确实可以在斯威夫特被创建的任何其他类型的数组。同样，您可以创建一个字典存储任何指定类型的值，并有上什么类型可以是没有任何限制。</p>

<p>泛型解决问题</p>

<p>这里的所谓标准，非通用功能swapTwoInts(<u>:</u>:)，其中交换两个Int值：</p>

<p>func swapTwoInts(_ a: inout Int, _ b: inout Int) {<br/>
    let temporaryA = a<br/>
    a = b<br/>
    b = temporaryA<br/>
}<br/>
此功能利用了IN-OUT参数交换的价值a，并b按照中的说明输入-输出参数。</p>

<p>该swapTwoInts(<u>:</u>:)功能交换原值b成a，并且原值a成b。你可以调用这个函数来交换两个值Int的变量：</p>

<p>var someInt = 3<br/>
var anotherInt = 107<br/>
swapTwoInts(&amp;someInt, &amp;anotherInt)<br/>
print(<q>someInt is now (someInt), and anotherInt is now (anotherInt)</q>)<br/>
// Prints <q>someInt is now 107, and anotherInt is now 3</q><br/>
该swapTwoInts(<u>:</u>:)功能是有用的，但它只能与所用Int的值。如果你想交换两个String值，或两个Double值，你必须写更多的功能，如swapTwoStrings(<u>:</u>:)与swapTwoDoubles(<u>:</u>:)如下功能：</p>

<p>func swapTwoStrings(_ a: inout String, _ b: inout String) {<br/>
    let temporaryA = a<br/>
    a = b<br/>
    b = temporaryA<br/>
}</p>

<p>func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {<br/>
    let temporaryA = a<br/>
    a = b<br/>
    b = temporaryA<br/>
}<br/>
您可能已经注意到的尸体swapTwoInts(<u>:</u>:)，swapTwoStrings(<u>:</u>:)和swapTwoDoubles(<u>:</u>:)功能是相同的。唯一的区别是该值的，他们接受的类型（Int，String，和Double）。</p>

<p>这将是更为有用，并大大更灵活，编写可以互换的两个值的单一功能的任何类型。通用代码，可以写这样的功能。（这些功能的通用版本定义如下）。</p>

<p>注意</p>

<p>在所有的三个功能，重要的是该类型的a，并b被定义为彼此相同。如果a和b是相同类型的不，它不会是可能的交换它们的值。迅速是一种安全的语言，并且不允许（例如）类型的变量String和类型的变量Double相互交换值。试图这样做会被报告为编译时错误。</p>

<p>泛型函数</p>

<p>通用功能可以与任何类型的工作。这里的一个通用版本swapTwoInts(<u>:</u>:)从上面的功能，叫做swapTwoValues(<u>:</u>:)：</p>

<p>func swapTwoValues<T>(_ a: inout T, _ b: inout T) {<br/>
    let temporaryA = a<br/>
    a = b<br/>
    b = temporaryA<br/>
}<br/>
所述的本体swapTwoValues(<u>:</u>:)功能是相同的身体swapTwoInts(<u>:</u>:)功能。然而，第一行swapTwoValues(<u>:</u>:)是从稍微不同swapTwoInts(<u>:</u>:)。这是第一个行之间的比较：</p>

<p>func swapTwoInts(_ a: inout Int, _ b: inout Int)<br/>
func swapTwoValues<T>(_ a: inout T, _ b: inout T)<br/>
该函数的通用版本使用占位符类型名（称为T，在这种情况下），而不是一个实际的类型名称（例如Int，String或Double）。占位符类型名称不说什么什么T必须的，但它没有说，双方a并b必须是同一类型的T，不管T代表。实际类型到位使用T将每个时间确定swapTwoValues(<u>:</u>:)函数被调用。</p>

<p>另一不同之处在于通用功能的名称（swapTwoValues(<u>:</u>:)）之后的占位符类型名称（T）角括号内（<T>）。方括号告诉斯威夫特说T是在一个占位符类型名swapTwoValues(<u>:</u>:)函数定义。因为T是一个占位符，雨燕不会找所谓的实际类型T。</p>

<p>的swapTwoValues(<u>:</u>:)功能现在可以在相同的方式被称为swapTwoInts，除了它可以传递的两个值的任何类型的，只要这两个值是相同的类型为彼此的。每次swapTwoValues(<u>:</u>:)被调用时，要使用的类型T是从类型传递给函数值的推断。</p>

<p>在下面的两个例子中，T被推断为Int与String分别为：</p>

<p>var someInt = 3<br/>
var anotherInt = 107<br/>
swapTwoValues(&amp;someInt, &amp;anotherInt)<br/>
// someInt is now 107, and anotherInt is now 3</p>

<p>var someString = <q>hello</q><br/>
var anotherString = <q>world</q><br/>
swapTwoValues(&amp;someString, &amp;anotherString)<br/>
// someString is now <q>world</q>, and anotherString is now <q>hello</q><br/>
注意</p>

<p>在swapTwoValues(<u>:</u>:)上面定义函数的调用一个泛型函数的启发swap，这是斯威夫特标准库的一部分，让您可以在您的应用程序使用自动变得可用。如果你需要的行为，swapTwoValues(<u>:</u>:)在自己的代码的功能，你可以用斯威夫特的现有swap(<u>:</u>:)功能，而不是提供自己的实现。</p>

<p>类型参数</p>

<p>在swapTwoValues(<u>:</u>:)上述示例中，占位符类型T是的例子类型参数。类型参数指定和名称的占位符类型，并且函数名后写的，一对匹配的尖括号（如之间<T>）。</p>

<p>一旦您指定一个类型参数，你可以用它来 ​​定义一个函数的参数（如类型a和b该参数的swapTwoValues(<u>:</u>:)功能），或作为函数的返回类型，或作为函数体内的类型注释。在每种情况下，类型参数被替换为实际类型每当函数被调用。（在swapTwoValues(<u>:</u>:)上面的例子中，T用代替Int所述第一次调用函数，并与被替换String，它被称为第二次）。</p>

<p>您可以通过编写尖括号内的多个类型参数的名称，用逗号分隔提供多个类型参数。</p>

<p>命名类型参数</p>

<p>在大多数情况下，类型参数具有描述性名称，如Key与Value在Dictionary<Key, Value>和Element中Array<Element>，它告诉有关类型参数和通用型或函数它在所使用的关系的阅读器，但是，当没有它们之间的有意义的关系，这是传统的命名他们使用单字母如T，U，和V，如T在swapTwoValues(<u>:</u>:)上述的功能。</p>

<p>注意</p>

<p>总是给类型参数上驼峰名称（如T和MyTypeParameter），以表明他们是一个占位符类型，而不是一个值。</p>

<p>泛型类型</p>

<p>除了 ​​一般的功能，斯威夫特，您可以定义自己的泛型类型。这些自定义类，结构和枚举可与工作的任何类型的，以类似的方式，以Array和Dictionary。</p>

<p>本节将展示如何编写称为泛型集合类型Stack。堆栈是一个有序的设定值，类似于一个数组，但有更严格的操作集比雨燕的Array类型。阵列允许被插入，并在阵列中的任何位置删除新的项目。堆栈，但是，允许新的项目要追加只到集合的端部（被称为推上一个新值到栈）。同样，堆栈允许只从收集的端部（被称为已删除项目的弹出的值从堆栈）。</p>

<p>注意</p>

<p>栈的概念所使用的UINavigationController类，以在其导航层次结构的视图控制器建模。您调用UINavigationController类的pushViewController(<u>:animated:)方法来添加（或推）一个视图控制器到导航堆栈，其popViewControllerAnimated(</u>:)方法从导航堆栈中删除（或POP）一个视图控制器。堆栈是一个有用的集合模式，当您需要严格的“后进先出”的方法来管理的集合。</p>

<p>下图显示了一个堆栈推/流行的行为：</p>

<p>图片：../Art/stackPushPop_2x.png<br/>
目前在堆栈上三个值。<br/>
第四值到堆栈的顶部“推”。<br/>
堆栈现在拥有四个值，与最近的一个在顶部。<br/>
在堆栈顶部的项目被移除，或者“弹出”。<br/>
弹出一个值后，堆栈再次保持三个值。<br/>
下面是如何写一个堆栈的非通用版本，在这种情况下为一叠Int值：</p>

<p>struct IntStack {<br/>
    var items = <a href="">Int</a><br/>
    mutating func push(_ item: Int) {<br/>
        items.append(item)<br/>
    }<br/>
    mutating func pop() -&gt; Int {<br/>
        return items.removeLast()<br/>
    }<br/>
}<br/>
这种结构使用了一个Array称为属性items的值存储在堆栈中。Stack提供了两种方法，push并且pop，推和流行值和关闭堆栈。这些方法被标记为mutating的，因为它们需要修改（或变异）的结构的items阵列。</p>

<p>在IntStack上面所示类型只能与所用Int的值不过，。这将是更加有用定义一个通用 Stack类，可以管理的堆叠任何类型的值。</p>

<p>下面是相同的代码的通用版本：</p>

<p>struct Stack<Element> {<br/>
    var items = <a href="">Element</a><br/>
    mutating func push(_ item: Element) {<br/>
        items.append(item)<br/>
    }<br/>
    mutating func pop() -&gt; Element {<br/>
        return items.removeLast()<br/>
    }<br/>
}<br/>
注的通用版本如何Stack是基本上相同的非通用版本，但与称为类型参数Element的实际类型代替Int。该类型参数是一对尖括号（内书面<Element>）结构的名字之后。</p>

<p>Element定义了“某些类型的占位符名Element”将在后面提供。这种将来类型可以称为“ Element”内的结构的定义的任何地方。在这种情况下，Element被用作在三个地方的占位符：</p>

<p>要创建一个名为属性items，这与类型的值空数组初始化Element<br/>
要指定push(_:)方法称为单参数item，它必须是类型Element<br/>
以指定由返回的值pop()的方法将是type的值Element<br/>
因为它是一个通用的类型，Stack可用于创建的堆叠任何在夫特有效类型，以类似的方式，以Array和Dictionary。</p>

<p>您创建一个新的Stack写入存储在尖括号内堆栈中的类型实例。例如，创建一个新的字符串堆栈，你写的Stack<String>()：</p>

<p>var stackOfStrings = Stack<String>()<br/>
stackOfStrings.push(<q>uno</q>)<br/>
stackOfStrings.push(<q>dos</q>)<br/>
stackOfStrings.push(<q>tres</q>)<br/>
stackOfStrings.push(<q>cuatro</q>)<br/>
// the stack now contains 4 strings<br/>
以下是如何stackOfStrings在堆栈推这四个值后的样子：</p>

<p>图片：../Art/stackPushedFourStrings_2x.png<br/>
从弹出堆栈中删除一个值，并返回最高值，<q>cuatro</q>：</p>

<p>let fromTheTop = stackOfStrings.pop()<br/>
// fromTheTop is equal to <q>cuatro</q>, and the stack now contains 3 strings<br/>
这里的堆栈看起来如何弹出它的最高值后：</p>

<p>图片：../Art/stackPoppedOneString_2x.png<br/>
扩展泛型类型</p>

<p>当你扩展泛型类型，你不提供一个类型参数列表扩展的定义的一部分。相反，从所述类型参数列表原始类型定义是扩展的主体内可用的，和原始类型参数名被用来从原始定义指的类型的参数。</p>

<p>下面的例子扩展了通用的Stack类型添加一个只读属性来计算所谓的topItem，它返回堆栈顶部的项目，而不从栈中弹出它：</p>

<p>extension Stack {<br/>
    var topItem: Element? {<br/>
        return items.isEmpty ? nil : items[items.count - 1]<br/>
    }<br/>
}<br/>
该topItem属性返回类型的可选值Element。如果堆栈是空的，topItem返回nil; 如果栈不为空，topItem将返回在最后一个项目items数组。</p>

<p>请注意，这个扩展没有定义类型参数列表。相反，Stack类型的现有类型的参数名，Element时，在扩展中用于指示可选类型的topItem计算属性。</p>

<p>在topItem计算财产现在可以与任何使用Stack实例来访问，而没有删除它查询其顶部的项目：</p>

<p>if let topItem = stackOfStrings.topItem {<br/>
    print(<q>The top item on the stack is (topItem).</q>)<br/>
}<br/>
// Prints <q>The top item on the stack is tres.</q><br/>
类型约束</p>

<p>的swapTwoValues(<u>:</u>:)功能和Stack类型可以与任何类型的工作。然而，这有时是有益的实施某些类型约束上，可与普通的功能和通用类型中使用的类型。类型约束指定类型参数必须从一个特定的类继承，或符合特定协议或协议的组合物。</p>

<p>例如，迅捷的Dictionary类型放在可以用来作为用于字典的键的种类的限制。正如描述的字典，字典的键的类型必须是可哈希。也就是说，它必须提供一种方法，使本身唯一地表示的。Dictionary需要其键是哈希，以便它可以检查它是否已经包含一个特定键的值。没有这样的要求，Dictionary不能判断是否应插入或为特定的键取代一个值，也将能够找到对于给定的键已在词典中的一个值。</p>

<p>这个要求是通过在键类型的类型约束强制Dictionary，指定的密钥类型必须符合Hashable协议，在夫特标准库中定义的特殊协议。所有斯威夫特的基本类型（如String，Int，Double，和Bool）默认情况下哈希。</p>

<p>创建自定义泛型类型时，您可以定义自己的类型的限制，而这些限制提供多少泛型编程的力量。抽象的概念，喜欢Hashable在自己的概念特征方面描述的类型，而不是他们的明确的类型。</p>

<p>类型约束语法</p>

<p>您可以通过放置一个类型参数的名称后一个类或协议的约束，用冒号分隔，作为类型参数列表的一部分写类型约束。类型约束对泛型函数的基本语法如下所示（虽然语法是泛型类型相同）：</p>

<p>func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {<br/>
    // function body goes here<br/>
}<br/>
上述假设的功能有两个类型参数。第一类型参数，T，具有需要类型约束T为的一个子类SomeClass。第二类型参数，U，具有需要类型约束U，以符合该协议SomeProtocol。</p>

<p>键入限制行动</p>

<p>这里有一个所谓的非通用函数findIndex(ofString:in:)，它被赋予String的价值发现和数组String在其中找到它的值。该findIndex(ofString:in:)函数返回一个可选Int值，这将是该阵列中的第一匹配串的索引，如果它被发现，或者nil如果字符串无法找到：</p>

<p>func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {<br/>
    for (index, value) in array.enumerated() {<br/>
        if value == valueToFind {<br/>
            return index<br/>
        }<br/>
    }<br/>
    return nil<br/>
}<br/>
的findIndex(ofString:in:)功能可以被用来找到字符串数组字符串值：</p>

<p>let strings = [<q>cat</q>, <q>dog</q>, <q>llama</q>, <q>parakeet</q>, <q>terrapin</q>]<br/>
if let foundIndex = findIndex(ofString: <q>llama</q>, in: strings) {<br/>
    print(<q>The index of llama is (foundIndex)</q>)<br/>
}<br/>
// Prints <q>The index of llama is 2</q><br/>
在阵列查找值的索引的原则不仅是字符串是有用的，但是。您可以通过使用某种类型的值替换字符串中的任何一提写相同的功能泛型函数T来代替。</p>

<p>这里是你会如何期待的一个仿制版本findIndex(ofString:in:)，叫findIndex(of:in:)，被写入。注意，该函数的返回类型是静止Int?的，因为该函数返回一个可选索引号，而不是从阵列的可选值。被警告，虽然，这个功能不能编译，为之后的例子说明理由：</p>

<p>func findIndex<T>(of valueToFind: T, in array:[T]) -&gt; Int? {<br/>
    for (index, value) in array.enumerated() {<br/>
        if value == valueToFind {<br/>
            return index<br/>
        }<br/>
    }<br/>
    return nil<br/>
}<br/>
如上面写的这个功能不能编译。问题在于平等检查“， if value == valueToFind”。不是每一个斯威夫特类型都可以用等于运算符进行比较（==）。如果你创建自己的类或结构来表示一个复杂的数据模型，例如，那么的意思是“等于”为类或结构不是那种斯威夫特能猜出你。正因为如此，它是不可能保证此代码将努力为每一个可能的类型T，并且当您试图编译代码时报告相应的错误。</p>

<p>一切都没有丢失然而，。雨燕标准库定义了一个所谓的协议Equatable，它要求任何合乎规范的类型来实现等于运算符（==）和不等于运算符（!=）来比较该类型的任何两个值。所有斯威夫特的标准类型的自动支持的Equatable协议。</p>

<p>即任何类型的Equatable可以安全地与使用findIndex(of:in:)的功能，因为它保证以支持等于操作员。为了表达这个事实，你写的类型约束Equatable的类型参数的定义的一部分，当你定义函数：</p>

<p>func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -&gt; Int? {<br/>
    for (index, value) in array.enumerated() {<br/>
        if value == valueToFind {<br/>
            return index<br/>
        }<br/>
    }<br/>
    return nil<br/>
}<br/>
为单一类型的参数findIndex(of:in:)被写成T: Equatable，表示“任何类型的T符合的Equatable协议”。</p>

<p>的findIndex(of:in:)功能现在编译成功，并且可以与任何类型的即可以使用Equatable，例如Double或String：</p>

<p>let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])<br/>
// doubleIndex is an optional Int with no value, because 9.3 is not in the array<br/>
let stringIndex = findIndex(of: <q>Andrea</q>, in: [<q>Mike</q>, <q>Malcolm</q>, <q>Andrea</q>])<br/>
// stringIndex is an optional Int containing a value of 2<br/>
相关类型</p>

<p>当定义一个协议，它有时是有益的声明一个或多个相关联的类型作为该协议的定义的一部分。一个相关联的类型给出的占位符的名称被用作协议的一部分的类型。实际类型用于该相关类型没有指定，直到该协议被采用。相关类型与指定的associatedtype关键字。</p>

<p>在行动相关类型</p>

<p>这里有一个所谓的协议的一个例子Container，它声明相关的类型，称为ItemType：</p>

<p>protocol Container {<br/>
    associatedtype ItemType<br/>
    mutating func append(_ item: ItemType)<br/>
    var count: Int { get }<br/>
    subscript(i: Int) -&gt; ItemType { get }<br/>
}<br/>
该Container协议定义了三个必需的功能，任何容器必须提供：</p>

<p>它必须能够以一个新的项添加到该容器用append(_:)方法。<br/>
它必须能够通过访问在容器中的物品的计数count返回一个属性Int值。<br/>
它必须能够与一个下标，它接受一个检索容器中的每个项Int的索引值。<br/>
该协议不指定在容器中的物品如何应存储或什么类型的它们允许。该协议仅指定的功能，任何类型必须为了提供被认为是一个三个比特Container。相符的类型可以提供额外的功能，只要它满足这三个要求。</p>

<p>一个符合任何类型的Container协议必须能够指定其存储值的类型。具体地说，它必须确保正确的类型的唯一项目被添加到容器中，并且它必须明确由其标返回的项目的类型。</p>

<p>定义这些要求，Container协议需要一种方法来指一个容器将保持的元素的类型，而无需知道该类型是什么特定的容器中。该Container协议需要指定传递给任何值append(_:)方法必须具有相同的类型的容器的元件类型，并且通过容器的标返回的值将是相同的类型的容器的元件的类型。</p>

<p>为了实现这一目标，该Container协议声明称为关联的类型ItemType，写为associatedtype ItemType。该协议并没有定义什么ItemType是-信息留下任何符合要求的类型来提供。尽管如此，ItemType别名提供了一种指在一个项目的类型Container，并以限定用于与使用的类型append(_:)的方法和下标，以确保任何预期的行为Container被执行。</p>

<p>这里的非泛型的版本IntStack类型从早期的，适应于符合Container协议：</p>

<p>struct IntStack: Container {<br/>
    // original IntStack implementation<br/>
    var items = <a href="">Int</a><br/>
    mutating func push(_ item: Int) {<br/>
        items.append(item)<br/>
    }<br/>
    mutating func pop() -&gt; Int {<br/>
        return items.removeLast()<br/>
    }<br/>
    // conformance to the Container protocol<br/>
    typealias ItemType = Int<br/>
    mutating func append(_ item: Int) {<br/>
        self.push(item)<br/>
    }<br/>
    var count: Int {<br/>
        return items.count<br/>
    }<br/>
    subscript(i: Int) -&gt; Int {<br/>
        return items[i]<br/>
    }<br/>
}<br/>
该IntStack类型实现所有三个Container协议的要求，并在每种情况下包裹的部分IntStack类型的现有功能，以满足这些要求。</p>

<p>此外，IntStack指定该实施Container，适当ItemType使用是一种类型的Int。的定义typealias ItemType = Int变成抽象类型的ItemType成具体类型的Int这一实施的Container协议。</p>

<p>由于斯威夫特的类型推断，你实际上并不需要声明一个具体ItemType的Int作为定义的一部分IntStack。由于IntStack符合所有的要求Container协议，斯威夫特可以推断出适当的ItemType使用，只需通过查看类型append(_:)方法的item参数和标的返回类型。事实上，如果你删除typealias ItemType = Int上面从代码行，一切仍然有效，因为很明显应该使用什么类型ItemType。</p>

<p>您也可以使通用Stack型符合Container协议：</p>

<p>struct Stack<Element>: Container {<br/>
    // original Stack<Element> implementation<br/>
    var items = <a href="">Element</a><br/>
    mutating func push(_ item: Element) {<br/>
        items.append(item)<br/>
    }<br/>
    mutating func pop() -&gt; Element {<br/>
        return items.removeLast()<br/>
    }<br/>
    // conformance to the Container protocol<br/>
    mutating func append(_ item: Element) {<br/>
        self.push(item)<br/>
    }<br/>
    var count: Int {<br/>
        return items.count<br/>
    }<br/>
    subscript(i: Int) -&gt; Element {<br/>
        return items[i]<br/>
    }<br/>
}<br/>
这一次，类型参数Element作为类型append(_:)方法的item参数和标的返回类型。因此迅速可以推断出Element是适当的类型为使用ItemType此特定容器。</p>

<p>扩展现有类型指定一个相关联的类型</p>

<p>您可以扩展现有的类型一致性添加到一个协议，在描述同一个扩展添加协议一致性。这包括具有相关联的类型的协议。</p>

<p>斯威夫特的Array类型已经提供了一个append(_:)方法，一个count属性，与一个下标Int索引检索其元素。这三个功能相匹配的要求的Container协议。这意味着，你可以扩展Array到符合Container简单地宣布协议Array采用的协议。为此，您可以用空的扩展，如描述的声明协议采用的扩展名：</p>

<p>extension Array: Container {}<br/>
Array的现有append(_:)方法和标让斯威夫特推断出相应的类型使用ItemType，只是作为一个通用的Stack上述类型。定义该扩展后，您可以使用任何Array作为Container。</p>

<p>通用WHERE子句</p>

<p>类型约束，如描述的类型约束，使您能够定义与通用功能或类型关联的参数要求。</p>

<p>它也可以是用于定义关联的类型的需求是有用的。您可以通过定义一个做到这一点的通用where子句。一个通用的where条款，您可以要求相应的类型必须遵循一定的协议，或者某些类型的参数和相关类型必须相同。一个通用的where条款开始与where关键字，其次是相关类型或类型和相关类型之间的平等关系的约束。你写一个通用的where一类或函数体的大括号前右条款。</p>

<p>下面的例子中定义了被称为通用函数allItemsMatch，它检查以查看两个Container实例包含在相同的顺序相同的项目。该函数返回一个布尔值，true如果所有项目匹配和值false，如果他们不这样做。</p>

<p>两个容器进行检查不必是同一类型的容器（尽管它们也可以），但是它们必须持有相同类型的物品。这一要求是通过类型约束和通用组合表示where子句：</p>

<p>func allItemsMatch<C1: Container, C2: Container><br/>
    (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool<br/>
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {</p>

<pre><code>    // Check that both containers contain the same number of items.
    if someContainer.count != anotherContainer.count {
        return false
    }

    // Check each pair of items to see if they are equivalent.
    for i in 0..&lt;someContainer.count {
        if someContainer[i] != anotherContainer[i] {
            return false
        }
    }

    // All items match, so return true.
    return true
</code></pre>

<p>}<br/>
该函数有两个参数调用someContainer和anotherContainer。该someContainer参数是类型C1，并且anotherContainer参数是类型C2。双方C1并C2当函数被调用，以确定两种容器类型的类型参数。</p>

<p>以下要求放在函数两个类型参数：</p>

<p>C1必须符合Container协议（写C1: Container）。<br/>
C2还必须符合Container协议（写C2: Container）。<br/>
在ItemType为C1必须相同，ItemType为C2（写C1.ItemType == C2.ItemType）。<br/>
在ItemType对C1必须符合Equatable协议（写C1.ItemType: Equatable）。<br/>
在第一和第二要求，在该函数的类型参数列表中定义的，并且在第三和第四的要求的功能的通用定义的where条款。</p>

<p>这些要求是指：</p>

<p>someContainer是类型的容器C1。<br/>
anotherContainer是类型的容器C2。<br/>
someContainer与anotherContainer包含相同类型的物品。<br/>
中的项目someContainer可以与不等于操作员（检查!=），以查看它们是否彼此不同。<br/>
在第三和第四的要求结合起来，意味着在项目anotherContainer罐也可以与检查!=操作者，因为他们是完全相同的类型中的项目someContainer。</p>

<p>这些要求使allItemsMatch(<u>:</u>:)功能到两个容器比较，即使它们是不同的容器类型。</p>

<p>该allItemsMatch(<u>:</u>:)功能通过检查两个容器包含相同数量的项目开始。如果它们包含不同数量的物品，没有办法，他们可以匹配，函数返回false。</p>

<p>在使该检查，函数迭代的所有项目的后someContainer带for- in环和半开区间运算符（..&lt;）。对于每个项目，该功能检查从项是否someContainer不等于在相应的项目anotherContainer，如果两个项不相等，则这两个容器不匹配，并且在函数返回false。</p>

<p>如果循环完成且没有发现不匹配，两个容器匹配，并且在函数返回true。</p>

<p>下面是如何allItemsMatch(<u>:</u>:)函数看起来在行动：</p>

<p>var stackOfStrings = Stack<String>()<br/>
stackOfStrings.push(<q>uno</q>)<br/>
stackOfStrings.push(<q>dos</q>)<br/>
stackOfStrings.push(<q>tres</q>)</p>

<p>var arrayOfStrings = [<q>uno</q>, <q>dos</q>, <q>tres</q>]</p>

<p>if allItemsMatch(stackOfStrings, arrayOfStrings) {<br/>
    print(<q>All items match.</q>)<br/>
} else {<br/>
    print(<q>Not all items match.</q>)<br/>
}<br/>
// Prints <q>All items match.</q><br/>
上面的例子创建一个Stack实例来存储String值，推三串入堆栈。这个例子也创建一个Array使用数组常量，其中包含三个相同的字符串作为堆栈初始化实例。尽管堆栈和阵列是不同类型的，它们都符合Container协议，都包含相同类型的值。因此，您可以调用allItemsMatch(<u>:</u>:)函数与这两个容器中，作为它的参数。在上面的例子中，allItemsMatch(<u>:</u>:)函数正确地报告所有在两个容器中的项目的匹配。</p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="14743600314526.html"  title="Previous Post: 协议">&laquo; 协议</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="14743600592705.html" 
	        title="Next Post: 访问控制">访问控制 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '14743600461552.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
